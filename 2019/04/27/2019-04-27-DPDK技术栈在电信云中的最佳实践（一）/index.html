<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon32.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16.png?v=7.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="本文篇幅有限，很难用短短几语就勾勒出DPDK的完整轮廓，概括来说，DPDK是一个技术栈，主要用于Intel架构的服务器领域，其主要目的就是提升x86标准服务器的转发性能。因此，本文只重点介绍DPDK平台部分技术在电信云中的最佳实践。">
<meta name="keywords" content="电信云">
<meta property="og:type" content="article">
<meta property="og:title" content="2019-04-27-DPDK技术栈在电信云中的最佳实践（一）">
<meta property="og:url" content="https://kkutysllb.cn/2019/04/27/2019-04-27-DPDK技术栈在电信云中的最佳实践（一）/index.html">
<meta property="og:site_name" content="一花一菩提，一云一世界">
<meta property="og:description" content="本文篇幅有限，很难用短短几语就勾勒出DPDK的完整轮廓，概括来说，DPDK是一个技术栈，主要用于Intel架构的服务器领域，其主要目的就是提升x86标准服务器的转发性能。因此，本文只重点介绍DPDK平台部分技术在电信云中的最佳实践。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://i.loli.net/2019/04/27/5cc3e29dacd51.jpg">
<meta property="og:image" content="https://i.loli.net/2019/04/27/5cc3e2d3d69cf.jpg">
<meta property="og:image" content="https://i.loli.net/2019/04/27/5cc3e3322d7e4.jpg">
<meta property="og:image" content="https://i.loli.net/2019/04/27/5cc3e38aabc9c.jpg">
<meta property="og:image" content="https://i.loli.net/2019/04/27/5cc3e3b41a473.jpg">
<meta property="og:image" content="https://i.loli.net/2019/04/27/5cc3e3dbd46c5.jpg">
<meta property="og:image" content="https://i.loli.net/2019/04/27/5cc3e5b16a991.jpg">
<meta property="og:image" content="https://i.loli.net/2019/04/27/5cc3e5cc93de5.jpg">
<meta property="og:image" content="https://i.loli.net/2019/04/27/5cc3e64a94e86.jpg">
<meta property="og:image" content="https://i.loli.net/2019/04/27/5cc3e66c1fc6d.jpg">
<meta property="og:image" content="https://i.loli.net/2019/04/27/5cc3e6d6612ea.jpg">
<meta property="og:image" content="https://i.loli.net/2019/04/27/5cc3e702f0608.jpg">
<meta property="og:image" content="https://i.loli.net/2019/04/27/5cc3e72df17eb.jpg">
<meta property="og:image" content="https://i.loli.net/2019/04/27/5cc3e75475642.jpg">
<meta property="og:image" content="https://i.loli.net/2019/04/27/5cc3e78523f21.jpg">
<meta property="og:image" content="https://i.loli.net/2019/04/27/5cc3e7a0dc86a.jpg">
<meta property="og:image" content="https://i.loli.net/2019/04/27/5cc3e7c6deca7.jpg">
<meta property="og:image" content="https://i.loli.net/2019/04/27/5cc3e8c3924d0.jpg">
<meta property="og:image" content="https://i.loli.net/2019/04/27/5cc3e91e07d20.jpg">
<meta property="og:image" content="https://i.loli.net/2019/04/27/5cc3eb2155fbf.jpg">
<meta property="og:updated_time" content="2019-04-27T05:39:55.490Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="2019-04-27-DPDK技术栈在电信云中的最佳实践（一）">
<meta name="twitter:description" content="本文篇幅有限，很难用短短几语就勾勒出DPDK的完整轮廓，概括来说，DPDK是一个技术栈，主要用于Intel架构的服务器领域，其主要目的就是提升x86标准服务器的转发性能。因此，本文只重点介绍DPDK平台部分技术在电信云中的最佳实践。">
<meta name="twitter:image" content="https://i.loli.net/2019/04/27/5cc3e29dacd51.jpg">



  <link rel="alternate" href="/atom.xml" title="一花一菩提，一云一世界" type="application/atom+xml">




  <link rel="canonical" href="https://kkutysllb.cn/2019/04/27/2019-04-27-DPDK技术栈在电信云中的最佳实践（一）/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>2019-04-27-DPDK技术栈在电信云中的最佳实践（一） | 一花一菩提，一云一世界</title>
  






  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?45d7282259ecad100b2fe7e379853e80";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>







  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
	
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">一花一菩提，一云一世界</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">佛系ICT人士技术博客</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kkutysllb.cn/2019/04/27/2019-04-27-DPDK技术栈在电信云中的最佳实践（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="kkutysllb">
      <meta itemprop="description" content="容易走的路是下坡路<br>总是不经意间装个X得罪一票人">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一花一菩提，一云一世界">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">2019-04-27-DPDK技术栈在电信云中的最佳实践（一）

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-27 12:59:18 / 修改时间：13:39:55" itemprop="dateCreated datePublished" datetime="2019-04-27T12:59:18+08:00">2019-04-27</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/NFV关键技术/" itemprop="url" rel="index"><span itemprop="name">NFV关键技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">24k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">22 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本文篇幅有限，很难用短短几语就勾勒出DPDK的完整轮廓，概括来说，DPDK是一个技术栈，主要用于Intel架构的服务器领域，其主要目的就是提升x86标准服务器的转发性能。因此，本文只重点介绍DPDK平台部分技术在电信云中的最佳实践。<a id="more"></a></p>
<h2 id="为什么需要DPDK？"><a href="#为什么需要DPDK？" class="headerlink" title="为什么需要DPDK？"></a>为什么需要DPDK？</h2><p>在IA上，网络数据包处理远早于DPDK而存在。从商业版的Windows到开源的Linux操作系统，所有跨主机通信几乎都会涉及网络协议栈以及底层网卡驱动对于数据包的处理。然而，低速网络数据转发与高速网络数据转发的处理对系统的要求完全不一样。以Linux为例，传统网络设备驱动包处理的动作可以概括如下：</p>
<ol>
<li>数据包到达网卡设备。</li>
<li>网卡设备依据配置进行DMA操作。</li>
<li>网卡发送中断，唤醒处理器。</li>
<li>驱动软件填充读写缓冲区数据结构。</li>
<li>数据报文达到内核协议栈，进行高层处理。</li>
<li>如果最终应用在用户态，数据从内核搬移到用户态。</li>
<li>如果最终应用在内核态，在内核继续进行。</li>
</ol>
<p>随着网络接口带宽从千兆向万兆迈进，原先每个报文就会触发一个中断，中断带来的开销变得突出，大量数据到来会触发频繁的中断开销，导致系统无法承受。</p>
<p>在网络包高性能转发技术领域，有两个著名的技术框架NAPI和Netmap。NAPI策略用于高吞吐的场景，其策略是系统被中断唤醒后，尽量使用轮询的方式一次处理多个数据包，直到网络再次空闲重新转入中断等待，其目的就是解决数据包在转发过程过程中频繁中断引入的大量系统开销。Netmap就是采用共享数据包池的方式，减少内核到用户空间的包复制，从而解决大多数场景下需要把包从内核的缓冲区复制到用户缓冲区引入大量系统开销问题。</p>
<p>NAPI与Netmap两方面的努力其实已经明显改善了传统Linux系统上的包处理能力，但是，Linux作为分时操作系统，要将CPU的执行时间合理地调度给需要运行的任务。相对于公平分时，不可避免的就是适时调度。早些年CPU核数比较少，为了每个任务都得到响应处理，进行充分分时，用效率换响应，是一个理想的策略。现今CPU核数越来越多，性能越来越强，为了追求极端的高性能高效率，分时就不一定总是上佳的策略。以Netmap为例，即便其减少了内核到用户空间的内存复制，但内核驱动的收发包处理和用户态线程依旧由操作系统调度执行，除去任务切换本身的开销，由切换导致的后续cache替换（不同任务内存热点不同），对性能也会产生负面的影响。为此，Intel针对IA架构的这些问题，就提出了DPDK技术栈的架构，其根本目的就是尽量采用用户态驱动能力来替代内核态驱动，从而减少内核态的开销，提升转发性能。</p>
<h2 id="鸟瞰DPDK"><a href="#鸟瞰DPDK" class="headerlink" title="鸟瞰DPDK"></a>鸟瞰DPDK</h2><p>什么是DPDK？在《DPDK深入浅出》一书中，有以下一段描述：</p>
<blockquote>
<p>针对不同的对象，其定义并不相同。对于普通用户来说，它可能是一个性能出色的包数据处理加速软件库；对于开发者来说，它可能是一个实践包处理新想法的创新工场；对于性能调优者来说，它可能又是一个绝佳的成果分享平台。当下火热的网络功能虚拟化，则将DPDK放在一个重要的基石位置。</p>
</blockquote>
<p>DPDK最初的动机很简单，就是为了证明IA多核处理器能够支撑高性能数据包处理。随着早期目标的达成和更多通用处理器体系的加入，DPDK逐渐成为通用多核处理器高性能数据包处理的业界标杆。</p>
<p>目前，DPDK技术主要应用于计算领域的硬件加速器、通信领域的网络处理器和IT领域的多核处理器。随着软件（例如，DPDK）在I/O性能提升上的不断创新，将多核处理器的竞争力提升到一个前所未有的高度。在SDN/NFV领域，DPDK技术得到了空前应用，产生了不少最佳实践案例。</p>
<p><img src="https://i.loli.net/2019/04/27/5cc3e29dacd51.jpg"></p>
<p>DPDK提出的目的就是为IA上的高速包处理。下图所示的DPDK主要模块分解展示了以基础软件库的形式，为上层应用的开发提供一个高性能的基础I/O开发包。主要利用了有助于包处理的软硬件特性，如大页、缓存行对齐、线程绑定、预取、NUMA、IA最新指令的利用、Intel DDIO、内存交叉访问等。</p>
<p><img src="https://i.loli.net/2019/04/27/5cc3e2d3d69cf.jpg"></p>
<ul>
<li><strong>核心库Core Libs</strong>，提供系统抽象、大页内存、缓存池、定时器及无锁环等基础组件。</li>
<li><strong>PMD库</strong>，提供全用户态的驱动，以便通过轮询和线程绑定得到极高的网络吞吐，支持各种本地和虚拟的网卡。</li>
<li><strong>Classify库</strong>，支持精确匹配（Exact Match）、最长匹配（LPM）和通配符匹配（ACL），提供常用包处理的查表操作。</li>
<li><strong>QoS库</strong>，提供网络服务质量相关组件，如限速（Meter）和调度（Sched）。</li>
</ul>
<p>除了这些组件，DPDK还提供了几个平台特性，比如节能考虑的运行时频率调整（POWER），与Linux kernel stack建立快速通道的KNI（Kernel Network Interface）。而Packet Framework和DISTRIB为搭建更复杂的多核流水线处理模型提供了基础的组件。</p>
<p>DPDK软件包内有一个最基本的三层转发实例（l3fwd），可用于测试双路服务器整系统的吞吐能力，通过现场实验，可以达到220Gbit/s的数据报文吞吐能力。除了通过硬件或者软件提升性能之外，如今DPDK整系统报文吞吐能力上限已经不再受限于CPU的核数，当前瓶颈在于PCIe（IO总线）的LANE数。换句话说，系统性能的整体I/O天花板不再是CPU，而是系统所提供的所有PCIe LANE的带宽，也就是能插入多少个高速以太网接口卡。</p>
<p>在这样的性能基础上，网络节点的软化（NFV）就成为可能。对于网络节点上运转的不同形态的网络功能，通过软化并适配到一个通用的硬件平台，就是软硬件解耦。解耦正是NFV的一个核心思想，而硬件解耦的多个网络功能在单一通用节点上的隔离共生问题，就是另一个核心思想—<strong>虚拟化</strong>。</p>
<h2 id="电信云中数据包转发性能提升中的DPDK"><a href="#电信云中数据包转发性能提升中的DPDK" class="headerlink" title="电信云中数据包转发性能提升中的DPDK"></a>电信云中数据包转发性能提升中的DPDK</h2><h3 id="cache的作用"><a href="#cache的作用" class="headerlink" title="cache的作用"></a>cache的作用</h3><p>在当今服务器领域，一个处理器通常包含多个核心（Core），集成Cache子系统，内存子系统通过内部或外部总线与其通信。在经典计算机系统中一般都有两个标准化的部分：北桥（North Bridge）和南桥（SouthBridge）。它们是处理器和内存以及其他外设沟通的渠道。在这类系统中，北桥就是真个架构的瓶颈，一旦北桥处理不过来或故障，整个系统的处理效率就会变低或瘫痪。因此，后来计算机系统中只存在南桥芯片，而北桥部分就被全部移植到CPU的SoC中，其中最重要的部分就是内存控制器，并在此基础上进一步衍生出NUMA和MPP架构，这个放在后面会讲。</p>
<p>我们在本科学习计算机基础课程时，都知道计算机的内存分为SRAM、DRAM、SDRAM和DDR(1/2/3/4)等不同类型。在早期的PC系统中，主要使用DRAM和SDRAM来作为内存，相比SRAM在成本、功耗方面有不小的优势，而且速度也还可以。后来在现今的PC系统中，利用SDRAM在一个时钟周期的上下边沿进行数据读写，整体数据吞吐率带宽翻倍，也就是DDR RAM，DDR根据不同的主频，又分为DDR1/DDR2/DDR3/DDR4。而SRAM，由于其功耗高、成本高，速度很快，一般都作为CPU的cache使用，目前都被封装的CPU的SoC中。</p>
<p>一般来说，Cache由三级组成，之所以对Cache进行分级，也是从成本和生产工艺的角度考虑的。一级（L1）最快，但是容量最小；三级（LLC，Last Level Cache）最慢，但是容量最大。</p>
<p><img src="https://i.loli.net/2019/04/27/5cc3e3322d7e4.jpg"></p>
<ul>
<li><strong>一级Cache</strong>：一般分为数据Cache和指令Cache，数据Cache用来存储数据，而指令Cache用于存放指令。这种Cache速度最快，一般处理器只需要3～5个指令周期就能访问到数据，因此成本高，容量小，一般都只有几十KB。</li>
<li><strong>二级Cache：</strong>和一级Cache分为数据Cache和指令Cache不同，数据和指令都无差别地存放在一起。速度相比一级Cache慢一些，处理器大约需要十几个处理器周期才能访问到数据，容量也相对来说大一些，一般有几百KB到几MB不等。</li>
<li><strong>三级Cache：</strong>速度更慢，处理器需要几十个处理器周期才能访问到数据，容量更大，一般都有几MB到几十个MB。在多核处理器内部，三级Cache由所有的核心所共有。这样的共享方式，其实也带来一个问题，有的处理器可能会极大地占用三级Cache，导致其他处理器只能占用极小的容量，从而导致Cache不命中，性能下降。因此，Intel公司推出了Intel® CAT技术，确保有一个公平，或者说软件可配置的算法来控制每个核心可以用到的Cache大小，有兴趣的可参考<a href="https://software.intel.com/zh-cn/articles/introduction-to-cache-allocation-technology?_ga=2.54835683.913561365.1556263296-1903721401.1556263296" target="_blank" rel="noopener">https://software.intel.com/zh-cn/articles/introduction-to-cache-allocation-technology?_ga=2.54835683.913561365.1556263296-1903721401.1556263296</a>。</li>
</ul>
<p>为了将cache与内存进行关联，需要对cache和内存进行分块，并采用一定的映射算法进行关联。分块就是将Cache和内存以块为单位进行数据交换，块的大小通常以在内存的一个存储周期中能够访问到的数据长度为限。当今主流块的大小都是64字节，因此一个<strong>Cache line</strong>就是指64个字节大小的数据块。而映射算法是指把内存地址空间映射到Cache地址空间。具体来说，就是把存放在内存中的内容按照一定规则装入到Cache中，并建立内存地址与Cache地址之间的对应关系。当CPU需要访问这个数据块内容时，只需要把内存地址转换成Cache地址，从而在Cache中找到该数据块，最终返回给CPU。</p>
<p>根据Cache和内存之间的映射关系的不同，Cache可以分为三类：第一类是<strong>全关联型Cache</strong>（full associative cache），第二类是<strong>直接关联型Cache</strong>（direct mapped cache），第三类是<strong>组关联型Cache</strong>（N-ways associative cache）。</p>
<p><strong>全关联型cache</strong>：需要在cache中建立一个目录表，目录表的每一项由内存地址、cache块号和一个有效位组成。当CPU需要访问某个内存地址时，首先查询该目录表判断该内容是否缓存在Cache中，如果在，就直接从cache中读取内容；如果不在，就去通过内存地址转换去内存冲读取。具体原理如下：</p>
<p><img src="https://i.loli.net/2019/04/27/5cc3e38aabc9c.jpg"></p>
<p>首先，用内存的块地址A在Cache的目录表中进行查询，如果找到等值的内存块地址，检查有效位是否有效，只有有效的情况下，才能通过Cache块号在Cache中找到缓存的内存，并且加上块内地址B，找到相应数据，这时则称为Cache命中，处理器拿到数据返回；否则称为不命中，CPU则需要在内存中读取相应的数据。使用全关联型Cache，块的冲突最小（没有冲突），Cache的利用率也高，但是需要一个访问速度很快的相联存储器。随着Cache容量的增加，其电路设计变得十分复杂，因此一般只有TLB cache才会设计成全关联型。</p>
<p><strong>直接关联型Cache：</strong>是指将某一块内存映射到Cache的一个特定的块，即Cache line中。假设一个Cache中总共存在N个Cache line，那么内存就被分成N等分，其中每一等分对应一个Cache line。比如：Cache的大小是2K，而一个Cache line的大小是64B，那么就一共有2K/64B=32个Cache line，那么对应我们的内存，第1块（地址0～63），第33块（地址64<em>32～64</em>33-1），以及第（N<em>32+1）块都被映射到Cache第一块中；同理，第2块，第34块，以及第（N</em>32+2）块都被映射到Cache第二块中；可以依次类推其他内存块。直接关联型Cache的目录表只有两部分组成：<strong>区号</strong>和<strong>有效位</strong>。具体原理如下：</p>
<p><img src="https://i.loli.net/2019/04/27/5cc3e3b41a473.jpg"></p>
<p>首先，内存地址被分成三部分：<strong>区号A、块号B</strong>和<strong>块内地址C</strong>。根据区号A在目录表中找到完全相等的区号，并且在有效位有效的情况下，说明该数据在Cache中，然后通过内存地址的块号B获得在Cache中的块地址，加上块内地址C，最终找到数据。如果在目录表中找不到相等的区号，或者有效位无效的情况下，则说明该内容不在Cache中，需要到内存中读取。可以看出，直接关联是一种很“死”的映射方法，当映射到同一个Cache块的多个内存块同时需要缓存在Cache中时，只有一个内存块能够缓存，其他块需要被“淘汰”掉。因此，直接关联型命中率是最低的，但是其实现方式最为简单，匹配速度也最快。</p>
<p><strong>组关联型Cache：</strong>是目前Cache中用的比较广泛的一种方式，是前两种Cache的折中形式。在这种方式下，内存被分为很多组，一个组的大小为多个Cache line的大小，一个组映射到对应的多个连续的Cache line，也就是一个Cache组，并且该组内的任意一块可以映射到对应Cache组的任意一个。可以看出，在组外，其采用直接关联型Cache的映射方式，而在组内，则采用全关联型Cache的映射方式。比如：有一个4路组关联型Cache，其大小为1M，一个Cache line的大小为64B，那么总共有16K个Cache line，但是在4路组关联的情况下，就拥有了4K个组，每个组有4个Cache line。一个内存单元可以缓存到它所对应的组中的任意一个Cache line中去。具体原理如下：</p>
<p><img src="https://i.loli.net/2019/04/27/5cc3e3dbd46c5.jpg"></p>
<p>目录表由三部分组成：<strong>“区号+块号”、Cache块号</strong>和<strong>有效位</strong>。一个内存地址被分成四部分：<strong>区号A、组号B、块号C</strong>和<strong>块内地址D</strong>。首先，根据组号B按地址查找到一组目录表项；然后，根据区号A和块号C在该组中进行关联查找（即并行查找，为了提高效率），如果匹配且有效位有效，则表明该数据块缓存在Cache中，得到Cache块号，加上块内地址D，可以得到该内存地址在Cache中映射的地址，得到数据；如果没有找到匹配项或者有效位无效，则表示该内存块不在Cache中，需要处理器到内存中读取。</p>
<p>Cache之所以能够提高系统性能，主要是因为程序执行存在局部性现象，即<strong>时间局部性（程序中指令和数据在时间上的关联性，比如：循环体中的变量和指令）</strong>和<strong>空间局部性（程序中指令和数据在空间上的关联性，比如：列表数据结构中的元素）。</strong>cache就可以根据程序的局部性特点，以及当前执行状态、历史执行过程、软件提示等信息，然后以一定的合理方法，在数据/指令被使用前取入Cache，也就是<strong>cache预取</strong>。</p>
<p>内存的数据被加载进cache后，最终还是需要写回到内存中，这个写回的过程存在两种策略：</p>
<p><strong>直写（write-through）：</strong>在CPU对Cache写入的同时，将数据写入到内存中。这种策略保证了在任何时刻，内存的数据和Cache中的数据都是同步的，这种方式简单、可靠。但由于CPU每次对Cache更新时都要对内存进行写操作，总线工作繁忙，内存的带宽被大大占用，因此运行速度会受到影响。</p>
<p><strong>回写（write-back）：</strong>回写相对于直写而言是一种高效的方法。回写系统通过将Cache line的标志位字段添加一个Dirty标志位，当处理器在改写了某个Cache line后，并不是马上把其写回内存，而是将该Cache line的Dirty标志设置为1。当处理器再次修改该Cache line并且写回到Cache中，查表发现该Dirty位已经为1，则先将Cache line内容写回到内存中相应的位置，再将新数据写到Cache中。</p>
<p>除了上述这两种写策略，还有WC（write-combining）和UC（uncacheable）。这两种策略都是针对特殊的地址空间来使用的，这里不做详细讨论，有兴趣的可以参考Intel官方社区。</p>
<p>在采用回写策略的架构中，如果多个CPU同时对一个cache line进行修改后的写回操作，就存在“脏”数据区域的问题，这就是cache一致性问题。其本质原因是<strong>存在多个处理器独占的Cache，而不是多个处理器。</strong>解决Cache一致性问题的机制有两种：基于目录的协议（Directory-based protocol）和总线窥探协议（Bus snooping protocol）。这里因为篇幅问题，不再展开讨论，有兴趣的可参见《深入浅出DPDK》一书相关内容。</p>
<p>事实上，Cache对于绝大多数程序员来说都是透明不可见的，cache完成数据缓存的所有操作都是硬件自动完成的。但是，硬件也不是完全智能的。因此，Intel体系架构引入了能够对Cache进行预取的指令，使一些对程序执行效率有很高要求的程序员能够一定程度上控制Cache，加快程序的执行。DPDK对cache进行预取操作如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (nb_rx &lt; nb_pkts) </span><br><span class="line">&#123; </span><br><span class="line">	rxdp = &amp;rx_ring[rx_id]; <span class="comment">//读取接收描述符 </span></span><br><span class="line">	staterr = rxdp-&gt;wb.upper.status_error; <span class="comment">//检查是否有报文收到 </span></span><br><span class="line">	<span class="keyword">if</span> (！(staterr &amp; rte_cpu_to_le_32(IXGBE_RXDADV_STAT_DD)))</span><br><span class="line">		<span class="keyword">break</span>; </span><br><span class="line">	rxd = *rxdp; <span class="comment">//分配数据缓冲区 </span></span><br><span class="line">	nmb = rte_rxmbuf_alloc(rxq-&gt;mb_pool); </span><br><span class="line">	nb_hold++; <span class="comment">//读取控制结构体 </span></span><br><span class="line">	rxe = &amp;sw_ring[rx_id]; </span><br><span class="line">	…… </span><br><span class="line">	rx_id++; </span><br><span class="line">	<span class="keyword">if</span> (rx_id == rxq-&gt;nb_rx_desc) </span><br><span class="line">    &#123;</span><br><span class="line">        rx_id = <span class="number">0</span>; <span class="comment">//预取下一个控制结构体mbuf</span></span><br><span class="line">        rte_ixgbe_prefetch(sw_ring[rx_id].mbuf); <span class="comment">//预取接收描述符和控制结构体指针 </span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 预取报文 */</span></span><br><span class="line">    <span class="keyword">if</span> ((rx_id &amp; <span class="number">0x3</span>) == <span class="number">0</span>) </span><br><span class="line">    &#123; </span><br><span class="line">        rte_ixgbe_prefetch(&amp;rx_ring[rx_id]); </span><br><span class="line">        rte_ixgbe_prefetch(&amp;sw_ring[rx_id]); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 把接收描述符读取的信息存储在控制结构体mbuf中 */</span></span><br><span class="line">    rte_packet_prefetch((<span class="keyword">char</span> *)rxm-&gt;buf_addr + rxm-&gt;data_off); </span><br><span class="line">	rxm-&gt;nb_segs = <span class="number">1</span>; </span><br><span class="line">	rxm-&gt;next = <span class="literal">NULL</span>; </span><br><span class="line">	rxm-&gt;pkt_len = pkt_len; </span><br><span class="line">	rxm-&gt;data_len = pkt_len;</span><br><span class="line">	rxm-&gt;port = rxq-&gt;port_id; </span><br><span class="line">		……</span><br><span class="line">	rx_pkts[nb_rx++] = rxm; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，DPDK在定义数据结构或者数据缓冲区时就申明cache line对齐，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RTE_CACHE_LINE_SIZE 64 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __rte_cache_aligned __attribute__((__aligned__(RTE_CACHE_LINE_SIZE)))</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_ring_debug_stats</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	<span class="keyword">uint64_t</span> enq_success_bulk; </span><br><span class="line">	<span class="keyword">uint64_t</span> enq_success_objs; </span><br><span class="line">	<span class="keyword">uint64_t</span> enq_quota_bulk; </span><br><span class="line">	<span class="keyword">uint64_t</span> enq_quota_objs; </span><br><span class="line">	<span class="keyword">uint64_t</span> enq_fail_bulk; </span><br><span class="line">	<span class="keyword">uint64_t</span> enq_fail_objs;</span><br><span class="line">	<span class="keyword">uint64_t</span> deq_success_bulk; </span><br><span class="line">	<span class="keyword">uint64_t</span> deq_success_objs; </span><br><span class="line">	<span class="keyword">uint64_t</span> deq_fail_bulk; </span><br><span class="line">	<span class="keyword">uint64_t</span> deq_fail_objs; </span><br><span class="line">&#125; __rte_cache_aligned;</span><br></pre></td></tr></table></figure>
<h3 id="大页内存"><a href="#大页内存" class="headerlink" title="大页内存"></a>大页内存</h3><p>在前文<a href="https://kkutysllb.cn/2019/04/21/2019-04-21-x86%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80/">《x86架构基础》</a>一文中提到了TLB的概念，其主要用来缓存内存地址转换中的页表项，其本质上也是一个cache，称之为TLB cache。<strong>TLB和cache的区别是：TLB缓存内存地址转换用的页表项，而cache缓存程序用到的数据和指令。</strong></p>
<p>TLB中保存着程序线性地址前20位[31：12]和页框号的对应关系，如果匹配到线性地址就可以迅速找到页框号，通过页框号与线性地址后12位的偏移组合得到最终的物理地址。TLB使用虚拟地址进行搜索，直接返回对应的物理地址，相对于内存中的多级页表需要多次访问才能得到最终的物理地址，TLB查找大大减少了CPU的开销。如果需要的地址在TLB Cache中，就会迅速返回结果，然后CPU用该物理地址访问内存，这样的查找操作也称为TLB命中；如果需要的地址不在TLB Cache中，也就是不命中，CPU就需要到内存中访问多级页表，才能最终得到物理地址。但是，TLB的大小是有限的，因此TLB不命中的概率很大，为了提高内存地址转换效率，减少CPU的开销，就提出了<strong>大页内存</strong>的概念。</p>
<p>在x86架构中，一般都分成以下四组TLB：</p>
<ul>
<li>第一组：缓存一般页表（4KB页面）的指令页表缓存（Instruction-TLB）。</li>
<li>第二组：缓存一般页表（4KB页面）的数据页表缓存（Data-TLB）。</li>
<li>第三组：缓存大尺寸页表（2MB/4MB页面）的指令页表缓存（Instruction-TLB）。</li>
<li>第四组：缓存大尺寸页表（2MB/4MB页面）的数据页表缓存（Data-TLB）</li>
</ul>
<p>如果采用常规页（4KB）并且使TLB总能命中，需要寻址的内容都在该内容页内，那么至少需要在TLB表中存放两个表项。如果一个程序使用了512个内容页也就是2MB大小，那么需要512个页表表项才能保证不会出现TLB不命中的情况。但是，如果采用2MB作为分页的基本单位，那么只需要一个表项就可以保证不出现TLB不命中的情况；对于消耗内存以GB为单位的大型程序，可以采用1GB为单位作为分页的基本单位，减少TLB不命中的情况。需要注意的是：<strong>系统能否支持大页，支持大页的大小为多少是由其使用的处理器决定的。</strong></p>
<p>在Linux启动之后，如果想预留大页，则可以使用以下的方法来预留内存。在非NUMA系统中，可以使用以下方法预留2MB大小的大页。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 预留1024个大小为2MB的大页，也就是预留了2GB内存。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 1024 &gt; /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages</span><br></pre></td></tr></table></figure>
<p><strong><em>系统未开启大页内存的状态</em></strong></p>
<p><img src="https://i.loli.net/2019/04/27/5cc3e5b16a991.jpg"></p>
<p><strong><em>系统开启大页内存后的状态</em></strong></p>
<p><img src="https://i.loli.net/2019/04/27/5cc3e5cc93de5.jpg"></p>
<p>如果是在NUMA系统中，假设有两个NODE的系统中，则可以用以下的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在NODE0和NODE1上各预留1024个大小为2MB的大页，总共预留了4GB大小。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 1024 &gt; /sys/devices/system/node/node0/hugepages/hugepages-2048kB/nr_hugepages </span><br><span class="line"><span class="built_in">echo</span> 1024 &gt; /sys/devices/system/node/node1/hugepages/hugepages-2048kB/nr_hugepages</span><br></pre></td></tr></table></figure>
<p><strong>而对于大小为1GB的大页，则必须在Linux的GRUB配置文件中进行修改，并重启系统生效，不能动态预留。</strong></p>
<p>DPDK中也是使用HUGETLBFS来使用大页。首先，它需要把大页mount到某个路径，比如/mnt/huge，以下是命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /mnt/huge </span><br><span class="line">mount -t hugetlbfs nodev /mnt/huge</span><br></pre></td></tr></table></figure>
<p>需要注意的是：在mount之前，要确保之前已经成功预留内存，否则会失败。该命令只是临时的mount了文件系统，如果想每次开机时省略该步骤，可以修改/etc/fstab文件，加上如下一行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodev /mnt/huge hugetlbfs defaults 0 0</span><br></pre></td></tr></table></figure>
<p>对于1GB大小的大页，则必须用如下的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodev /mnt/huge_1GB hugetlbfs pagesize=1GB 0 0</span><br></pre></td></tr></table></figure>
<p>然后，在DPDK运行的时候，会使用<strong>mmap（）系统调用</strong>把大页映射到用户态的虚拟地址空间，然后就可以正常使用了。</p>
<p><strong>DDIO（Data Direct I/O）数据直连技术</strong></p>
<p>如今，随着大数据和云计算的爆炸式增长，宽带的普及以及个人终端网络数据的日益提高，对运营商服务节点和数据中心的数据交换能力和网络带宽提出了更高的要求。并且，数据中心本身对虚拟化功能的需求也增加了更多的网络带宽需求。为此，英特尔公司提出了Intel® DDIO（Data Direct I/O）的技术。该技术的主要目的就是让服务器能更快处理网络接口的数据，提高系统整体的吞吐率，降低延迟，同时减少能源的消耗。</p>
<p>当一个网络报文送到服务器的网卡时，网卡通过外部总线（比如PCI总线）把数据和报文描述符送到内存。接着，CPU从内存读取数据到Cache进而到寄存器。进行处理之后，再写回到Cache，并最终送到内存中。最后，网卡读取内存数据，经过外部总线送到网卡内部，最终通过网络接口发送出去。可以看出，对于一个数据报文，CPU和网卡需要多次访问内存。而内存相对CPU来讲是一个非常慢速的部件。CPU需要等待数百个周期才能拿到数据，在这过程中，CPU什么也做不了。</p>
<p>DDIO技术思想就是使外部网卡和CPU通过LLC Cache直接交换数据，绕过了内存这个相对慢速的部件。这样，就增加了CPU处理网络报文的速度（减少了CPU和网卡等待内存的时间），减小了网络报文在服务器端的处理延迟。这样做也带来了一个问题，就是<strong>网络报文直接存储在LLC Cache中，对这一级cache的容量有很大需求</strong>。因此，在英特尔的E5处理器系列产品中，把LLC Cache的容量提高到了20MB。DDIO处理网络报文流程示意图如下：</p>
<p><img src="https://i.loli.net/2019/04/27/5cc3e64a94e86.jpg"></p>
<p>为了发送一个数据报文到网络上去，首先是运行在CPU上的软件分配了一段内存，然后把这段内存读取到CPU内部，更新数据，并且填充相应的报文描述符（网卡会通过读取描述符了解报文的相应信息），然后写回到内存中，通知网卡，最终网卡把数据读回到内部，并且发送到网络上去。但是，没有DDIO技术和有DDIO技术条件的处理方式是不同的。</p>
<p><strong><em>a) 没有DDIO时，如下图所示：</em></strong></p>
<p><img src="https://i.loli.net/2019/04/27/5cc3e66c1fc6d.jpg"></p>
<p>1）CPU更新报文和控制结构体。由于分配的缓冲区在内存中，因此会触发一次Cache不命中，CPU把内存读取到Cache中，然后更新控制结构体和报文信息。之后通知NIC来读取报文。</p>
<p>2）NIC收到有报文需要传递到网络上的通知后，读取控制结构体进而知道去内存中读取报文信息。</p>
<p>3）由于之前CPU刚把该缓冲区从内存读到Cache中并且做了更新，很有可能Cache还没有来得及把更新的内容写回到内存中(回写机制)。因此，当NIC发起一个对内存的读请求时，很有可能这个请求会发送到Cache系统中，Cache系统会把数据写回到内存中。</p>
<p>4）最后，内存控制器再把数据写到PCI总线上去，NIC从PCI总线上读取数据。</p>
<p><strong>b) 有DDIO时，如下图所示：</strong></p>
<p><img src="https://i.loli.net/2019/04/27/5cc3e6d6612ea.jpg"></p>
<p>1）CPU更新报文和控制结构体。这个步骤和没有DDIO的技术类似，但是由于DDIO的引入，处理器会开始就把内存中的缓冲区和控制结构体预取到Cache，因此减少了内存读的时间。</p>
<p>2）NIC收到有报文需要传递到网络上的通知后，通过PCI总线去读取控制结构体和报文。利用DDIO技术，I/O访问可以直接将Cache的内容送到PCI总线上。这样，就减少了Cache写回时等待的时间。</p>
<p><strong>由此可以看出，由于DDIO技术的引入，网卡的读操作减少了访问内存的次数，因而提高了访问效率，减少了报文转发的延迟。在理想状况下，NIC和CPU无需访问内存，直接通过访问Cache就可以完成更新数据，把数据送到NIC内部，进而送到网络上的所有操作。</strong></p>
<p>有网络报文需要送到系统内部进行处理，其过程一般是NIC从网络上收到报文后，通过PCI总线把报文和相应的控制结构体送到预先分配的内存，然后通知相应的驱动程序或者软件来处理。和之前网卡的读数据操作类似，有DDIO技术和没有DDIO技术的处理也是不一样的。</p>
<p><strong>a) 没有DDIO时，如下图所示：</strong></p>
<p><img src="https://i.loli.net/2019/04/27/5cc3e702f0608.jpg"></p>
<p>1）报文和控制结构体通过PCI总线送到指定的内存中。如果该内存恰好缓存在Cache中（有可能之前CPU有对该内存进行过读写操作），则需要等待Cache把内容先写回到内存中，然后才能把报文和控制结构体写到内存中。</p>
<p>2）运行在CPU上的驱动程序或者软件得到通知收到新报文，去内存中读取控制结构体和相应的报文，Cache不命中。之所以Cache一定不会命中，是因为即使该内存地址在Cache中，在步骤1中也被强制写回到内存中。因此，只能从内存中读取控制结构体和报文。</p>
<p><strong>b) 有DDIO时，如下图所示：</strong></p>
<p><img src="https://i.loli.net/2019/04/27/5cc3e72df17eb.jpg"></p>
<p>1）这时，报文和控制结构体通过PCI总线直接送到Cache中。这时有两种情形：场景一就是如果该内存恰好缓存在Cache中（有可能之前处理器有对该内存进行过读写操作），则直接在Cache中更新内容，覆盖原有内容。场景二就是如果该内存没有缓存在Cache中，则在最后一级Cache中分配一块区域，并相应更新Cache表，表明该内容是对应于内存中的某个地址的。</p>
<p>2）运行在CPU上的驱动或者软件被通知到有报文到达，其产生一个内存读操作，由于该内容已经在Cache中，因此直接从Cache中读。</p>
<p><strong>由此可以看出，DDIO技术在CPU和外设之间交换数据时，减少了CPU和外设访问内存的次数，也减少了Cache写回的等待，提高了系统的吞吐率和数据的交换延迟。</strong></p>
<h3 id="NUMA系统"><a href="#NUMA系统" class="headerlink" title="NUMA系统"></a>NUMA系统</h3><p>从系统架构来看，目前的商用服务器大体可以分为三类，即<strong>对称多处理器结构 (SMP ： Symmetric Multi-Processor)</strong> ，<strong>非一致存储访问结构 (NUMA ： Non-Uniform Memory Access)</strong> ，以及<strong>海量并行处理结构 (MPP ： Massive Parallel Processing)</strong> 。它们的特征如下：</p>
<p><img src="https://i.loli.net/2019/04/27/5cc3e75475642.jpg"></p>
<blockquote>
<p><strong>SMP (Symmetric Multi Processing)</strong>,对称多处理系统内有许多紧耦合多处理器，在这样的系统中，所有的CPU共享全部资源，如总线，内存和I/O系统等，操作系统或管理数据库的复本只有一个，这种系统有一个最大的特点就是共享所有资源。多个CPU之间没有区别，平等地访问内存、外设、一个操作系统。操作系统管理着一个队列，每个处理器依次处理队列中的进程。如果两个处理器同时请求访问一个资源（例如同一段内存地址），由硬件、软件的锁机制去解决资源争用问题。SMP 服务器的主要特征是共享，系统中所有资源 (CPU 、内存、 I/O 等 ) 都是共享的。也正是由于这种特征，导致了 SMP 服务器的主要问题，<strong>那就是它的扩展能力非常有限</strong>。对于 SMP 服务器而言，每一个共享的环节都可能造成 SMP 服务器扩展时的瓶颈，而最受限制的则是内存。由于每个 CPU 必须通过相同的内存总线访问相同的内存资源，因此随着 CPU 数量的增加，内存访问冲突将迅速增加，最终会造成 CPU 资源的浪费，使 CPU 性能的有效性大大降低。实验证明， SMP 服务器 CPU 利用率最好的情况是 2 至 4 个 CPU 。</p>
<p><strong>NUMA 服务器</strong>的基本特征是具有多个 CPU 模块，每个 CPU 模块由多个 CPU( 如 4 个 ) 组成，并且具有独立的本地内存、 I/O 槽口等。由于其节点之间可以通过互联模块 ( 如称为 Crossbar Switch) 进行连接和信息交互，因此每个 CPU 可以访问整个系统的内存 ( 这是 NUMA 系统与 MPP 系统的重要差别 ) 。显然，访问本地内存的速度将远远高于访问远地内存 ( 系统内其它节点的内存 ) 的速度，这也是非一致存储访问 NUMA 的由来。由于这个特点，为了更好地发挥系统性能，开发应用程序时需要尽量减少不同 CPU 模块之间的信息交互。利用 NUMA 技术，可以较好地解决原来 SMP 系统的扩展问题，在一个物理服务器内可以支持上百个 CPU 。NUMA 技术同样有一定缺陷，由于访问远地内存的延时远远超过本地内存，因此当 CPU 数量增加时，系统性能无法线性增加。</p>
<p>和 NUMA 不同， <strong>MPP</strong> 提供了另外一种进行系统扩展的方式，它由多个 SMP 服务器通过一定的节点互联网络进行连接，协同工作，完成相同的任务，从用户的角度来看是一个服务器系统。其基本特征是由多个 SMP 服务器 ( 每个 SMP 服务器称节点 ) 通过节点互联网络连接而成，每个节点只访问自己的本地资源 ( 内存、存储等 ) ，是一种完全无共享 (Share Nothing) 结构，因而扩展能力最好，理论上其扩展无限制，目前的技术可实现 512 个节点互联，数千个 CPU 。<strong>MPP不是处理器内部节点互联，而是多个服务器通过外部互联。</strong>在 MPP 系统中，每个 SMP 节点也可以运行自己的操作系统、数据库等。但和 NUMA 不同的是，它不存在异地内存访问的问题。换言之，每个节点内的 CPU 不能访问另一个节点的内存。节点之间的信息交互是通过节点互联网络实现的，这个过程一般称为数据重分配 (Data Redistribution) 。MPP 服务器需要一种复杂的机制来调度和平衡各个节点的负载和并行处理过程。</p>
</blockquote>
<p>NUMA系统是一种多处理器环境下设计的内存结构。在NUMA架构出现前，CPU欢快的朝着频率越来越高的方向发展。受到物理极限的挑战，又转为核数越来越多的方向发展。如果每个core的工作性质都是share-nothing（类似于map-reduce的node节点的作业属性），那么也许就不会有NUMA。由于所有CPU Core都是通过共享一个北桥来读取内存，无论核数如何的发展，北桥在响应时间上的性能瓶颈越来越明显。于是，聪明的硬件设计师们，想到了把内存控制器（原本北桥中读取内存的部分）也做个拆分，平分到了每个die上。于是NUMA就出现了！</p>
<p><img src="https://i.loli.net/2019/04/27/5cc3e78523f21.jpg"></p>
<p>NUMA中，虽然内存直接attach在CPU上，但是由于内存被平均分配在了各个die上。只有当CPU访问自身直接attach内存对应的物理地址时，才会有较短的响应时间（后称Local Access）。而如果需要访问其他CPU attach的内存的数据时，就需要通过inter-connect通道访问，响应时间就相比之前变慢了（后称Remote Access）。所以NUMA（Non-Uniform Memory Access）就此得名。</p>
<p><strong>NUMA的几个概念（Node，socket，core，thread）</strong></p>
<p><img src="https://i.loli.net/2019/04/27/5cc3e7a0dc86a.jpg"></p>
<ul>
<li><p><strong>socket：</strong>就是主板上的CPU插槽; </p>
</li>
<li><p><strong>Core：</strong>就是socket里独立的一组程序执行的硬件单元，比如寄存器，计算单元等; </p>
</li>
<li><p><strong>Thread：</strong>就是超线程hyperthread的概念，逻辑的执行单元，独立的执行上下文，但是共享core内的寄存器和计算单元。</p>
</li>
<li><p><strong>Node：</strong>这个概念其实是用来解决core的分组的问题，具体参见下图来理解（图中的OS CPU可以理解thread，那么core就没有在图中画出），从图中可以看出共有4个socket，每个socket 2个node，每个node中有8个thread，总共4（Socket）× 2（Node）× 8 （4core × 2 Thread） = 64个thread。另外每个node有自己的内部CPU，总线和内存，同时还可以访问其他node内的内存，NUMA的最大的优势就是可以方便的增加CPU的数量，因为Node内有自己内部总线，所以增加CPU数量可以通过增加Node的数目来实现，如果单纯的增加CPU的数量，会对总线造成很大的压力，所以UMA结构不可能支持很多的核。下图出自：《<strong>NUMA Best Practices for Dell PowerEdge 12th Generation Servers</strong>》</p>
<p><img src="https://i.loli.net/2019/04/27/5cc3e7c6deca7.jpg"></p>
</li>
</ul>
<p>由于每个node内部有自己的CPU总线和内存，所以如果一个虚拟机的vCPU跨不同的Node的话，就会导致一个node中的CPU去访问另外一个node中的内存的情况，这就导致内存访问延迟的增加。在NFV环境中，对性能有比较高的要求，就非常需要同一个虚拟机的vCPU尽量被分配到同一个Node中的pCPU上，所以在OpenStack的Kilo版本及后续版本均增加了基于NUMA感知的虚拟机调度的特性。<strong>详见<a href="http://www.openstack.org官方社区管理员手册文档。" target="_blank" rel="noopener">www.openstack.org官方社区管理员手册文档。</a></strong></p>
<p><strong>查看服务器中NUMA拓扑架构常用以下命令：</strong></p>
<p><strong>1）比较常用的是lscpu</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ~]<span class="comment"># lscpu</span></span><br><span class="line">Architecture:          x86_64</span><br><span class="line">CPU op-mode(s):        32-bit, 64-bit</span><br><span class="line">Byte Order:            Little Endian</span><br><span class="line">CPU(s):                4</span><br><span class="line">On-line CPU(s) list:   0-3</span><br><span class="line">Thread(s) per core:    1</span><br><span class="line">Core(s) per socket:    2</span><br><span class="line">Socket(s):             2</span><br><span class="line">NUMA node(s):          2</span><br><span class="line">Vendor ID:             GenuineIntel</span><br><span class="line">CPU family:            6</span><br><span class="line">Model:                 158</span><br><span class="line">Model name:            Intel(R) Core(TM) i9-8950HK CPU @ 2.90GHz</span><br><span class="line">Stepping:              10</span><br><span class="line">CPU MHz:               2903.998</span><br><span class="line">BogoMIPS:              5807.99</span><br><span class="line">Virtualization:        VT-x</span><br><span class="line">Hypervisor vendor:     VMware</span><br><span class="line">Virtualization <span class="built_in">type</span>:   full</span><br><span class="line">L1d cache:             32K</span><br><span class="line">L1i cache:             32K</span><br><span class="line">L2 cache:              256K</span><br><span class="line">L3 cache:              12288K</span><br><span class="line">NUMA node0 CPU(s):     0-3</span><br><span class="line">Flags:                 fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon nopl xtopology tsc_reliable nonstop_tsc eagerfpu pni pclmulqdq vmx ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch ssbd ibrs ibpb stibp tpr_shadow vnmi ept vpid fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 invpcid rtm mpx rdseed adx smap clflushopt xsaveopt xsavec arat spec_ctrl intel_stibp flush_l1d arch_capabilities</span><br></pre></td></tr></table></figure>
<p>从上面报文输出可以看出，当前机器有2个sockets，每个sockets包含1个numa node，每个numa node中有2个cores，每个cores包含1个thread，所以总的threads数量=2（sockets）×1（node）×2（cores）×1（threads）=4.</p>
<p><strong>2）通过shell脚本打印出当前机器的socket，core和thread的数量</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 简单打印系统CPU拓扑</span></span><br><span class="line"><span class="comment"># Author: kkutysllb</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> get_nr_processor()</span><br><span class="line">&#123;</span><br><span class="line">	grep <span class="string">'^processor'</span> /proc/cpuinfo | wc -l</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> get_nr_socket()</span><br><span class="line">&#123;</span><br><span class="line">	grep <span class="string">'physical id'</span> /proc/cpuinfo | awk -F: <span class="string">'&#123;</span></span><br><span class="line"><span class="string">	print $2 | "sort -un"&#125;'</span> | wc -l</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> get_nr_siblings()</span><br><span class="line">&#123;</span><br><span class="line">	grep <span class="string">'siblings'</span> /proc/cpuinfo | awk -F: <span class="string">'&#123;</span></span><br><span class="line"><span class="string">	print $2 | "sort -un"&#125;'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> get_nr_cores_of_socket()</span><br><span class="line">&#123;</span><br><span class="line">	grep <span class="string">'cpu cores'</span> /proc/cpuinfo | awk -F: <span class="string">'&#123;</span></span><br><span class="line"><span class="string">	print $2 | "sort -un"&#125;'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'===== CPU Topology Table ====='</span></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'+--------------+---------+-----------+'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'| Processor ID | Core ID | Socket ID |'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'+--------------+---------+-----------+'</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line; <span class="keyword">do</span></span><br><span class="line">	<span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$line</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">printf</span> <span class="string">'| %-12s | %-7s | %-9s |\n'</span> <span class="variable">$p_id</span> <span class="variable">$c_id</span> <span class="variable">$s_id</span></span><br><span class="line">		<span class="built_in">echo</span> <span class="string">'+--------------+---------+-----------+'</span></span><br><span class="line">		<span class="built_in">continue</span></span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">echo</span> <span class="string">"<span class="variable">$line</span>"</span> | grep -q <span class="string">"^processor"</span>; <span class="keyword">then</span></span><br><span class="line">		p_id=`<span class="built_in">echo</span> <span class="string">"<span class="variable">$line</span>"</span> | awk -F: <span class="string">'&#123;print $2&#125;'</span> | tr -d <span class="string">' '</span>` </span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">echo</span> <span class="string">"<span class="variable">$line</span>"</span> | grep -q <span class="string">"^core id"</span>; <span class="keyword">then</span></span><br><span class="line">		c_id=`<span class="built_in">echo</span> <span class="string">"<span class="variable">$line</span>"</span> | awk -F: <span class="string">'&#123;print $2&#125;'</span> | tr -d <span class="string">' '</span>` </span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">echo</span> <span class="string">"<span class="variable">$line</span>"</span> | grep -q <span class="string">"^physical id"</span>; <span class="keyword">then</span></span><br><span class="line">		s_id=`<span class="built_in">echo</span> <span class="string">"<span class="variable">$line</span>"</span> | awk -F: <span class="string">'&#123;print $2&#125;'</span> | tr -d <span class="string">' '</span>` </span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span> &lt; /proc/cpuinfo</span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line">awk -F: <span class="string">'&#123; </span></span><br><span class="line"><span class="string">	if ($1 ~ /processor/) &#123;</span></span><br><span class="line"><span class="string">		gsub(/ /,"",$2);</span></span><br><span class="line"><span class="string">		p_id=$2;</span></span><br><span class="line"><span class="string">	&#125; </span></span><br><span class="line"><span class="string">	else if ($1 ~ /physical id/)&#123;</span></span><br><span class="line"><span class="string">		gsub(/ /,"",$2);</span></span><br><span class="line"><span class="string">		s_id=$2;</span></span><br><span class="line"><span class="string">		arr[s_id]=arr[s_id] " " p_id</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">END&#123;</span></span><br><span class="line"><span class="string">	for (i in arr) </span></span><br><span class="line"><span class="string">	printf "Socket %s:%s\n", i, arr[i];</span></span><br><span class="line"><span class="string">&#125;'</span> /proc/cpuinfo</span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'===== CPU Info Summary ====='</span></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line">nr_processor=`get_nr_processor`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Logical processors: <span class="variable">$nr_processor</span>"</span></span><br><span class="line">nr_socket=`get_nr_socket`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Physical socket: <span class="variable">$nr_socket</span>"</span></span><br><span class="line">nr_siblings=`get_nr_siblings`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Siblings in one socket: <span class="variable">$nr_siblings</span>"</span></span><br><span class="line">nr_cores=`get_nr_cores_of_socket`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Cores in one socket: <span class="variable">$nr_cores</span>"</span></span><br><span class="line"><span class="built_in">let</span> nr_cores*=nr_socket</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Cores in total: <span class="variable">$nr_cores</span>"</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$nr_cores</span>"</span> = <span class="string">"<span class="variable">$nr_processor</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">"Hyper-Threading: off"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">"Hyper-Threading: on"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'===== END ====='</span></span><br></pre></td></tr></table></figure>
<p>运行后输出结果如下：</p>
<p><img src="https://i.loli.net/2019/04/27/5cc3e8c3924d0.jpg"></p>
<p><strong>DPDK中有以下策略来适应NUMA系统：</strong></p>
<p><strong>1）Per-core memory：</strong>一个CPU上有多个核（core），per-core memory是指每个核都有属于自己的内存，即对于经常访问的数据结构，每个核都有自己的备份。这样做一方面是为了本地内存的需要，另外一方面也是前面提到的Cache一致性的需要，避免多个核访问同一个Cache Line。</p>
<p><strong>2）本地设备本地处理</strong>：即用本地的处理器、本地的内存来处理本地的设备上产生的数据。如果有一个PCI设备在node0上，就用node0上的核来处理该设备，处理该设备用到的数据结构和数据缓冲区都从node0上分配。以下是一个分配本地内存的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* allocate memory for the queue structure */</span> </span><br><span class="line"><span class="comment">/* 该例分配一个结构体，通过传递socket_id，即node id获得本地内存，并且以Cache Line对齐 */</span></span><br><span class="line">q = rte_zmalloc_socket(<span class="string">"fm10k"</span>, <span class="keyword">sizeof</span>(*q), RTE_CACHE_LINE_SIZE, socket_id);</span><br></pre></td></tr></table></figure>
<h3 id="CPU的亲和性调度"><a href="#CPU的亲和性调度" class="headerlink" title="CPU的亲和性调度"></a>CPU的亲和性调度</h3><p>当前，属于多核处理器时代，这类多核处理器自然会面对一个问题，按照什么策略将任务线程分配到各个处理器上执行。众所周知，这个分配工作一般由操作系统完成。负载均衡当然是比较理想的策略，按需指定的方式也是很自然的诉求，因为其具有确定性。简单地说，<strong>CPU亲和性（Core affinity）就是一个特定的任务要在某个给定的CPU上尽量长时间地运行而不被迁移到其他处理器上的倾向性。</strong>这意味着线程可以不在处理器之间频繁迁移，从而减少不必要的开销。</p>
<p>Linux内核包含了一种机制，它让开发人员可以编程实现CPU亲和性。也就是说可以将应用程序显式地指定线程在哪个（或哪些）CPU上运行。</p>
<p>在Linux内核中，所有的线程都有一个相关的数据结构，称为<strong>task_struct</strong>。这个结构非常重要，这里不展开讨论，只讨论其中与亲和性相关度最高的是<strong>cpus_allowed位掩码</strong>。这个位掩码由n位组成，与系统中的n个逻辑处理器一一对应。具有4个物理CPU的系统可以有4位。如果这些CPU都启用了超线程，那么这个系统就有一个8位的位掩码。</p>
<p><strong>如果针对某个线程设置了指定的位，那么这个线程就可以在相关的CPU上运行。因此，如果一个线程可以在任何CPU上运行，并且能够根据需要在处理器之间进行迁移，那么位掩码就全是1。**</strong>实际上，在Linux中，这就是线程的默认状态。**</p>
<p>Linux内核API提供了一些方法，让用户可以修改位掩码或查看当前的位掩码：</p>
<ul>
<li><strong>sched_set_affinity（）（用来修改位掩码）</strong></li>
<li><strong>sched_get_affinity（）（用来查看当前的位掩码）</strong></li>
</ul>
<p><strong>注意，cpu_affinity会被传递给子线程，因此应该适当地调用sched_set_affinity。</strong></p>
<p><strong>将线程与CPU绑定，最直观的好处就是提高了CPU Cache的命中率</strong>，从而减少内存访问损耗，提高程序的速度。在多核体系CPU上，提高外设以及程序工作效率最直观的办法就是让各个物理核各自负责专门的事情。尤其在在NUMA架构下，这个操作对系统运行速度的提升有更大的意义，跨NUMA节点的任务切换，将导致大量三级Cache的丢失。从这个角度来看，NUMA使用CPU绑定时，每个核心可以更专注地处理一件事情，资源体系被充分使用，减少了同步的损耗。</p>
<p>通常Linux内核都可以很好地对线程进行调度，在应该运行的地方运行线程，也就是说在可用的处理器上运行并获得很好的整体性能。内核包含了一些用来检测CPU之间任务负载迁移的算法，可以启用线程迁移来降低繁忙的处理器的压力。只有在以下三个特殊场景会用到CPU亲和性绑定机制：</p>
<ul>
<li><strong>大量计算：</strong>在科学计算和理论计算中，如果不进行CPU亲和性绑定，会发现自己的应用程序要在多处理器的机器上花费大量时间进行迁移从而完成计算。</li>
<li><strong>复杂程序测试：</strong>比如在线性可伸缩测试中，我们期望的理论模型是如果应用程序随着CPU的增加可以线性地伸缩，那么每秒事务数和CPU个数之间应该会是线性的关系。这样建模可以测试应用程序是否可以有效地使用底层硬件。如果一个给定的线程迁移到其他地方去了，那么它就失去了利用CPU缓存的优势。实际上，如果正在使用的CPU需要为自己缓存一些特殊的数据，那么其他所有CPU都会使这些数据在自己的缓存中失效。因此，如果有多个线程都需要相同的数据，那么将这些线程绑定到一个特定的CPU上，就可以确保它们访问相同的缓存数据或者至少可以提高缓存的命中率。</li>
<li><strong>实时性线程：</strong>对于实时性线程经常会希望使用亲和性来指定一个8路主机上的某个CPU来处理，而同时允许其他7个CPU处理所有普通的系统调度。这种做法对长时间运行、对时间敏感的应用程序可以确保正常运行，同时可以允许其他应用程序独占其余的计算资源。</li>
</ul>
<p>Linux内核提供了启动参数isolcpus。对于有4个CPU的服务器，在启动的时候加入启动参数isolcpus=2，3。那么系统启动后将不使用CPU3和CPU4。<strong>注意，这里说的不使用不是绝对地不使用，系统启动后仍然可以通过taskset命令指定哪些程序在这些核心中运行。</strong></p>
<p><strong>1）修改/etc/default/grub文件中内容，在CMDLINE中添加如下图所示设置</strong></p>
<p><img src="https://i.loli.net/2019/04/27/5cc3e91e07d20.jpg"></p>
<p><strong>2）编译内核启动文件</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 myshell]<span class="comment"># grub2-mkconfig -o /boot/grub2/grub.cfg</span></span><br><span class="line">Generating grub configuration file ...</span><br><span class="line">Found linux image: /boot/vmlinuz-3.10.0-957.10.1.el7.x86_64</span><br><span class="line">Found initrd image: /boot/initramfs-3.10.0-957.10.1.el7.x86_64.img</span><br><span class="line">Found linux image: /boot/vmlinuz-3.10.0-862.el7.x86_64</span><br><span class="line">Found initrd image: /boot/initramfs-3.10.0-862.el7.x86_64.img</span><br><span class="line">Found linux image: /boot/vmlinuz-0-rescue-e344b139f44946638783478bcb51f820</span><br><span class="line">Found initrd image: /boot/initramfs-0-rescue-e344b139f44946638783478bcb51f820.img</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p><strong>3）重启系统后查看/proc/cmdline配置文件是否设置生效</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ~]<span class="comment"># cat /proc/cmdline </span></span><br><span class="line">BOOT_IMAGE=/vmlinuz-3.10.0-957.10.1.el7.x86_64 root=UUID=0887567f-1df6-425f-ba3d-ce58584279e0 ro crashkernel=auto biosdevname=0 net.ifnames=0 rhgb quiet isolcpu=2,3</span><br></pre></td></tr></table></figure>
<p>DPDK的线程基于pthread接口创建，属于抢占式线程模型，受内核调度支配。DPDK通过在多核设备上创建多个线程，每个线程绑定到单独的核上，减少线程调度的开销，以提高性能。DPDK的线程可以作为<strong>控制线程</strong>，也可以作为<strong>数据线程</strong>。控制线程一般绑定到MASTER核上，接受用户配置，并传递配置参数给数据线程等；数据线程分布在不同核上处理数据包。</p>
<p>DPDK的<strong>lcore</strong>指的是EAL线程，本质是基于pthread（Linux/FreeBSD）封装实现。Lcore（EAL pthread）由<strong>remote_launch函数</strong>指定的任务创建并管理。在每个EAL pthread中，有一个<strong>TLS（Thread Local Storage）称为_lcore_id</strong>。当使用DPDK的<strong>EAL‘-c’参数</strong>指定<strong>coremask</strong>时，EAL pthread生成相应个数<strong>lcore</strong>，并默认是1：1亲和到coremask对应的CPU逻辑核，<strong>_lcore_id和CPU ID是一致的。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* rte_eal_cpu_init（）函数中，通过读取/sys/devices/system/cpu/cpuX/下的相关信息，确定当前系统有哪些CPU核，以及每个核属于哪个CPU Socket。eal_parse_args（）函数，解析-c参数，确认哪些CPU核是可以使用的，以及设置第一个核为MASTER。为每一个SLAVE核创建线程，并调用eal_thread_set_affinity（）绑定CPU。线程的执行体是eal_thread_loop（）,函数内部的主体是一个while死循环，调用不同模块注册到lcore_config[lcore_id].f的回调函数 */</span></span><br><span class="line"></span><br><span class="line">RTE_LCORE_FOREACH_SLAVE(i) </span><br><span class="line">&#123; </span><br><span class="line">	<span class="comment">/* * create communication pipes between master thread * and children */</span> </span><br><span class="line">	<span class="keyword">if</span> (pipe(lcore_config[i].pipe_master2slave) &lt; <span class="number">0</span>) </span><br><span class="line">		rte_panic(<span class="string">"Cannot create pipe\n"</span>); </span><br><span class="line">	<span class="keyword">if</span> (pipe(lcore_config[i].pipe_slave2master) &lt; <span class="number">0</span>) </span><br><span class="line">		rte_panic(<span class="string">"Cannot create pipe\n"</span>); </span><br><span class="line">	lcore_config[i].state = WAIT; </span><br><span class="line">	<span class="comment">/* create a thread for each lcore */</span> </span><br><span class="line">	ret = pthread_create(&amp;lcore_config[i].thread_id, <span class="literal">NULL</span>, eal_thread_loop, <span class="literal">NULL</span>); </span><br><span class="line">	<span class="keyword">if</span> (ret！= <span class="number">0</span>) </span><br><span class="line">	rte_panic(<span class="string">"Cannot create thread\n"</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 不同的模块需要调用rte_eal_mp_remote_launch（），将自己的回调处理函数注册到lcore_config[].f中。以l2fwd为例，注册的回调处理函数是l2fwd_launch_on_lcore（）*/</span></span><br><span class="line">rte_eal_mp_remote_launch(l2fwd_launch_one_lcore, <span class="literal">NULL</span>, CALL_MASTER);</span><br></pre></td></tr></table></figure>
<p>DPDK每个核上的线程最终会调用eal_thread_loop（）&gt;&gt;&gt; l2fwd_launch_on_lcore（），调用到自己实现的处理函数。默认情况下，lcore是与逻辑核一一亲和绑定的。带来性能提升的同时，也牺牲了一定的灵活性和能效。在现网中，往往有流量潮汐现象的发生，在网络流量空闲时，没有必要使用与流量繁忙时相同的核数。于是，EAL pthread和逻辑核之间进而允许打破1：1的绑定关系，使得_lcore_id本身和CPU ID可以不严格一致。EAL定义了长选项“——lcores”来指定lcore的CPU亲和性。对一个特定的lcore ID或者lcore ID组，这个长选项允许为EAL pthread设置CPU集。这个选项以及对应的一组API（rte_thread_set/get_affinity（））为lcore提供了亲和的灵活性。lcore可以亲和到一个CPU或者一个CPU集合，使得在运行时调整具体某个CPU承载lcore成为可能。同时，多个lcore也可能亲和到同一个核，但是这种情况下如果调度占用的内核库是非抢占式，就存在锁机制，DPDK技术栈在电信云中的最佳实践（2）中会专门针对不同锁进制进行讨论。</p>
<p>除了使用DPDK提供的逻辑核之外，用户也可以将DPDK的执行上下文运行在任何用户自己创建的pthread中。在普通用户自定义的pthread中，lcore id的值总是<strong>LCORE_ID_ANY</strong>，以此确定这个thread是一个有效的普通用户所创建的pthread。用户创建的pthread可以支持绝大多数DPDK库，没有任何影响。但少数DPDK库可能无法完全支持用户自创建的pthread，如timer和Mempool。详细请参见《DPDK开发者手册多线程章节》。</p>
<p>DPDK不仅可以通过绑核完成大量计算任务资源亲和性调度，同时在计算任务较小，一个核的资源绰绰有余的情况下，还可以通过Linux的cgroup对资源进行释放。因为，DPDK的线程其实就是普通的pthread，其本质就是使用cgroup能把CPU的配额灵活地配置在不同的线程上。因此，DPDK可以借助cgroup实现计算资源配额对于线程的灵活配置，可以有效改善I/O核的闲置利用率。</p>
<p>最后，用一张图来总结lcore的启动过程和执行任务分发的流程。</p>
<p><img src="https://i.loli.net/2019/04/27/5cc3eb2155fbf.jpg"></p>

      
    </div>

    

    
    
    

    

    
      
    
	
	<div>
	
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
	
	</div>
	
    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById(&quot;QR&quot;); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.png" alt="kkutysllb 微信支付">
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.png" alt="kkutysllb 支付宝">
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        



  



<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>kkutysllb</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    
    <a href="https://kkutysllb.cn/2019/04/27/2019-04-27-DPDK技术栈在电信云中的最佳实践（一）/" title="2019-04-27-DPDK技术栈在电信云中的最佳实践（一）">https://kkutysllb.cn/2019/04/27/2019-04-27-DPDK技术栈在电信云中的最佳实践（一）/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/电信云/" rel="tag"><i class="fa fa-tag"></i> 电信云</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/23/2019-04-22-Linux系统命令-第四篇《系统信息显示命令》/" rel="next" title="2019-04-22-Linux系统命令-第四篇《系统信息显示命令》">
                <i class="fa fa-chevron-left"></i> 2019-04-22-Linux系统命令-第四篇《系统信息显示命令》
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/04/28/2019-04-27-Linux系统命令-第五篇《文件备份与压缩命令》/" rel="prev" title="2019-04-27-Linux系统命令-第五篇《文件备份与压缩命令》">
                2019-04-27-Linux系统命令-第五篇《文件备份与压缩命令》 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC80MjY0Ni8xOTE5Mw=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="kkutysllb">
            
              <p class="site-author-name" itemprop="name">kkutysllb</p>
              <p class="site-description motion-element" itemprop="description">容易走的路是下坡路<br>总是不经意间装个X得罪一票人</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">21</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/kkutysllb" title="GitHub &rarr; https://github.com/kkutysllb" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:linbrid772233@gmail.com" title="E-Mail &rarr; mailto:linbrid772233@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-e-mail"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://weibo.com/u/2243838583?is_all=1" title="Weibo &rarr; https://weibo.com/u/2243838583?is_all=1" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://www.zhihu.com/people/tang-xi-yao-43/activities" title="Zhihu &rarr; https://www.zhihu.com/people/tang-xi-yao-43/activities" rel="noopener" target="_blank"><i class="fa fa-fw fa-zhihu"></i>Zhihu</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么需要DPDK？"><span class="nav-number">1.</span> <span class="nav-text">为什么需要DPDK？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#鸟瞰DPDK"><span class="nav-number">2.</span> <span class="nav-text">鸟瞰DPDK</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#电信云中数据包转发性能提升中的DPDK"><span class="nav-number">3.</span> <span class="nav-text">电信云中数据包转发性能提升中的DPDK</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#cache的作用"><span class="nav-number">3.1.</span> <span class="nav-text">cache的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#大页内存"><span class="nav-number">3.2.</span> <span class="nav-text">大页内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NUMA系统"><span class="nav-number">3.3.</span> <span class="nav-text">NUMA系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU的亲和性调度"><span class="nav-number">3.4.</span> <span class="nav-text">CPU的亲和性调度</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">kkutysllb</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">185k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">2:48</span>
  
</div>









        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
    
  
  <script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>













  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.0"></script>

  <script src="/js/src/motion.js?v=7.0.0"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.0"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.0"></script>




  
  <script src="/js/src/scrollspy.js?v=7.0.0"></script>
<script src="/js/src/post-details.js?v=7.0.0"></script>



  


  <script src="/js/src/bootstrap.js?v=7.0.0"></script>



  


  
    <script>
  window.livereOptions = {
    refer: '2019/04/27/2019-04-27-DPDK技术栈在电信云中的最佳实践（一）/'
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
</script>

  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function(i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap');
      $(e).after($wrap);
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
        var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
          return $(e).text();
        }).toArray().join('\n');
        var ta = document.createElement('textarea');
        var range = document.createRange(); //For Chrome
        var sel = window.getSelection(); //For Chrome
        var yPosition = window.pageYOffset || document.documentElement.scrollTop;
        ta.style.top = yPosition + 'px'; //Prevent page scroll
        ta.style.position = 'absolute';
        ta.style.opacity = '0';
        ta.value = code;
        ta.textContent = code; //For FireFox
        ta.contentEditable = true;
        ta.readOnly = false;
        document.body.appendChild(ta);
        range.selectNode(ta);
        sel.removeAllRanges();
        sel.addRange(range);
        ta.setSelectionRange(0, code.length);
        var result = document.execCommand('copy');
        
          if (result) $(this).text('复制成功');
          else $(this).text('复制失败');
        
        ta.blur(); //For iOS
        $(this).blur();
      })).on('mouseleave', function(e) {
        var $b = $(this).find('.copy-btn');
        setTimeout(function() {
          $b.text('复制');
        }, 300);
      }).append(e);
    })
  </script>


</body>
</html>
