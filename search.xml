<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2019-04-10-Linux系统核心命令---第一篇《关机、重启命令》]]></title>
    <url>%2F2019%2F04%2F15%2F2019-04-10-Linux%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E5%91%BD%E4%BB%A4-%E7%AC%AC%E4%B8%80%E7%AF%87%E3%80%8A%E5%85%B3%E6%9C%BA%E3%80%81%E9%87%8D%E5%90%AF%E5%91%BD%E4%BB%A4%E3%80%8B%2F</url>
    <content type="text"><![CDATA[Linux命令行的概述众所周知，Linux是一个主要通过命令行来进行管理的操作系统，即通过键盘输入指令来管理系统的相关操作，包括但不限于编辑文件、启动停止服务等。这和初学者曾经使用的Windows系统使用鼠标点击的可视化管理大不相同。 使用鼠标可视化管理的优势是简单、容易上手，但缺点是不便于快速、批量、自动化管理系统，而且感觉系统很臃肿，这个时候Linux系统的命令行管理优势就凸显了。使用Linux命令行管理，不但可以批量、自动化管理，而且还可以实现智能化、可视化管理；当然，后者需要开发人员配合开发管理界面来完成。但是无论如何，Linux系统的优势基因还是快速、批量、自动化、智能化管理系统及处理业务。 Linux命令行介绍安装Linux系统时，无论是使用文本模式（命令行）安装，还是使用图形模式安装，最终管理系统的任务都会落到命令行之上。 大多数互联网企业在安装系统时甚至不会安装图形管理软件包，而是直接使用文本模式安装，因此登录后直接面对的就是命令行的界面，如下图所示： Linux命令行提示符介绍 Linux命令行结尾的提示符有“#”和“$”两种不同的符号，代码如下所示： 123[root@C7-Server01 ～]# # 这是超级管理员root用户对应的命令行。![](https://i.loli.net/2019/04/16/5cb4bcc717709.jpg) 1[kkutysllb@C7-Server01 ～]$ # 这是普通用户kkutysllb对应的命令行。 Linux命令提示符由PS1环境变量控制。示例代码如下： 1[root@C7-Server01 ~]# set | grep PS1 这里的PS1=[\u@\h\W]\$，可以通过全局配置文件/etc/bashrc或/etc/profile进行按需配置和调整。 Linux命令行常用快捷键这里需要特别说明一下的是，在企业工作中，管理Linux时一般不会直接采用键盘、显示器登录系统，而是会通过网络在远程进行管理，因此，需要通过远程连接工具连接到Linux系统中。目前最常用的Linux远程连接工具为：SecureCRT和Xshell客户端软件，因此，本节涉及的常用命令快捷键也是基于这两款客户端软件的，其他软件的快捷键使用情况与此基本类似。提高Linux运维效率的30个命令行常用快捷键如下： Linux重启、关机、注销命令1、shutdown 命令常用操作shutdown是一个用来安全关闭或重启Linux系统的命令，系统在关闭之前会通知所有的登录用户，系统即将关闭，此时所有的新用户都不可以登录，与shutdown类似功能的命令还有init、halt、poweroff、reboot。 语法格式为：shutdown [OPTION]…… TIME [MESSAGE] 通常情况下，我们执行的shutdown命令为shutdown-h now或shutdown-r now shutdown命令常用的参数选项如下： 【使用举例】 1）10分钟后关闭或重启系统 12#关机[root@C7-Server01 ~]# shutdown -h +10 12#重启[root@C7-Server01 ~]# shutdown -r +10 2）11点整定时关闭或重启系统 12#11点整重启 [root@C7-Server01 ~]# shutdown -r 11:00 12#11点整关闭[root@C7-Server01 ~]# shutdown -h 11:00 3）立即关闭或重启Linux系统的命令如下： 12#立即关机 [root@C7-Server01 ~]# shutdown -h now 12#立即重启[root@C7-Server01 ~]# shutdown -r now 2、halt/poweroff/reboot命令的常用操作从RedHat或CentOS 6开始，你会发现halt、poweroff、reboot这三个命令对应的都是同一个man帮助文档。在CentOS 6时代，而halt、poweroff是reboot命令的链接文件，而在CentOS 7时代，这三个命令都是systemctl的连接文件。 语法格式为：halt/poweroff/reboot [OPTIONS] 通常情况下，我们执行这三个命令时都不带任何参数。因此，这三个命令的选项参数也就没什么好研究的。 【使用举例】 1）使用halt命令完成关机 1[root@C7-Server01 ~]# halt 2）使用poweroff命令完成关机 1[root@C7-Server01 ~]# poweroff 3）使用reboot命令重启系统 1[root@C7-Server01 ~]# reboot 3、常见不常见关机、重启和注销的命令列表 Linux命令正是组成Linux系统最核心、重要的基础之一，因此，大家只要牢牢掌握基础命令，在日后linux运维、shell编程、云计算/大数据、甚至Python自动化运维都能如鱼得水。]]></content>
      <categories>
        <category>核心命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-04-05-CentOS操作系统6.x版本与7.x版本的区别]]></title>
    <url>%2F2019%2F04%2F15%2F2019-04-05-CentOS%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F6-x%E7%89%88%E6%9C%AC%E4%B8%8E7-x%E7%89%88%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Centos7与6之间最大的差别就是初始化技术的不同，7采用的初始化技术是Systemd,并行的运行方式，除了这一点之外，服务启动、开机启动文件、网络命令方面等等也存在不同。 1.系统初始化技术在Linux系统常用系统初始化技术主要有三种：Sysvinit技术、Upstart技术和Systemd技术。在CentOS 6时代，主要使用sysvinit技术完成系统的初始化，其实现原理通过调用各种服务的shell脚本完成初始化工作。而在CentOS 7时代，开始采用Systemd技术来完成系统的初始化工作，其最大的特点的各类服务可以并发完成。同时，在CentOS 7时代也保留Sysvinit技术。三种不同的初始化技术的优缺点如下： Sysvinit技术特点： 1.系统第1个进程为init; 2.init进程是所有进程的父进程，不可kill； 3.大多数Linux发行版的init系统是和SystemV相兼容的，被称为sysvinti 4.代表系统：CentOS5 CentOS6 优点： sysvinit运行非常良好，概念简单清晰，它主要依赖于shell脚。所以，如果大家开始学习shell编程时，建议安装一个CentOS6系统。 缺点： 1.按照一定顺序执行——&gt;启动太慢。 2.很容易hang住，fstab与nfs挂载问题 Upstart技术CentOS6采用了upstart技术代替sysVinit进行引导，Upstart对rc.sysinit脚本做了大量的优化，缩短了系统初始化的启动时间。但是CentOS6为了简便管理员的操作，upstart的很多特性并没有凸显或直接不支持。代表系统：CentOS6, Ubuntu14, 从CentOS7, Ubuntu15开始使用systemd。 Systemd技术新系统都会采用的技术（RedHat7,CentOS7,Ubuntu15等），设计目标是克服sysvinit固有的缺点，提高系统的启动速度。和Sysvinit兼容，降低迁移成本，最主要优点：并行启动，Pid为1的进程。 2.在yum源上的优化在centos6的时候，默认是从官方源下载rpm包的，由于是国外的yum源很慢不能用，CentOS7在这里做了优化，当我们使用yum安装软件的时候，默认不会再从官方下载，而是自动寻找离自己地理位置最近的yum源开始下载。 3.网络命令如果在安装系统的时候选择minimal，会比之前6的时候以更小的包来安装，比如：vim、ifconfig、route、setup、netstat等等都不会安装。因此，使用CentOS7通过最小化安装后，还需挂在ISO完成上述常用工具的安装。如果采用脚本自动化安装，可以将上述的工具的安装命令写入到安装到脚本中。 4.字符集修改 1234567891011/etc/locale.conf #字符集配置文件 localectl set-locale LANG=zh_CN.UTF-8 # 命令行一步到位 [root@CentOS7 ~]# localectl set-locale LANG=zh_CN.UTF-8 [root@CentOS7 ~]# localectl status System Locale: LANG=zh_CN.UTF-8 VC Keymap: us X11 Layout: us 5.开机启动管理/etc/rc.local 这个文件还是存在，不过如果我们还想继续使用这种方式需要给它加执行权限chmod +x /etc/rc.d/rc.local system一统天下 snapshot(支持快照) 12345678systemctl status cron.service #查看定时任务状态systemctl stop cron.service#关闭定时任务systemctl status cron.service#查看操作情况systemctl list-unit-files|grep enable #查看当前正在运行的服务systemctl disable postfix.service #关闭邮件服务systemctl list-unit-files|grep postfix #查看邮件服务是否开启systemctl stop firewalld.service #关闭防火墙systemctl is-enable #开启的服务 systemctl disable#关闭的服务 6.运行级别runlevel/etc/inittab 是无效的，由system target 替代。12345678910#永久生效下次登录生效 systemctl get-default graphical.target # 切换到5 systemctl get-default multi-user.target # 切换到3 ##临时生效的话 init3 七种种运行级别如下1[root@centos7 ~]# ls -lh /usr/lib/systemd/system/runlevel*.target 7.网卡名称CentOS7的网卡名称太长，这不符合我们的使用习惯，增加了管理难度，最简单粗暴的方法是在安装系统的时候就把网卡名改了。当然，安装好的系统也是可以修改的。下面分别介绍两种方法。 方法一：(推荐）在进入安装界面的时候把光标移动到Install CentOS7,按下tab键，在后面输入“net ifnames=0 biosdevname=0”回车即可。 方法二：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#进入网卡配置文件目录[root@centos7 ~]# cd /etc/sysconfig/network-scripts/#重命名网卡[root@centos7 network-scripts]# mv ifcfg-eno16777736 ifcfg-eth0#修改配置文件NAME、DEVICE[root@centos7 network-scripts]# vim ifcfg-eth0TYPE=EthernetBOOTPROTO=staticTYPE=EthernetBOOTPROTO=staticDEFROUTE=yesTYPE=EthernetBOOTPROTO=staticDEFROUTE=yesPEERDNS=yesPEERROUTES=yesIPV4_FAILURE_FATAL=noNAME=eth0UUID=552c01f7-fd9d-4f19-913e-379a2bf5a467DEVICE=eth0ONBOOT=yesIPADDR=10.0.0.111&quot;ifcfg-eth0&quot; 14L, 239C written#修改grubsed -i.bak &apos;s#crashkernel=auto rhgb quiet#crashkernel=auto rhgb net.ifnames=0 biosdevname=0 quiet#g&apos; /etc/sysconfig/grub[root@centos7 network-scripts]# vim /etc/sysconfig/grub GRUB_TIMEOUT=5GRUB_DISTRIBUTOR=&quot;$(sed &apos;s, release .*$,,g&apos; /etc/system-release)&quot;GRUB_DEFAULT=savedGRUB_DISABLE_SUBMENU=trueGRUB_TERMINAL_OUTPUT=&quot;console&quot;GRUB_CMDLINE_LINUX=&quot;crashkernel=auto rhgb net.ifnames=0 biosdevname=0 quiet&quot;&quot;/etc/sysconfig/grub&quot; 7L, 263C written#生成启动菜单[root@centos7 network-scripts]# grub2-mkconfig -o /boot/grub2/grub.cfg Generating grub configuration file ...Found linux image: /boot/vmlinuz-3.10.0-327.el7.x86_64Found initrd image: /boot/initramfs-3.10.0-327.el7.x86_64.imgFound linux image: /boot/vmlinuz-0-rescue-7ed5d4eebe4c43e3aadbda68cd0ef311Found initrd image: /boot/initramfs-0-rescue-7ed5d4eebe4c43e3aadbda68cd0ef311.imgdone#重启系统生效[root@centos7 network-scripts]# reboot 8.桌面系统1234567[CentOS6] GNOME 2.x[CentOS7] GNOME 3.x（GNOME Shell） 9.文件系统1234567[CentOS6] ext4 [CentOS7] xfs 10.内核版本1234567[CentOS6] 2.6.x-x [CentOS7] 3.10.x-x 11.启动加载器1234567[CentOS6] GRUB Legacy (+efibootmgr)[CentOS7] GRUB2 12.防火墙1234567[CentOS6] iptables[CentOS7] firewalld 13.默认数据库1234567[CentOS6] MySQL [CentOS7] MariaDB 14.文件结构1234567[CentOS6] /bin, /sbin, /lib, and /lib64在/下 [CentOS7] /bin, /sbin, /lib, and /lib64移到/usr下 15.主机名123[CentOS7] /etc/hostname 16.时间同步1234567891011[CentOS6] $ ntp $ ntpq -p [CentOS7] $ chrony $ chronyc sources 17.修改时间1234567891011[CentOS6] $ vim /etc/sysconfig/clock ZONE=&quot;Asia/Shanghai&quot; UTC=fales $ sudo ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime [CentOS7] $ timedatectl set-timezone Asia/Shanghai $ timedatectl status 18.修改地区1234567891011[CentOS6] $ vim /etc/sysconfig/i18n LANG=&quot;zh_CN.utf8&quot; $ /etc/sysconfig/i18n $ locale [CentOS7] $ localectl set-locale LANG=zh_CN.utf8 $ localectl status 19.服务相关1）启动停止123456789101112131415[CentOS6] $ service service_name start $ service service_name stop $ service sshd restart/status/reload [CentOS7] $ systemctl start service_name $ systemctl stop service_name $ systemctl restart/status/reload sshd 2) 自启动123456789[CentOS6] $ chkconfig service_name on/off [CentOS7] $ systemctl enable service_name $ systemctl disable service_name 3) 服务一览123456789[CentOS6] $ chkconfig --list [CentOS7] $ systemctl list-unit-files $ systemctl --type service 4) 强制停止1234567[CentOS6] $ kill -9 &lt;PID&gt; [CentOS7] $ systemctl kill --signal=9 sshd 20.网络1）网络信息123456789101112131415[CentOS6] $ netstat $ netstat -I $ netstat -n [CentOS7] $ ip n $ ip -s l $ ss 2）IP地址MAC地址1234567[CentOS6] $ ifconfig -a [CentOS7] $ ip address show 3）路由1234567891011[CentOS6] $ route -n $ route -A inet6 -n [CentOS7] $ ip route show $ ip -6 route show 21.重启关闭1）关闭123456789[CentOS6] $ shutdown -h now [CentOS7] $ poweroff $ systemctl poweroff 2）重启1234567891011[CentOS6] $ reboot $ shutdown -r now [CentOS7] $ reboot $ systemctl reboot 3）单用户模式1234567[CentOS6] $ init S [CentOS7] $ systemctl rescue 4）启动模式123456789101112131415161718192021[CentOS6] $ vim /etc/inittab id:3:initdefault: $ startx [CentOS7] $ systemctl isolate multi-user.target $systemctl isolate graphical.target #默认 $ systemctl set-default graphical.target $ systemctl set-default multi-user.target #当前 $ systemctl get-default]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>基础概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-03-30-Linux的文件系统]]></title>
    <url>%2F2019%2F04%2F15%2F2019-03-30-Linux%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[Linux目录结构的特点Windows系统目录和磁盘是强对应的关系，联系很紧密，例如c盘下的目录和文件不可能和D盘的目录有关联或交集。而Linux系统目录与之不同，Linux系统的目录和磁盘等设备是不直接关联的，每个目录都可以关联（官称：挂载）在不同的设备（例如磁盘）上，例如：看似有包含关系的几个目录/、/etc、/boot、/var很可能是在不同的分区或磁盘上。 在Linux中，一切皆是文件。Linux是以文件的方式来管理系统中各个组件，所有的文件存储都以根（”/“）开始，整个文件系统结构就像一颗倒挂的”树“。Linux文件系统的目录结构如图所示： 在Linux中，一切从“根”开始，“/”是所有目录的起点（顶点），Linux根下面的目录是一个有层次的树状结构。我们熟悉的Windows系统，目录和磁盘是强对应的关系，联系很紧密，例如c盘下的目录和文件不可能和D盘的目录有关联或交集。而Linux系统目录与之不同，Linux系统的目录和磁盘等设备是不直接关联的，每个目录都可以关联（官称：挂载）在不同的设备（例如磁盘）上，例如：看似有包含关系的几个目录/、/etc、/boot、/var很可能是在不同的分区或磁盘上。 在逻辑上，所有的目录（包括目录下的子目录）都在最高级别的目录“/”下，根（“/”）目录是所有目录的起始点（顶点），而实际上访问目录/、/etc、/boot、/var时，可能是在访问完全不同的分区和磁盘。 Linux下面的设备（磁盘），如果不挂载是看不到入口的，就像没窗没门的房间，是不能被正常使用的。如果要访问设备，就必须为设备开一个入口，这个入口就是挂载点。挂载点实质就是一个目录，开入口的过程就是将挂载点和磁盘设备关联，即挂载。 Linux的根目录特点 1、根目录“/“是所有目录的顶点。 2、目录结构像一颗倒挂的“树”。 3、目录和分区没有关联，因此不同目录可以映射不同的分区。 4、分区或设备要想访问，必须将其与目录挂载，此时挂载的目录相当于分区的入口。 5、挂载目录的指令为mount。 6、系统开机自动挂载的配置文件为/etc/fstab。 Linux目录的层次标准FHSFHS全称为Filesystem Hierarchy Standard，中文意思是目录层次标准，是Linux的目录规范标准。详细见http://www.pathname.com/fhs/。FHS定义了两层规范： 第一层是“/”目录下的各个目录应该放什么文件数据。 第二层是针对/usr（Unix software resource）和/var(Variable data)这两个目录的子目录在定义的。 参考资料： http://www.pathname.com/fhs/ http://www.ibm.com/developerworks/linux/library/l-proc/index.html 所有目录的命名和结构是有规范，在Linux的目录结构遵照FHS规范。常用目录和子目录的作用如下： /bin ：存放普通用户或管理员使用所有二进制命令文件。 /sbin：存放管理员使用的所有二进制命令文件。 /boot : 存放Linux系统启动引导的安装文件存放目录。 /dev ： 存放特殊存储文件或设备文件存放的目录，比如：cpu、内存、硬盘、光驱、鼠标、键盘等。 /etc ： 存放应用程序配置文件，比如：yum或rpm安装软件的配置文件存放路径，很多服务的启动程序存放的路径。 /home ：非关键性目录，是可选目录，是普通用户的家目录。一般每个用户的家目录，默认为此目录下与用户名同名的目录。 /lib：存放基本的共享库文件或Linux内核模块文件,为系统启动或根文件系统上的应用程序（/bin,/sbin等）提供共享库，以及为内核提供内核模块。 ​ libc.so.：*动态链接的C库，在64位系统下，有可能位于/lib64目录下。 ​ ld：*运行时链接器/加载器，在64位系统下，有可能位于/lib64目录下。 ​ modules：用于存储内核模块的目录，在64系统下，也位于/lib目录下。 /lib64：存放64位操作系统基本的共享库文件或Linux内核模块文件。 /media：便携式设备挂载点。比如：U盘，光盘，移动硬盘等。 /mnt：其他文件系统的临时挂载点。 /opt：附件应用程序的安装位置，比如第三方应用程序devstack。 /root ：管理员root用户的家目录，也是可选目录，并非必选。因为，管理员root在生产环境下一班不允许登录。 /srv：存放此系统专门提供给运行此系统应用程序上的数据。 /tmp：为那些会产生临时文件的程序用于存储临时文件的目录，可供所有用户执行写入操作，有有特殊权限。 /usr：是一个层级结构目录，存放全局共享只读数据。 ​ /usr/bin：普通用户命令。 ​ /usr/sbin：管理员命令，并非系统必须，用于扩展系统功能的命令。 ​ /usr/lib64：存放系统的扩展共享库文件。 ​ /usr/include：存放c程序的头文件位置。 ​ /usr/share：命令手册页和自带文档等架构特有的文件存放位置。 ​ /usr/local：又一个层级目录，让系统管理员安装本地应用程序或者第三方的应用程序。 ​ /usr/X11R6：存放X window的程序文件。 ​ /usr/src：程序源码文件的存位置。 /var：层级目录，存储常发生变化的数据的目录。 ​ /var/cache：应用程序缓存数据。 ​ /var/lib：应用程序的状态信息。 ​ /var/local：为/usr/local提供经常变化的数据。 ​ /var/lock：锁文件存放位置。 ​ /var/log：应用程序的日志文件。 ​ /var/opt：为/opt目录下应用程序提供变化的数据。 ​ /var/run：为运行中的进程提供相关数据。 ​ /var/spool：为应用程序提供的管道数据。 ​ /var/tmp：系统重启后依然需要留存的数据。 /proc：存放内核和进程的基于内存的虚拟文件系统。说白了，就是为内核和进程存储运行的相关数据，多为内核参数。例如：net.ipv4.ip_forward，虚拟化为net/ipv4/ip_forward，存储于/proc/sys/下，因此其完整路径为/proc/sys/net/ipv4/ip_foward /sys：挂载sysfs虚拟文件系统的挂载点，比proc更为理想的访问内核数据的途径，也是一个基于内存的虚拟文件系统。为管理LInux设备提供一种统一文件系统。在Linux内核2.6版本开始才出现此目录，以前并没有。 Linux系统的文件类型： -：表示普通文件，在其他命令中用f表示普通文件 d：表示目录文件，完成路径映射，与windows功能不同。 b：表示块设备文件，完成块设备映射的文件，支持以block为单位随机访问设备 c：表示字符设备文件，完成字符设备映射的文件，支持以字符为单位线性访问设备 ​ major number：主设备号，用于表示设备类型，进而确定要加载的驱动程序 ​ minor number：次设备号，用于表示同一种类型设备下不同的设备，进而确定要驱动的嗯对象 l：表示符号链接文件，类似windows上快捷方式，也成为软链接文件。 p：表示管道文件 s：表示套接字文件，用于两个进程之间进行通信时套接的数据。 Linux系统重要的配置文件/etc/sysconfig/network-scripts/ifcfg-eth : 网卡配置文件 /etc/resolv.conf : DNS配置文件 /etc/hosts : 主机名与IP的映射关系配置文件 /etc/sysconfig/network : 配置主机名的目录 /etc/fstab : 实现开机要挂载的文件系统的一个文件 /etc/rc.local : 实现开机启动的配置或软件 /etc/inittab : 实现开机后系统运行的级别，加载相关的启动文件 /etc/issue : 用户登录时的系统提示 /etc/motd : 用户登录后的系统提示 /etc/redhat-release：系统发行版本信息 /usr/local : 通过源码编译的文件 /var/log/message：系统日志文件]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>基础概念</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F04%2F15%2F2019-03-18-Linux%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[title: 2019-03-18-Linux系统的内存管理date: 2019-04-15 15:21:59tags: 基础概念category: Linux 内存管理中的基本概念内存管理一向是所有操作系统书籍不惜笔墨重点讨论的内容，无论市面上或是网上都充斥着大量涉及内存管理的教材和资料。因此，我们这里所要写的Linux内存管理采取避重就轻的策略，从理论层面就不去班门弄斧，贻笑大方了。 遵循“理论来源于实践”的“教条”，我们先不必一下子就钻入内核里去看系统内存到底是如何管理，那样往往会让你陷入似懂非懂的窘境（我当年就犯了这个错误！）。所以最好的方式是先从外部（用户编程范畴）来观察进程如何使用内存，等到大家对内存的使用有了较直观的认识后，再深入到内核中去学习内存如何被管理等理论知识。 每个程序在操作系统中都对应一个进程（例如：QQ，微信等），所有进程都必须占用一定数量的内存，它或是用来存放从磁盘载入的程序代码，或是存放取自用户输入的数据等等。不过进程对这些内存的管理方式因内存用途不一而不尽相同，有些内存是事先静态分配和统一回收的，而有些却是按需要动态分配和回收的。 对任何一个普通进程来讲，它都会涉及到5种不同的数据段。稍有编程知识的朋友都能想到这几个数据段中包含有“程序代码段”、“程序数据段”、“程序堆栈段”等。不错，这几种数据段都在其中，但除了以上几种数据段之外，进程还另外包含两种数据段。下面我们来简单归纳一下进程对应的内存空间中所包含的5种不同的数据区。 代码段：代码段是用来存放可执行文件的操作指令，也就是说它是可执行程序在内存中的镜像。代码段需要防止在运行时被非法修改，所以只准许读取操作，而不允许写入（修改）操作——它是不可写的。 数据段：数据段用来存放可执行文件中已初始化全局变量，换句话说就是存放程序静态分配的变量和全局变量。 BSS段：BSS段包含了程序中未初始化的全局变量，在内存中 bss段全部置零。 堆（heap）：堆是用于存放进程运行中被动态分配的内存段，每一个程序当开始执行，就会在内存中划出一片空间作为程序运行时代码和数据存放地方。它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。 栈：栈是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。 机器语言指令中出现的内存地址，都是逻辑地址，需要转换成线性地址，再经过MMU(CPU中的内存管理单元)转换成物理地址才能够被访问到。我们写个最简单的hello world程序，用gccs编译，再反编译后会看到以下指令： mov 0x8747ab0, %eax 这里的内存地址0x8747ab0 就是一个逻辑地址，必须加上隐含的DS 数据段的基地址，才能构成线性地址。也就是说 0x8747ab0 是当前任务的DS数据段内的偏移量offset。 在x86保护模式下，段的信息（段基线性地址、长度、权限等）即段描述符占8个字节，段信息无法直接存放在段寄存器中（段寄存器只有2字节）。Intel的设计是段描述符集中存放在GDT或LDT中，而段寄存器存放的是段描述符在GDT或LDT内的索引值(index)。 Linux系统逻辑地址=线性地址为什么这么说呢？因为Linux所有的段（用户代码段、用户数据段、内核代码段、内核数据段）的线性地址都是从 0x00000000 开始，长度4G，这样，线性地址=逻辑地址+ 0x00000000，也就是说逻辑地址等于线性地址了。 这种情况下Linux只用到了GDT，不论是用户任务还是内核任务，都没有用到LDT。GDT的第12和13项段描述符是 KERNEL_CS 和KERNEL_DS，第14和15项段描述符是 USER_CS 和USER_DS。内核任务使用KERNEL_CS 和KERNEL_DS，所有的用户任务共用USER_CS 和USER_DS，也就是说不需要给每个任务再单独分配段描述符。内核段描述符和用户段描述符虽然起始线性地址和长度都一样，但DPL(描述符特权级)是不一样的。KERNEL_CS 和KERNEL_DS 的DPL值为0（最高特权），USER_CS 和USER_DS的DPL值为3。 用gdb调试程序的时候，用info reg 显示当前寄存器的值： cs 0x73 115 ss 0x7b 123 ds 0x7b 123 es 0x7b 123 可以看到ds值为0x7b, 转换成二进制为 00000000 01111011，TI字段值为0,表示使用GDT，GDT索引值为 01111，即十进制15，对应的就是GDT内的__USER_DATA 用户数据段描述符。 从上面可以看到，Linux在x86的分段机制上运行，却通过一个巧妙的方式绕开了分段。 Linux主要以分页的方式实现内存管理。如下图所示： 前面说了Linux中逻辑地址等于线性地址，那么线性地址怎么对应到物理地址呢？这个大家都知道，那就是通过分页机制，具体的说，就是通过页表查找来对应物理地址。 准确的说分页是CPU提供的一种机制，Linux只是根据这种机制的规则，利用它实现了内存管理。 在保护模式下，控制寄存器CR0的最高位PG位控制着分页管理机制是否生效，如果PG=1，分页机制生效，需通过页表查找才能把线性地址转换物理地址。如果PG=0，则分页机制无效，线性地址就直接做为物理地址。 分页的基本原理是把内存划分成大小固定的若干单元，每个单元称为一页（page），每页包含4k字节的地址空间（为简化分析，我们不考虑扩展分页的情况）。这样每一页的起始地址都是4k字节对齐的。为了能转换成物理地址，我们需要给CPU提供当前任务的线性地址转物理地址的查找表，即页表(page table)。注意，为了实现每个任务的平坦的虚拟内存，每个任务都有自己的页目录表和页表。 为了节约页表占用的内存空间，x86将线性地址通过页目录表和页表两级查找转换成物理地址。32位的线性地址被分成3个部分：最高10位 Directory 页目录表偏移量，中间10位 Table是页表偏移量，最低12位Offset是物理页内的字节偏移量。 页目录表的大小为4k（刚好是一个页的大小），包含1024项，每个项4字节（32位），项目里存储的内容就是页表的物理地址。如果页目录表中的页表尚未分配，则物理地址填0。页表的大小也是4k，同样包含1024项，每个项4字节，内容为最终物理页的物理内存起始地址。 每个活动的任务，必须要先分配给它一个页目录表，并把页目录表的物理地址存入cr3寄存器。页表可以提前分配好，也可以在用到的时候再分配。 还是以mov 0x8747ab0, %eax中的地址为例分析一下线性地址转物理地址的过程。 前面说到Linux中逻辑地址等于线性地址，那么我们要转换的线性地址就是 0x8747ab0。转换的过程是由CPU自动完成的，Linux所要做的就是准备好转换所需的页目录表和页表（假设已经准备好，给页目录表和页表分配物理内存的过程很复杂，这里不做展开讨论，喜欢内核优化的可自行研究）。 线性地址 0x8747ab0 转换成二进制后是 1000 0111 0100 0111 1010 1011 0000 0000，最高10位1000 0111 01的十进制是541，CPU查看页目录表第541项，里面存放的是页表的物理地址。线性地址中间10位00 0111 1010 的十进制是122，页表的第122项存储的是最终物理页的物理起始地址。物理页基地址加上线性地址中最低12位的偏移量，CPU就找到了线性地址最终对应的物理内存单元。 我们知道Linux中用户进程线性地址能寻址的范围是0 － 3G，那么是不是需要提前先把这3G虚拟内存的页表都建立好呢？一般情况下，32位机器的物理内存是小于3G的，加上同时有很多进程都在运行，根本无法给每个进程提前建立3G的线性地址页表。Linux利用CPU的一个缺页机制解决了这个问题。进程创建后我们可以给页目录表的表项值都填0，CPU在查找页表时，如果表项的内容为0,则会引发一个缺页异常，进程暂停执行，Linux内核这时候可以通过一系列复杂的算法给分配一个物理页，并把物理页的地址填入表项中，进程再恢复执行。当然进程在这个过程中是被蒙蔽的，它自己的感觉还是正常访问到了物理内存。]]></content>
  </entry>
  <entry>
    <title><![CDATA[2019-03-02-Linux系统基础介绍]]></title>
    <url>%2F2019%2F04%2F15%2F2019-03-02-Linux%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[本文作为Linux操作系统开篇文章，主要介绍一些操作系统的基础概念和原理，然后简要介绍Linux的发展历史，以及市面上常见的Linux系统版本。 操作系统基本概念和原理操作系统可以说是目前所有现代人都了解的一个名词，大家平时的日常工作和生活都离不开操作系统。目前，世界上主要流行的操作系统有三类：Linux、Windows和Mac OS。其中，后两个操作系统是大家熟悉的，大家的日常工作和生活大部分都会跟这两种操作系统打交道，对于Linux操作系统可能普通只是处在听说过的阶段，很少有人去详细了解和使用。 那么如果有人问你什么是操作系统？虽然大家平时都在用，但是估计很多人都会一脸懵逼。其实，操作系统就是处在计算机硬件和人之间的一个重要的中间部件，它存在意义有2个：一是通过在其上部署应用软件，满足人们操作计算机硬件的需求。二是将上层应用软件与底层硬件进行解耦，满足人们随时随地、随心所欲的操作计算机硬件的要求。 作系统的官方定义是：英文名Operating System，简称OS。是计算机系统中必不可少的基础系统软件，它是应用程序运行以及用户操作必备的基础环境支撑，是计算机系统的核心。**从官方定义不难看出，操作系统（后统称为OS）首先是一个软件，是一个支撑软件，支撑应用软件和人们的操作。所以，它是一种特殊软件，主要由内核+库两部分实现（如下图所示）。 内核存在的目的就是将底层的硬件进行软件化封装，方便上层调用来操作硬件。而库的作用就是将内核的软件封装再构造成一个个标准函数，供上层应用去调用从而避免应用直接操作内核的风险。其次，它还是计算机系统的核心。我们现在讲的计算机系统都是冯诺依曼架构（如下图所示），由控制器、运算器、存储设备和输入输出设备四部分构成，OS就是这些部件协调运作赖以支撑的基础，所以它也是计算机系统的核心。 综上，用一句话概括操作系统的概念就是：操作系统就是位于用户与计算机系统硬件之间用于传递信息系统程序软件。 什么是Linux Linux系统组成如上图 内核：是系统的心脏，是运行程序和管理像磁盘和打印机等硬件设备的核心程序。 Shell：是系统的用户界面，提供了用户和内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行，是一个命令解释器。但它不仅是命令解释器，而且还是高级编程语言，shell编程。 文件系统：文件系统是文件存放在磁盘等存储设备上的组织方法，Linux支持多种文件系统，如ext3,ext2,NFS,SMB,iso9660等。 应用程序：标准的Linux操作系统都会有一套应用程序例如X-Window,Open Office等。 和windows一样，Linux也是一种操作系统。与windows的商业不同的是，Linux是一套完全开源的操作系统，其实现代码全部呈现给使用者。就像你亲自下厨做饭一样，所有的原材料和工序你都清楚，因此做出饭菜自然比外卖要安全可靠。所以，国内一些企业自研操作系统均是由Linux源码封装改造而来，其宣称”自主可控“，也无可厚非。 Linux在设计之初，是基于Intel x86 PC架构的，是一套多任务、多用户并支持多线程和多CPU的操作系统。其设计的本意就是打破商业软件版权的限制（因为当初unix系统被AT&amp;T回收版权，禁止向学生群体开放源码，从而引起版权纠纷），全世界都能使用的类unix系统兼容产品。从其1991年诞生到现在约30年的时间，Linux操作系统主要用于服务器领域、嵌入式开发，其在个人PC桌面领域应用较少，这也是其不被大众熟悉的原因。（目前，在个人PC桌面领域做的较好由国外的ubuntu、fedora，国内的深度deepin，中兴的新起点等操作系统）。其实，现在windows在个人桌面操作系统的优势除了软件生态以外，也不再剩下什么。如果Linux的软件生态得到广大发展，那么可以预期个人桌面系统将发生颠覆性的变化。这也是微软为什么在即将发布的windows 10的1903版本推出同时兼容读写Linux系统文件的原因，微软现在已经很着急啦：）。 全球超算99.9%都是使用Linux，全球和国内排名前1000的互联网公司90%的服务器也使用的是Linux，就是因为Linux系统优越性使其在服务器领域一举奠定了霸主地位，无论是windows还是mac os都无法与其竞争。Linux的优越性主要都继承自unix系统，主要由以下几点： 具备开放源代码的程序软件，可自由修改。 Unix系统兼容，具备几乎所有Unix系统的优点。 可自由传播，无任何商业化版权制约。 适合Intel x86CPU系列架构的计算机。 严格来说，Linux这个词本身只表示Linux内核，但是人们已经习惯用Linux来形容整个基于Linux内核的操作系统，并且是一种使用GNU通用公共许可证（GUN general public，GPL）工程的，包括各种工具和数据库的操作系统。 Linux内核除系统调用外，由五个主要的子系统组成：进程调度、内存管理、虚拟文件系统、网络和进程间通信(IPC)。 各个子系统的主要功能为： 1、进程调度：它控制着进程对CPU的访问，当需要选择一个进程开始运行时，由调度程序选择最应该运行的进程； 2、内存管理：它允许多个进程安全地共享主内存区域，支持虚拟内存；从逻辑上可以分为硬件无关的部分和硬件相关的部分； 3、虚拟文件系统(VFS)：它隐藏了各种不同硬件的具体细节，为所有设备提供统一的接口，支持多达数十种不同的文件系统，分为逻辑文件系统和设备驱动程序； 4、网络：它提供了对各种网络标准协议的存取和各种网络硬件的支持，分为网络协议和网络驱动程序两部分； 5、进程间通信：支持进程间各种通信机制，包括共享内存、消息队列和管道等。 GNU的全称为GNU’s not Unix，意思是“GNU不是Unix”，GNU计划，又称革奴计划，是由Richard Stallman在1984年公开发起的，是FSF（自由软件基金会）的主要项目，这个项目成立的本意就是建立一套完全自由的可移植的类unix操作系统。在Linux内核发布的时候，GUN项目已经完成了除系统内核之外的各种必备软件的开发。在Linus Torvalds和其他开发人员的努力下，GNU项目的部分组件又运行到了Linux内核之上，例如：GNU项目里的Emacs、gcc、bash、gawk等，至今都是Linux系统中很重要的基础软件。因此，如今我们说的Linux操作系统实际上是GNU/Linux操作系统。 而GPL是一个最著名的开源许可协议，其核心是保证任何人有共享和修改自由软件的自由，任何人有权取得、修改和重新发布自由软件的源代码权利，但都必须同时给出具体更改的源代码。正是因为该协议的存在，才使得开源软件有如今如火如荼的发展局面。 Linux系统启动顺序和基本概念开机自检（BIOS)—&gt;MBR引导（512字节，其中前446字节是Grub菜单，后64字节是分区表）—&gt;GRUB菜单（选择启动系统）—-&gt;加载内核Kernel—&gt;运行INIT进程。其中，INIT进程在Linux系统的用PID编号为1来表示，意思为所有进程的“大佬”。 BIOS：基本输入输出系统（basic input output system，BIOS），是一组固话到计算机主板ROM上的程序，保存着计算计算最重要的基本输入输出程序、系统设置信息、开机自检程序和系统自启动程序，为计算机提供最底层的、最直接的硬件设置和控制。 MBR：一种硬盘分区格式。目前，硬盘分区格式主要有两种，分别是MBR和GTP。MBR，即主引导记录扇区（master boot record），位于整块硬盘的0磁道0煮面1扇区，用于操作系统对硬盘读写时，判断分区的合法性以及分区引导信息的定位。总共512字节，前446字节用于主引导记录，后64字节用于存储硬盘分区表（DPT），每个分区表大小16字节，共4个分区表，所以采用MBR分区格式的硬盘最多只能分出4个分区（主分区+扩展分区），最后两个字节”55，AA“是分区的结束标志。MBR分区表的格式如下： GPT：全局唯一分区格式，正在逐渐取代MBR成为新标准。它和统一的可扩展固件接口（unified extensible firnware interface，UEFI）相辅相成。UEFI用于取代BIOS，而GPT用于取代MBR。在GPT硬盘中，分区表中的位置信息存储在GPT头中，第一个扇区同样有一个与MBR类似的标记，叫做受保护的主引导记录（protected main boot record，PMBR）。其作用是当使用不支持GPT的分区工具时，整个硬盘将显示为一个受保护的分区，防止数据被破坏，其中存储的内容与MBR一样，之后才是GPT头部信息。与MBR相比，支持2TB以上的磁盘，如果使用fdisk分区，最大只能建立2TB大小的分区，创建大于2TB的分区时，需使用parted工具，同时必须使用64位操作系统。以下是GPT分区表的数据格式： GRUB：多操作系统启动程序（GRand unified bootloader）。支持多操作系统引导，当系统中装载多操作系统时，在系统启动时便于用户选择。GRUB还可用于选择操作系统分区上的不同内核，也可用于向这些内核传递启动参数。Linux常见的引导程序包括：LILO、GRUB、GRUB2。CentOS 6.x系统和Ubuntu系统默认采用GRUB引导程序，所以当我们有需要编译GRUB菜单时，执行如下命令： 1grub-mkconfig -o /boot/grub/grub.cfg CentOS 7.x系统默认采用GRUB2引导程序，所以当我们有需要编译GRUB菜单时，执行如下命令： 1grub2-mkconfig -o /boot/grub2/grub.cfg GRUB加载引导程序的流程如下： GRUB2是基于GRUB开发的更加安全强大的多系统引导程序，同时采用模块化设计，使得GRUB2核心更加尽量，使用更加灵活，也不需要像GRUB那样分为stage1、stage1.5和stage2三个阶段。 init：就是系统的不同运行级别对应加载的启动文件。在Linux跟目录下的/etc/目录下，有与系统运行级别对应的rc开头的目录，里面存在对应系统运行级别的脚本文件。Linux内核加载完成后，通过加载这些启动文件完成系统的初始化。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>基础概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-10-10-云计算的技术架构]]></title>
    <url>%2F2018%2F10%2F10%2F2018-10-10-%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9A%84%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[云计算总体技术架构下图是一张从云计算上下文参考架构引申出的云计算总体技术架构图。其实，当我们面临一个复杂系统的认知学习，首先需要从全局对其做鸟瞰式概览，将其关键部分抽象为几个关键模块。然后，分析每个关键模块之间的关联，也就是上下文对接关系。最后，再由上下文参考架构拓展出具体关键流程和服务模块。做到上述“收放自如”，才算真正入门，才具备继续深钻的基础条件。：） 上图左边是云计算的参考架构，主要由4个关键子模块和1个关键服务组成。4个关键子模块包括：CloudDevice（云设备）、User（用户&amp;开发者）、ServiceCenter（运营服务中心）和OperatorCenter（运维中心）。而将4个关键子模块进行衔接的关键服务就是我们常说的IaaS、PaaS和SaaS三层平台的逻辑抽象，由IaaS层的CloudOS统一完成纳管和呈现。 对上下文架构参考图进一步拓展，就是右边的云计算解决方案的整体技术架构图。这张整体技术架构图向上可以支撑公有云、私有云、电信云和混合云的各种方案部署。虽然，其涉及的技术方案很多，但其本质上还是底层四个关键技术领域。即，计算、网络、存储和安全。说白了，云计算要想彻底精通，必须同时精通计算、网络、存储和安全四个领域。 云计算的核心技术识别 虚拟化及资源调度平台 虚拟化软件：高性能、高可靠性、智能调度算法 数据中心的一体化自动管控 分布式计算/存储框架 虚拟化的硬件加速 计算与存储平台 定制化的服务器与存储：讲话涉及大内存，高网络/存储IOPS 数据中心安全性：可信赖、完整性、可用性 网络平台 高密度、低成本的10GE互联 网络的集群与虚拟化 基础设施平台 E2E的集成交付能力 绿色节能的工程设计 从物理设备（服务器、存储和网络设备）、虚拟化软件平台、分布式计算和存储资源调度、一体化自动化管控软件、虚拟化数据中心的安全和E2E的集成交付能力，都是构建高效绿色云数据中心的关键技术。 简化设计的大内存、高网络和存储IOPS的服务器，可以为云数据中心提供强大的计算能力。 高IOPS，支持链接克隆、精简置备、快照等功能的存储设备，可以为数据中心提供强大的存储能力。 高密度、低成本，支持大二层网络技术的交换设备为数据在二层网络流动提供交换能力。 虚拟化软件平台，可以抽象物理资源为资源池，给云用户配置不同规格虚拟机提供底层支撑。 灵活、高效的分布式计算或存储框架，为云计算的资源调度和调整提供支撑。 从门禁监控、网络接入、虚拟化平台软件安全、经过安全加固的OS和DB到用户的分权分域管理，保证数据中心的放心使用。 一体化自动化的管控软件，提升维护人员的效率，降低企业成本。 云计算的关键技术云计算的单点技术都是“老”技术，组合起来却有无与伦比的的价值。马云有句话说的好，从技术层面来讲，云计算的就是新瓶装旧酒。 计算架构：支持scale out模式，整体性能最优，基于软件可靠性和可扩展性。 云计算硬件 服务器：高可靠性、高性能 网络：高密度以太网交换机 存储：低成本、多备份 云计算软件 并行计算技术 分布式存储 分布式文件管理 虚拟化技术 智能化云计算系统管理技术 通过对多项核心技术进行归类汇总，可归结为三个方面：整体的计算架构、承载的硬件设备和软件系统。 整体的计算架构：需要涵盖高性能、高可靠和可扩展。 云计算硬件包括：高可靠和高性能的计算服务器提供计算资源；低成本、数据安全的存储设备提供数据存储空间；支持大二层网络的高密度交换机进行数据的通信和交流。 云计算软件包括：用于大数据的并行分析计算技术；整合存储资源提供动态可伸缩资源池的分布式存储技术；用于数据管理的分布式文件管理；计算、存储等资源池化的虚拟化技术；简化运维人员工作，方便高效智能运维的系统管理技术。 云计算的硬件技术：计算架构 早起许多IT系统开始很简单，但当需要进行系统扩展时就会变得复杂。升级系统最常见的原因是需要更多的容量，以支持更多的用户、文件、应用程序或连接的服务器。常见的系统扩展方式有Scale up和Scale out两种。 Scale up 纵向扩展架构主要是利用现有的系统，通过不断增加存储容量来满足数据增长的需求。但是这种方式只增加了容量，而带宽和计算能力并没有相应的增加。所以，整个系统很快就会达到性能瓶颈，需要继续扩展。 Scale out 横向扩展架构的升级通常是以节点为单位，每个节点往往将包含容量、处理能力和I/O带宽。一个节点被添加到系统，系统中的三种资源将同时升级。而且，Scale out架构的系统在扩展之后，从用户的视角看起来仍然是一个单一的系统。所以Scale out方式使得系统升级工作大大简化，用户能够真正实现按需购买，降低TCO。 云计算的设计思想是以最低成本构建出整体的性能最优，与传统电信设备和IT设备（服务器、大型机、企业存储等）追求设备可靠性和性能的思路完全不同。 云计算的硬件技术：存储系统 企业存储一般采用专用的存储设备，成本高。 分布式存储系统把使用便宜IDE/SATA硬盘的服务器本地存储构建存储资源池，既降低了服务器的成本，也降低了存储成本，构建最低成本的计算和存储。 通过“分布式存储和多副本备份”来解决海量信息的存储和系统可靠性，数据存储可以配置多份副本，保证数据的安全性。 云计算的硬件技术：数据中心的联网 东西向流量增长 并行计算业务(如：搜索)需要服务器集群协同运算，产生大量横向交互流量 虚拟机的自由部署和动态迁移，虚机间需要实时同步大量的数据 随着云计算的发展，越来越多业务承载在数据中心的虚拟机上，业务数据的流动从南北向转变为东西向，对数据中心网络的需求和冲击提出了很大挑战。 数据中心内部虚拟机的迁移促进了大二层网络虚拟交换技术的发展，支持大容量数据的通信和超高的端口密度，可以连接更多的服务器提升数据中心的处理能力。 云计算的软件技术：集群管理 云计算虚拟化平台软件，支持分布式的集群管理。可以针对业务模型，对物理服务器创建不同的业务集群，并在集群内实现资源调度和负载均衡，在业务负载均衡的基础上实现资源的动态调度，弹性调整。 云计算虚拟化平台需要支持各种不同的存储设备，包括本地存储、SAN存储、NAS存储和分布式本地存储，保证业务的广适配性。 同时，提供链接克隆、资源复用、精简置备和快照功能，降低企业成本并提供高效率、高可靠性的资源池。 结束语截止目前，云计算基础入门部分已更新完毕，此部分主要是针对打算入坑的新人，给其一个总体上概括认知。后续本打算重写虚拟化技术。但是，考虑到OpenStack以及Docker容器涉及很多Linux基础知识，故临时调整更新内容为重写Linux部分。主要涉及：Linux系统组成、常用命令总结（这部分是我自己总结，大家可下载留存参考）、三剑客基本使用教程和shell编程基础。 完成Linux部分更新后，再继续重写虚拟化技术入门，涉及计算、存储和网络虚拟化三部分。以上与目前更新云计算基础统一构成基础概念部分。所谓“基础不牢，地动山摇”，因此这部分虽然是入门，其实还是很重要的部分。]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>基础概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-09-25-云计算带来哪些变化]]></title>
    <url>%2F2018%2F09%2F25%2F2018-09-25-%E4%BA%91%E8%AE%A1%E7%AE%97%E5%B8%A6%E6%9D%A5%E5%93%AA%E4%BA%9B%E5%8F%98%E5%8C%96%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[传统的IT架构与云计算架构投资决策的差异 传统的IT架构俗称三层架构，即，表示层、业务逻辑层和数据访问层。虽然三层架构将系统在逻辑上分层了三层，但它并不是物理意义上的分层。也就是说对于不同层的代码而言，经历编译、打包、部署之后，所有的代码最终还是运行在同一个进程之中。 对于这种功能集中、代码中心化、一个发布包、部署后运行在同一个进程中应用程序，我们称之为单块架构应用。企业采用这种架构开发某个业务时，对计算、网络、存储、服务器资源的需求都是独占的，不同业务之间是一种烟囱式的条块化分割。随着业务的增加，需求功能的迭代，单块架构只能通过增加自己独占资源组内的资源来实现，即使其他应用资源占用很低，也无法共享其它应用的空闲资源。因此，这种架构模式已经很难满足业务快速变化的需要。 一方面，代码的可维护、扩展性、灵活性在降低； 另一方面，系统的修改成本、构建以及维护成本在增加，因此单块架构的改造与重构势在必行。 随着云计算的出现，在技术上面其实有四点最关键的技术： 第一个技术就是服务器虚拟化，前面讲到了，就是把一台物理的服务器，当成很多逻辑的服务器来用，这种分割的目的就是那提升资源共享利用率，达到业务可以快速的部署，代码重构维护简单的目的。 第二个技术就是分布式的存储，就是把一些原来的专用大存储服务器，比如存储9000那种大的设备大的柜子。把它里面设计成一台一台小的服务器，通过软件方式融合在一起进行管理，当成是一个“存储池”来管理这个资源，这种就是分布式的存储。分布式的存储的好处是可以提高存储的速度，同时以按照客户的需要去扩容。比如：可以像虚拟CPU和虚拟内存那样，实现存储资源的弹性部署。同时，随着Server SAN概念的提出，分布式存储的硬件基于x86通用服务器，远比专用存储服务器的硬件成本低。 第三个技术就是软件定义的网络，也就是现在炒的火热的SDN。我们都知道网络这一块管理起来很复杂，需要提前做好规划，提前分配IP地址。那么，如何通过软件来实现呢？就是通过云计算实现的云资源池，利用里面基础虚拟网络资源，分析这类资源的随时变化，通过编程的方式将这种变化通过协议流去控制实现，通过软件去管理，自动化完成。这就是软件定义网络概念的本质。 第四个技术就是REST，它本质上是一个协议，一种资源状态转移协议。前面说过传统IT的三层架构，主要分为表示层、业务逻辑层和数据访问层。由于在云计算架构里，它的资源是池化的，资源之间是共享的（隔离的本质其实是最大的共享！详见后面OpenStack Neutron部分论述），交互很快，用传统的三层架构软件去实现这种调度根本不现实。因此，就出现了REST协议，它其实是将传统三层架构的功能做了整合，通过它应用可以直面底下的虚拟资源池。这相当于是一个资源调度程序，由应用程序调用，直接去使用这种云的资源。当这种弹性的资源调度模式与上层应用关联起来之后，应用不够或者坏掉了，都没关系，直接再起一个新应用，让应用扩展起来，底层的虚拟机资源也随之增加。这里面有几个特点，第一个就是这种协议是一种API接口协议，所有做开发的人都必须遵循的一种接口协议，为分布式开发和CI/CD(持续集成，持续交付）创造了条件。第二个是云计算采用轻量级的云OS，其主要职责是纳管，并不是具体实现。其上应用恢复与扩展的速度比传统的三层架构更快，为敏捷开发创造了条件。但是，它唯一的遗憾还是未能有一个组织出来进行标准化定义，因此兼容性方面还有缺陷。直到现在容器技术的兴起，才使上述两个场景（CI/CD和敏捷开发）真正落地。 云时代商业模式的变化：从自建变为租用 企业由纯粹的自建IT系统逐步转向混合云的模式。 部分核心应用私有云，一般应用租用公有云服务。 云服务又分为：IaaS、PaaS、SaaS三种方式。 以前，IT企业提供业务需要自己建设机房，买了一堆服务器、交换机部署一个数据中心，然后在上面再部署自己的软件来提供服务。往往这都是一笔不小的花费，从而导致好多创业公司的启动经费过高。 随着IDC机房的出现，云计算技术的普及，这种模式发生了变换。好多公司完全可以通过租借云DC的方式来部署自己的业务软件。所谓的云DC，其实就是通过云计算技术将IDC机房中基础设施通过虚拟化资源的方式来统一提供，租用的费用远远比自建少得多，同时可以节省一笔维护开销，从而导致创业的门槛大大降低。 往往这些企业只需要购买很少一部分服务器和交换机来部署自己的核心业务，存储自己的核心数据，同样也使用云计算来提高资源利用率，降低成本，这部分往往我们称为企业私有云。非核心的企业业务软件和数据，往往通过公有云提供商提供云DC/云主机部署，这部分往往我们称为公有云。两者的结合，就诞生了混合云的概念。因此，混合云是从企业业务的全局部署角度提出的，并不是云计算的新技术分支，现在IT企业提供业务大部分都是通过混合云的方式提供。与混合云类似的还有行业云，两者之间的区别非常小，可以合并为一种。 那么租用云DC到底租用的是什么？这个从需求者不同需求角度来说，分为IaaS（基础设施即服务），PaaS（平台即服务），SaaS（软件即服务）。有些企业，软件开发能力很强，具备平台级的开发能力，但是缺少运行软件平台的服务器、存储和交换机。为了节省成本，他们往往都是向云服务提供租用云主机，将自己的软件部署在云主机上，这种租用的就是IaaS。另一些企业，具备应用层软件的开发能力，但不具备数据之间逻辑处理的能力（即，算法），同时为了节省成本，他们往往都是云服务提供上租用开发平台（如大数据处理），也连带底层基础设施（云主机）一起租用，这种租用的就是IaaS+PaaS。目前还没有哪家企业只租用PaaS，自建IaaS的方式来部署自己的业务。至于SaaS的租用，目前只涉及个人办公（如web版office）或开发领域（如Mob等应用），很少有面向企业的服务应用。 云时代建设模式的变化：从烟囱变为水平 芯片、新介质取得突破，以及CPU、硬盘、网络性能大幅提升为IT架构的水平化演进提供了技术支撑。云计算经历了从虚拟化—云资源池—平台&amp;应用的逐步发展阶段。 云服务提供商为了提供各种云服务，必然要建设相应的数据中心，这种建设是去IOE化的。去IOE化的概念，最早是阿里巴巴提出的，其本意是，在阿里巴巴的IT架构中，去掉IBM的小型机、Oracle数据库、EMC存储设备，代之以自己在开源软件基础上开发的系统。说白了就是结合开源软件技术，将IOE的各层级功能通过通用硬件平台，分布式架构，软硬件解耦和软件定义存储的方式实现，通过Cloud OS进行纳管，并统一对外提供服务。 前面也提到了，云计算的出现不是突然出现的，详见博文 云计算的前世今生。随着软硬件技术的发展，他主要经历了三个发展阶段。第一个阶段就是虚拟化阶段，代表技术就是VMware和Xen，主要通过虚拟化技术来提升企业资源利用率，从而降低成本。第二个阶段是云DC阶段，代表技术就是OpenStack，但是OpenStack最成熟的部分还是其IaaS服务提供，这个阶段主要通过提供云主机和云DC来降低企业运营成本。第三个阶段就是现在火热的容器化应用阶段，其实容器也是一种虚拟化技术，属于轻量级操作系统级别的虚拟化。它是以软件进程的方式来封装各个应用模块，通过共享底层操作系统内核，来提供各种平台服务和应用服务（PaaS+SaaS）。通过这种技术，使得前几年DevOps概念完美落地并真正意义上实现敏捷开发，这是一种企业应用现有管理模式的变革。 云计算给企业带来哪些变化 要说云计算技术给企业带来了哪些变化，最明显的还要数银行。 银行采用基于云计算的新架构以后，它的第一个变换就是IT资源池化了，即使有一些资源损坏了，它还可以继续工作，并不影响它的业务。所以这样提高了就是业务的质量，减少了业务中断，保证这个业务的连续性，全年的业务停机时间就大大减少。 第二个变化就是业务提供的速度，当业务需要很多IT资源时，可以通过资源弹性扩缩容的方式，来满足业务需求。不像以前，一个业务办理的好慢好烦，甚至死机，影响客户的体验，客户就可能去选择其他家更快业务。所以通过把资源管理好，也让IT人员有更多的创新机会，可以开发包括手机端的应用，让更多的人通过手机随时随地去办理业务。不知你注意到没有，国内这么多银行，招商银行在这方面一直走在其他银行前面。 还有更重要的一点对于企业来说，它的业务成本的降低。银行对散户，对个人的业务，实际上都是亏钱的，个人取钱的交易或者是存钱的交易，银行都要投入人力和场地等费用，而现今，通过手机银行和互联网银行，可以把这个散户交易成本降下来，通过云计算等互联网技术，免除了场地网点的费用而且业务处理速度非常的快，用户体验也提升了。]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>基础概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-09-12-云计算的前世今生]]></title>
    <url>%2F2018%2F09%2F12%2F2018-09-12-%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%2F</url>
    <content type="text"><![CDATA[云计算的发展历程 云计算的历史也是蛮好玩的… 一开始就是在2003年之前，大家都在在提升CPU的计算能力，提升存储的空间，使得CPU性能越来越高、存储变得更大。 到了2003年以后呢，企业的数据中心里面发现资源已经很空闲，因为架构设计的原因，让这些服务器很多时间都处在平均不到5%的使用率，大部分99%都是空闲的。相当云投资一千块，其实只用了五块钱，实际上产生了很大的浪费。同时，机房空间、动力等基础设施资源被占用过多，导致数据中心内部无法放置更多机柜、机架和服务器，需要买地建设新的机房（按照国内的地价/房价，这基本是不可能的）。因此，在2003年VMware这个厂商提供了服务器虚拟化的技术，就是把一台服务器一台设备，切成很多虚拟的小块服务器，也就是俗称的“虚拟机”。而让业务应用在虚拟机上面去工作，这就叫服务器虚拟化。 这个技术解决了数据中心里面机房空间和动力资源不够的问题，原来需要十台服务器的，现在在一台高级的服务器里面切了十份，分别给10个业务应用使用，即使这样也就才用了40%的CPU，电力节省了接近9/10，而且一个机房里面容量就可以做二十倍数的的提升。原来部署一百台物理的服务器，现在可以部署两千台虚拟服务器，大大的提升了资源的利用率。而虚拟化的另一个好处就是还大幅提升了客户业务的创新的积极性，因为以前他们服务器都摆不下，好多东西不能做，现在摆下了，所以他要做什么东西都可以试试。但是这个虚拟化技术只解决了资源的共享问题，还没解决运营效率问题。 到了2006年的时候，亚马逊提出了公有云的服务，那时还不叫云计算，叫Amazon Web Service, 简称AWS（现在亚马逊的云计算项目还是沿用这个叫法）。亚马逊大家都知道，它原本是一个做超市的，超市的概念就是你需要你去拿，拿了就到门口结帐，结帐你就拿走。然后亚马逊它把这个计算资源也当成一种，把服务器也当成资源去卖，但是它卖的不是物理的，不是让你搬一台服务器走。而是建好一个数据中心，当你用的时候，你要多少台我们就给你多少台，你只要刷信用卡在网上做支付，你就可以使用这些逻辑上提供给你的资源，这也是虚拟化资源第一次被当成商品出售的案例。随后，Amazon在此基础上提出了云计算的概念，并开发出了公有云业务。亚马逊的这种公有云的这种服务对企业而言，想做的时候，只要付钱就可以做了。而且一般企业业务部门都很有钱，所以业务部门的愿意投钱去做这个事情。 到了2010年的时候，出现了另外一种云计算架构，叫OpenStack。它是NASA就是美国太空总署那个NASA和RackSpace联合做的。RackSpace也是做公有云服务的运营商，就像我们的阿里云一样，它也是想学习亚马逊。但是它的人没有亚马逊的团队这么大，所以它把这个架构给开源出来，形成一个OpenStack开源社区，大家都在OpenStack上面去开发完善，然后让这个框架变得更好，目前OpenStack会聚了全球的研发力量，并吸引了几乎全球所有主流IT厂商的支持，帮它完善这个架构，形成了云计算领域一个全新的强大生态系统。OpenStack社区把这个架构公开出来以后，各个企业都看到了一个新的技术，可以运用到他们自己企业里面，所以很多企业都开始基于OpenStack做自己的私有云，让自己家的IT，变得效率更高，资源更有效。 然后，到了2014年以后，很多企业经过这么多年的建设以后，基本都走在了公有云和私有云这两条路上，私有云就是在家里，自建自用，不对外。公有云就是公开对外出售虚拟资源（如服务器、负载均衡器、防火墙等）在亚马逊、阿里或者华为都有这类服务，只要花钱买就可以。很多企业，尤其是中小企业，无力承担基础设施建设费用，就是通过购买EC2（云计算服务中资源服务器）来部署它的业务。还有一些企业，将一部分业务部署在公有云上，另一部分私密性业务部署在私有云上，这样就合成了一个混合云的状态。 云计算技术的演进历程 随着云计算技术走向成熟，在混合云时代，企业对于云计算的相关技术成熟度的问题已经不太关注了。企业新的追求是，让IT的人员怎么在一个团队的模式下面，对公有云和私有云的混合云资源进行统一的管理。这是一个管理的概念，也是混合云构建的核心。 云计算（Cloud Computing）是分布式计算（Distributed Computing）、并行计算（Parallel Computing）和网格计算（Grid Computing）的发展或者说是这些计算机科学概念的商业实现。 并行计算（Paralled Computing）：同时使用多种计算资源解决计算问题的过程，主要目的是快速解决大型且复杂的问题。 特点：把计算任务分派给系统内多个计算单元。 分布式计算（Distributed Computing）：把一个需要巨大计算能力才能解决的问题分成多个小部分，把这些小部分分配给多个计算进行处理，最后综合这些计算结果得到最终的结果。 特点：分配计算任务到网络中多台独立的机器。 网格计算（Grid Computing）：利用互联网把地理上广泛分布的各种资源连成一个逻辑的整体，就像一台超级计算机。 特点：分布式计算的一种，为用户提供一体化的信息和应用服务。 云计算的部署模式 私有云（Private Cloud）： 企业利用自有或租用的基础设施资源自建的云。 社区云/行业云（Community cloud）：为特定社区或行业所构建的共享基础设施的云。 公有云（Public cloud）：出租给公众的大型的基础设施的云。 混合云（Hybrid cloud）：由两种或两种以上部署模式组成的云。 从部署模式上看，云计算又分为私有云、社区云也就是行业云、公有云、和混合云，这几种形态，这里也给出了具体的定义。简单理解： 私有云就是企业建在自家院子里的，只给自己用的云，有些公司特别是公有云厂商喜欢把“私有云”称作“专有云”，名字不同，但含义基本相同，虽然这些厂商不愿意承认。 社区云既行业云，应用范围要比私有云广泛，更像是由家庭和家族的关系，往往应用在某个特定的区域或特定行业，主要给特殊血缘关系的行业或社区家族成员使用。 公有云的使用范围则更加宽泛，基本上只要给钱谁都可以用，因此公有云的规模往往也更大。 但公有云的用户鱼龙混杂，像火车站一样，而且目标明显，不仅使用的好人多，惦记着甚至使用的坏人也不少，所以经常成为黑客及非法集团的攻击或信息偷窃目标。但瑕不掩瑜，人们不能因为火车上有小偷，就不坐火车了。但贵重的东西，比如大额现金最好就别随身带了，放家里由家人看着最保险，也就是在使用公有云的同时还使用私有云。而且希望公有云与私有云能很好的协同。这就是混合云了。 云计算当前的商业模式 云基础设施即服务（IaaS）— 出租处理能力、存储空间、网络容量等基本计算资源。 云平台即服务（PaaS）— 为客户开发的应用程序提供可部署的云环境。 云软件即服务（SaaS）— 在网络上提供可直接使的应用程序。 现在不止这几种，还有存储即服务，桌面即服务，数据中心即服务等等。 在服务模式上，云计算分为三种，包括：IaaS 基础设施即服务、PaaS 开发平台即服务、SaaS 软件即服务这三种模式。 IaaS，就是以前买IBM、HP、DELL、华为服务器存储跑企业业务（比如：生产管理业务、财务、市场客户管理、邮箱等），现在企业把业务放到Amazon的网站或华为企业云服务（公有云）网站就全搞定了。简单讲就是由“买”变“租”。大型企业的IT部门也可以以IaaS服务的形式，对内部业务部门提供服务，然后进行内部结算。 PaaS，就是以前企业需要业务软件的时候，软件开发商在自己公司开发完在卖给企业客户，还要派人去安装软件。现在开发、安装都在企业客户那里全做了。当然给的钱也不再是软件费而是人头费了。 SaaS，就是以前写汇报胶片用微软PPT软件，现在登录www.prezi.com，在那个网站上就可以写胶片了，很酷。 云计算的8个通用特点 大规模（Massive scale） 同质化（Homogeneity） 虚拟化（Virtualization） 弹性计算（Resilient computing） 低成本软件（Low cost software） 地理分布（Geographic distribution） 服务定位（Service orientation） 先进安全技术（Advanced security technologies） 这是美国国家标准与技术研究院给云计算列出的8个通用特点： 大规模（Massive scale），因为云计算服务把IT的资源供应集中化了，自然规模很大。也正因为如此，量变导致质变，使得云计算与传统IT有了众多的区别。 同质化（Homogeneity），也可以理解成标准化，这点倒是和用电很类似，大家要保持相同电压、插座接口，这样人们的电器和各种设备才能被广泛使用。 虚拟化（Virtualization），有两层含义，一个是计算单元的精细化，一块蛋糕太大，一个人吃不了，那最好切成小块，大家分着吃，也就是让每个计算单元更小，这样可以充分利用IT资源；另外一层含义是软硬件的分离，虚拟化之前软件和指定硬件是绑在一起的，虚拟化之后软件在所有硬件上可以自由的迁移，这跟人们由买房变成租房是一样的，既然北上广深的房价太高，很多人便租房住了，拎个箱子想住哪就住哪。 弹性计算（Resilient computing），在前面已经说过，指的是IT资源供给可弹性伸缩。 低成本软件（Low cost software），是从竞争与市场需求发展的角度说的。云计算降低了人们使用IT的门槛，不仅仅在个人技术能力上，而且在资金能力上，很多小微的初创企业，本身就没啥钱，希望能够用最少的钱使用最多的IT服务，要想打开这部分市场，自然需要低成本的软件，通过薄利多销的形式赚到更多的钱。 地理分布（Geographic distribution）：前文我们提到了泛在接入，也就是能够在任意时间任意地点提供IT服务。从使用者的角度看，就是地理分散的，由于各地网络带宽的优劣差异，那么IT提供者，也就是云计算数据中心的部署，自然也是呈现出地理分布式特征的。大的公有云厂商都有几十个甚至数百个数据中心或服务节点，面向全球提供云计算服务。 服务定位（Service orientation）：因为云计算是一种服务模式，它的整个体系的设计也就是面向服务的。 先进安全技术（Advanced security technologies），林子大了，什么鸟都有，公有云大了，什么用户也都有，包括好的坏的，自然先进的安全技术保障是一个云计算必须的条件了。 到此为止，对云计算的总结就是：4部署-3服务-5特性-8个通用点，简称4358。 云计算的流派 从实现方式来看，云计算有两个典型的流派：大分小模式和小聚大模式。（现在这个概念已经很少有人提了，因为从资源的使用看，两种流派的本质是相同的） 大分小模式：也称为Amazon流派，不同的应用在使用资源时，通过时分复用算法来调用。 关键技术点包括：计算、存储和网络虚拟化以及虚拟机监控、调度和迁移。 典型代表：Amazon，alibaba，华为的EC2等。 小聚大模式：也称为Google流派，资源在多个应用间贡献，通过将应用划分多个子任务，结合调度算法来实现某个子引用在资源上的独占。 关键技术点包括任务分解、调度、分布式通信总线和全局一致性。 典型代表：Google，我国的天河2号等]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>基础概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-09-03-什么是云计算?]]></title>
    <url>%2F2018%2F09%2F03%2F2018-09-03-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%91%E8%AE%A1%E7%AE%97%2F</url>
    <content type="text"><![CDATA[云计算概念的定义 云计算基础知识入门 云计算是一种按使用量付费的模式，这种模式提供可用的、便捷的、按需的网络服务（即随时随地接入可接入），进入可配置的计算资源共享池（包括：网络、服务器、存储、应用软件、服务），这些资源能够被快速提供，只需投入很少的管理工作，或与服务供应商进行很少的交互。（美国国家标准与技术研究院） 云计算是一种基于互联网的计算方式，通过这种方式，共享软硬件资源和信息可以按需求提供给计算机和其他设备。云计算依赖资源的共享以达成规模经济，类似基础设施。（维基百科） 云计算概念诞生之初，市场上对其概念有很多种理解，经过一段时间的争论，现在大家一般来说都认可的就是美国标准与技术研究院的它给出的一个最标准的定义。它把云计算定义为一种模式，而不是一种技术。这种模式既可以是商业模式，也可以是服务模式。 云计算的关键特征 按需自助服务（On-demand Self-service） 无处不在的网络接入（Broad Network Access） 与位置无关的资源池（Locations independent resources pooling） 快速弹性（Rapid Elastic） 按使用付费（Pay per User） 我们从云计算的基本特质上进一步理解一下云计算的概念和内涵。 从管理层面上说，云计算实现了IT资源的按需自助服务。“按需”是从量的角度来说，这是一种“量体裁衣”的资源使用方式，避免粗放管理带来成本损耗。“自助”是从人的角度来说，减少了资源使用者与资源管理者之间的频繁交互，进一步减少人工成本的损耗。同时，从历史上看，IT的使用难度每降低一个层次，IT产业就会获得一次质飞跃，因为客户数量会因此有指数级的提升。而“自助”这种简单化操作意味着更多的人都可以使用IT产品和服务。 云计算实现了广泛网络接入。这意味着用户可以在全球各地7x24小时的使用IT服务，也就是随时、随地、随心、随意的使用。这极大的提升了用户工作的灵活性和经营工作效率。 云计算实现了资源池化。“池化”就意味着资源的同质化、归一化。无论是网络、服务器、存储、应用还是服务，都是这些同质化、归一化资源的组合、协同实现。使用者和管理者只需考虑需求的资源“量”，无需考虑资源提供商之间的差异性。 云计算资源弹性伸缩。是指资源能够快速的供应和释放，就是说当你要的时候，我能快速的很快就给你，不是说你申请了以后，十天半个月我才给你资源，而是你要我马上就给你，当你不用的时候，我马上就回收，资源释放。 从经营层面上说，云计算实现了可计量的服务。“技术免费、服务收费”是开源社区的一个宗旨。前面也提到云计算的本质就是一种服务，为了实现这类服务收费，就必须要求服务可计量，而计量的依据就是资源使用的可计量。比如：按使用小时为时间单位，以服务器CPU个数、占用存储的空间、网络的带宽等综合计费，当然也可以包时、包天、包月那种套餐模式进行计量。而且，计量的越精细，运营效率越高。 以上，就是美国标准与技术研究院给云计算标准的定义时所诠释的特质。 从技术视角来看：云计算=计算/存储的网络 商业视角：云计算=信息电厂计算和存储：由PC时代的局域网向云时代的互联网迁移。软件：由PC时代的终端向云端迁移。 用户消费模式变化 通过互联网提供软硬件与服务； 用户通过浏览器或轻量级终端获取、使用服务。 商业模式发生变化 从“购买软硬件产品”向“购买信息服务”转变，如同100年前用电的转变。 云计算产生的背景 云计算=需求推动+技术进步+商业模式转变 云计算的产生是需求推动、技术进步、商业模式转变共同促进的结果。 需求推动： 政企客户低成本且高性能的信息化需求。 个人用户的互联网、移动互联网应用需求强烈，追求更好用户体验。 技术进步 虚拟化技术、分布与并行计算、互联网技术的发展与成熟，使得基于互联网提供包括IT基础设施、开发平台、软件应用成为可能。 宽带技术及用户发展，使得基于互联网的服务使用模式逐渐成为主流。 商业模式转变 少数云计算的先行者（例如Amazon的IaaS、PaaS)的云计算服务已开始运营。 市场对云计算商业模式已认可，越来越多的用户接受并使用云计算服务。 生态系统正在形成，产业链开始发展和整合。 几年之内，云计算已从新兴技术发展成为当今的热点技术。从Google公开发布的核心文件到Amazon EC2（亚马逊弹性计算云）的商业化应用，再到美国电信巨头AT&amp;T（美国电话电报公司）推出的Synaptic Hosting（动态托管）服务，云计算从节约成本的工具到盈利的推动器，从ISP（网络服务提供商）到电信企业，已然成功地从内置的IT系统演变成公共的服务。]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>基本概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-08-31-为什么开始写博客？]]></title>
    <url>%2F2018%2F08%2F31%2F2018-08-31-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%80%E5%A7%8B%E5%86%99%E5%8D%9A%E5%AE%A2%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[前言2018年3月—7月期间，有幸在外培训，时间相对宽松。当时，主要一直在自学SDN部分知识，鉴于同班同学一直询问询问云计算怎么学习？为此，我特意开通微信公众号，主要讲述一点儿OpenStack的基础知识。（如下） 当时，还特意列出一个大纲，从最基础的Linux开始，一直到后续高级服务和应用。比如：Tacker、Workflow、批量热迁移等。 但是，微信公众号的排版实在是太浪费时间，再加上后续回到工作岗位，个人时间实在有限，因此公众号的内容一直处在长期停更，偶尔写写的状态。实在有愧大家的期待-_-!!! 在2018年7月期间，一个偶然的机会让我接触到hexo和markdown两个小伙伴，让我燃起了写技术博客的动力。hexo主要用来生成静态页面，而markdown是一种极简的文本编写工具，其语法格式只有十来种，对编写网页博客有很大助力：-）利用这两个工具，可以提升网文的写作效率。至于怎么使用，网上的教程很多，大家可以自信搜索。 言归正传，后续公众号中已完成的内容我会逐渐搬到个人博客中来，并对前期挖的坑做个填补-_-!!!。新增的内容主要在个人博客中完成，微信公众号只能有空闲时间后，再进行补充，还请大家以后多关注博客内容。 另外，大家有什么疑惑，以后都可以在博客的留言区进行留言。]]></content>
      <categories>
        <category>随笔杂感</category>
      </categories>
      <tags>
        <tag>篇首语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-08-31-写在前面的话]]></title>
    <url>%2F2018%2F08%2F31%2F2018-08-31-%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2%E7%9A%84%E8%AF%9D%2F</url>
    <content type="text"><![CDATA[学习大纲 鉴于好多人询问云计算怎么学习？我的建议是实践和理论相结合！IT不像CT那么多理论和流程，IT诞生和发展的源动力就是提升工作效率。因此，IT的理论并没有CT那么难，但是要想用好，用巧必须具备相当丰富的实操经验。对于新手，最好的学习方式就是边实践边消化相关理论流程。 OpenStack是目前最成熟并且符合生产部署的一套开源云操作系统，全球各大IT，CT厂商，甚至运营商都为此投入了大量的人力、物力和精力。由于其开源的特性，全世界的云计算爱好者也为此贡献了很多。从openstack的特点来看，它是由python语音开发，是一个提供多种服务，相当灵活和稳定的云操作系统。以前的定义主要集中IaaS层（基础设施层），但是现在随着docker的出现，IaaS和PaaS（平台层）的界限已经非常模糊，同时随着K8s的兴起，甚至与SaaS的界限也不再清晰。从操作系统的组成来看，openstack+docker+k8s的组合更像一个更广泛的云化操作系统，openstack是内核，dokcer是用户空间，K8s是调用各项基础进程的API。 转入正题，由于openstack非常灵活，同时也就引入另一个问题，学习起来非常困难。因此，在学习openstack的同时，如果自己手头有一套实验环境那是相当的完美。我当初学习openstack是从devstack开始学起（openstack开发者版本），同时我也建议初学者从devstack开始学起。接下来我们就开始学习OpenStack的第一步，基础准备工作。 工具准备 学习云计算的硬件和软件条件 1、一台不少于16G内存，2CPU+内核笔记本或二手服务器，且硬件要开启支持虚拟化功能。BIOS中的开启方法如下图所示： 2、下载CentOS 7的光盘安装镜像。下载地址在CentOS官网链接，下载DVD版本即可。https://www.centos.org/download/ 3、去VMWare官网下载VMWare虚拟机软件，需要新注册个账号。下载链接如下：（注意：如果你你的宿主机是win10系统，不要下载VirtualBox，因为win10的无线网络在VirtualBox中设置桥接网络有BUG）https://www.vmware.com/cn/support/workstation.html 以上工具就是我们环境搭建需要的基本工具。还有一些辅助工具如：XShell、XFTP可自行百度下载（个人版在官网申请是免费，记得千万不要升级） 下载地址如下： http://www.netsarang.com/products/xsh_overview.html]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>OpenStack</tag>
        <tag>基础准备</tag>
      </tags>
  </entry>
</search>
