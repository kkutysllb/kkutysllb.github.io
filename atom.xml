<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一花一菩提，一云一世界</title>
  
  <subtitle>佛系ICT人士技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kkutysllb.cn/"/>
  <updated>2019-04-21T08:25:44.960Z</updated>
  <id>https://kkutysllb.cn/</id>
  
  <author>
    <name>kkutysllb</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2019-04-21-x86架构基础</title>
    <link href="https://kkutysllb.cn/2019/04/21/2019-04-21-x86%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80/"/>
    <id>https://kkutysllb.cn/2019/04/21/2019-04-21-x86架构基础/</id>
    <published>2019-04-21T08:10:21.000Z</published>
    <updated>2019-04-21T08:25:44.960Z</updated>
    
    <content type="html"><![CDATA[<p>标准服务器技术是网络功能虚拟化（NFV）实现的一个关键因素，了解一些x86架构的基础知识对大家后续了解电信云关键技术，尤其是掌握虚拟化技术原理和关键优化方案是必须具备的。本文主要从x86架构的CPU指令集增强，内存管理、中断和异常、IO架构等部分进行阐述，以及包含一些基础IT的基本概念的讲解。<a id="more"></a></p><h2 id="x86-64指令集的增强"><a href="#x86-64指令集的增强" class="headerlink" title="x86-64指令集的增强"></a>x86-64指令集的增强</h2><p>Intel 的x86体系结构是世界上最流行的处理器架构，从1978年8086/8088处理器问世到现在的Core i7和Core i9，以及Xeon系列处理器，Intel x86体系结构已经在CPU领域叱咤40多年。</p><p>x86-64是x86架构的延伸产品，是一种64位微处理器架构及其相应的指令集。在x86-64出现以前，Intel与惠普联合推出IA-64架构，此架构不与x86兼容，且市场反应冷淡。于是，与x86兼容的x86-64架构应运而生。1999年，AMD 首次公开64位指令集为IA-32 提供扩展，称为x86-64（后来改名为AMD64）。此架构后来也为Intel 所采用，也就是现在的Intel 64。</p><p>x86-64能有效地把x86架构移植到64位环境，并且兼容原有的x86应用程序，市场前景广阔。外界使用x84-64或者x64称呼这个64位架构，以保持中立，不偏袒任何一家厂商。</p><blockquote><p>AMD 64指令集主要特点有：<strong>支持64 位通用寄存器、64 位整数及逻辑运算</strong>和<strong>64 位虚拟地址</strong>。</p><p>Intel 64架构加入了额外的寄存器和其他改良的指令集，可使<strong>处理器直接访问超过4GB的内存</strong>，允许运行更大的应用程序。通过64位的存储器地址上限，其理论存储器容量上限达16EB，目前大多数操作系统和应用程序已基本支持完整的64位地址。</p></blockquote><h2 id="x86的内存架构"><a href="#x86的内存架构" class="headerlink" title="x86的内存架构"></a>x86的内存架构</h2><p>硬件架构中最复杂、最核心的部分就是其内存架构。此部分详细内容因为篇幅有限无法详细展开，面向的人员主要包括CPU架构设计、操作系统开发和内核底层优化等领域，至于运维方面后期如果不做内核优化的同事了解即可，如感兴趣可参考《手把手教你设计CPU-RISC-V处理器》、《嵌入式操作系统原理》和《处理器虚拟化技术》等书籍。</p><h3 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h3><p>地址空间是所有可用资源的集合，我们姑且将它看做一个大大的数组，那么地址就是这个数组的索引。地址空间可以划分为物理地址空间和线性地址空间两大类。</p><p><strong>（1）物理地址空间</strong></p><p>硬件平台通常划分为CPU、内存和其他硬件设备三个部分。其中，CPU 是整个硬件平台的主导者，内存和其他硬件设备都是CPU 可以使用的资源。这些资源组合在一起，分布在CPU的物理地址空间内，CPU使用物理地址索引这些资源。<strong>物理地址空间的大小由CPU实现的物理地址位数所决定</strong>，物理地址位数由CPU经过MMU（Memory Management Unit，内存管理单元）转换后的外地址总线位数决定。<strong>外地址总线位数与CPU处理数据的能力（即CPU 位数）没有必然的联系</strong>，例如：16位的8086 CPU具有20位地址空间。</p><p>一个硬件平台只有一个物理地址空间，但每个程序都认为自己独享整个平台的硬件资源。为了让多个程序能够有效地相互隔离，也为了它们能够有效地使用物理地址空间的资源，引入了线性地址空间的概念。</p><p><strong>（2）线性地址空间</strong></p><p><strong>线性地址空间的大小由CPU实现的线性地址位数决定</strong>，线性地址位数由CPU的内地址总线位数决定。由于CPU的内地址总线与CPU的执行单元直连，所以，内地址总线位数往往与CPU位数一致，如果是32 位处理器，那么它就实现了32 位线性地址，其线性地址空间为4GB，如果是64位处理器，那么它的线性地址空间的为2的64次方，即16384GB。需要注意的是，<strong>线性地址空间的大小与物理地址空间的大小没有必然联系</strong>，Intel的PAE平台具有4GB 的线性地址空间，而其物理地址空间为64GB。但是，线性地址空间会被映射到某一部分物理地址空间或整个物理地址空间。也就是说，线性地址空间小于等于物理地址空间。</p><p>CPU负责将线性地址空间转换成物理地址空间，保证程序能够正确访问到该线性地址空间所映射到的物理地址空间。在现代操作系统中，每个进程通常都拥有自己的私有线性地址空间。一个典型的线性地址空间构造如下图所示。</p><p><img src="https://i.loli.net/2019/04/21/5cbc261553723.jpg"></p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p>地址是访问地址空间的索引。根据访问地址空间的不同，索引可以分为<strong>物理地址</strong>和<strong>线性地址</strong>。但由于x86特殊的段机制，还存在一种额外的地址—<strong>逻辑地址</strong>。</p><p><strong>（1）逻辑地址</strong></p><p>逻辑地址是程序直接使用的地址（x86无法禁用段机制，逻辑地址一直存在）。逻辑地址由一个16位的段选择符和一个32位的偏移量（32位平台）构成。下面以具体程序为例进行解释。比如：我们写下面一段c语言代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a = 100;   # 定义一个整型变量a</span><br><span class="line">int *p = &amp;a;   # 定义一个整型指针p，指向变量a在内存中的地址</span><br></pre></td></tr></table></figure><p>上述语句中的指针变量p存储的就是变量a的逻辑地址。实际上，p中存储的仅是逻辑地址的<strong>偏移部分</strong>，而偏移对应的<strong>段选择符位于段寄存器中</strong>，并没有在程序中显示。</p><p><strong>（2）线性地址</strong></p><p>线性地址又称虚拟地址。线性地址是逻辑地址转换后的结果，用于索引线性地址空间。当CPU使用分页机制时，还需要将线性地址转换成物理地址才能访问物理平台内存或其他硬件设备；<strong>当分页机制未启用时，线性地址与物理地址相同</strong>。</p><p><strong>（3）物理地址</strong></p><p>物理地址是物理地址空间的索引，是CPU提交到总线用于访问物理平台内存或其他硬件设备的最终地址，在x86下，物理地址有时也被称为总线地址。</p><p>根据上面的描述，我们可以总结如下：</p><ul><li><strong>分段机制启用，分页机制未启用：逻辑地址—&gt;线性地址=物理地址</strong></li><li><strong>分段机制、分页机制同时启用：逻辑地址—&gt;线性地址—&gt;物理地址</strong></li></ul><h3 id="x86内存管理机制"><a href="#x86内存管理机制" class="headerlink" title="x86内存管理机制"></a>x86内存管理机制</h3><p>x86架构的内存管理机制分为两部分：分段机制和分页机制。分段机制为程序提供彼此隔离的代码区域、数据区域、栈区域，从而避免了同一个处理器上运行的多个程序互相影响。</p><p>分页机制实现了传统的按需分页、虚拟内存机制，可以将程序的执行环境按需映射到物理内存。此外，分页机制还可以用于提供多任务的隔离。</p><p>分段机制和分页机制都可以通过配置，支持简单的单任务系统、多任务系统或共享内存的多处理器系统。<strong>需要强调的一点是，处理器无论在何种运行模式下都不可以禁止分段机制，但是分页机制却是可选选项。</strong></p><p><strong>（1）分段机制</strong></p><p>分段机制是x86架构下的朴素内存管理机制，不可以禁用。了解分段机制有利于对后续内存虚拟化原理和优化方案有更深的了解。</p><p>分段机制将内存划分成以基地址（Base）和长度（Limit）描述的块。段可以与程序最基本的元素联系起来，程序可以简单地划分为代码、数据和栈，段机制就有相应的代码段、数据段和栈段。</p><p>一个程序根据分段机制在内存中由<strong>逻辑地址</strong>、<strong>段选择符</strong>、<strong>段描述符</strong>和<strong>段描述符表</strong>4 个基本部分构成。</p><blockquote><p>1）当程序使用逻辑地址访问内存的某个部分时，CPU通过逻辑地址中的段选择符索引段描述符表，进而得到该内存对应的段描述符（段描述符描述段的基地址、长度以及读/写、访问权限等属性信息）</p><p>2）根据段描述符中的段属性信息检测程序的访问是否合法，如果合法，再根据段描述符中的基地址将逻辑地址转换为线性地址。</p></blockquote><p>这个流程可以用如下图示进行总结。</p><p><img src="https://i.loli.net/2019/04/21/5cbc267c60250.jpg"></p><p>段选择符是逻辑地址的一个组成部分，用于索引段描述符表以获得该段对应的段描述符。段选择符作为逻辑地址的一部分，对应用程序是可见的。但是，正如前面在逻辑地址中介绍的，应用程序中只存储和使用逻辑地址的偏移部分，段选择符的修改和分配由连接器和加载器完成。</p><p>为了使CPU能够快速地获得段选择符，x86架构提供了6个段寄存器存放当前程序中各个段的<strong>段选择符</strong>。这6 个段寄存器分别如下：</p><ul><li>CS（Code-Segment，代码段）：存放代码段的段选择符。</li><li>DS（Data-Segment，数据段）：存放数据段的段选择符。</li><li>SS（Stack-Segment，栈段）：存放栈的段选择符。</li><li>ES、FS、GS：可以存放额外三个数据段的段选择符，由程序自由使用。</li></ul><p>由于段选择符的存在最终是为了索引段描述符表中的段描述符，为了加速段描述符的访问，x86架构在不同的段寄存器后增加了一个程序不可见的<strong>段描述符寄存器</strong>。当相应段寄存器中加入一个新的段选择符后，CPU自动将该段选择符索引的段描述符加载到这个不可见的段描述符寄存器中。各个段寄存器的构造如下。</p><p><img src="https://i.loli.net/2019/04/21/5cbc26ab49407.jpg"></p><p>段描述符描述某个段的<strong>基地址</strong>、<strong>长度</strong>以及<strong>各种属性</strong>（例如，读/写属性、访问权限等）。这是分段机制的核心思想。当CPU通过一个逻辑地址的段选择符获得该段对应的段描述符后，会使用段描述符中各种属性字段对访问进行检查，一旦确认访问合法，CPU将段描述符中的基地址和程序中逻辑地址的偏移量相加就得到程序的线性地址。</p><p>正如前面讲到的，x86架构在每个段寄存器后增加了一个程序不可见的段描述符寄存器，每当段寄存器加入一个新的段选择符后，CPU自动将该段选择符索引的段描述符加载到这个段描述符寄存器中。后续只要不发生段寄存器的更新操作，CPU就不再查询段描述符表而是直接使用这个段描述符寄存器中的值，从而加快CPU的执行效率。</p><p>x86架构提供了两种段描述符表：<strong>GDT（全局段描述符表Global Descriptor Table）</strong>和<strong>LDT（本地段描述符表Local Descriptor Table）</strong>。具体选择哪个段描述符表，由段选择符中的TI字段决定，当TI=0时，索引GDT，当TI=1时索引LDT。系统中至少有一个GDT可以被所有的进程访问。与此同时，系统中可以有一个或多个LDT，可以被某个进程私有，也可以被多个进程共享。</p><blockquote><p><strong>GDT是内存中的一个数据结构</strong>。简单地讲，可以将GDT看成是一个数组，由基地址（Base）和长度（Limit）描述。</p><p><strong>LDT是一个段</strong>，需要用一个段描述符来描述。LDT的段描述符存放在GDT中，当系统中有多个LDT时，GDT中必须有对应数量的段描述符。</p></blockquote><p>为了加速对GDT和LDT的访问，x86架构提供了GDTR寄存器和LDTR寄存器。关于这两种寄存器的具体描述如下：</p><blockquote><p><strong>GDTR：</strong>包括一个32位的基地址（Base）和一个16 位的长度（Limit）。</p><p><strong>LDTR：</strong>结构与段寄存器相同（同样包含对程序不可见的段描述符寄存器）。</p></blockquote><p>通过段选择符索引GDT/LDT的过程如下图所示：</p><p><img src="https://i.loli.net/2019/04/21/5cbc26ed91ea5.jpg"></p><p><strong>x86架构内存管理中分段机制总结：</strong></p><p>1）在程序加载阶段，该进程LDT的段选择符首先索引GDT，获得LDT的段描述符并将其加载到LDTR寄存器中。此外，该进程的CS、DS、SS中加入相应的段选择符，CPU根据段选择符的TI字段索引相应的段描述符表，获得相应的段描述符，并加载入CS、DS、SS对应的程序不可见的段描述符寄存器。</p><p>2）程序执行到读/写内存中的数据时，把程序中相应变量的逻辑地址转换为线性地址：</p><ul><li>进行必要的属性、访问权限检查；</li><li>从DS对应的段描述符寄存器获得该段的基地址；</li><li>将变量的32位偏移量和段描述符中的基地址相加，获得该变量的线性地址。</li></ul><p><strong>2）分页机制</strong></p><p>分段机制的目的是将内存中的线性地址空间划分成以基地址和长度描述的多个段进行管理，程序对应的逻辑地址以基地址和偏移量来描述，实现逻辑地址到线性地址空间的映射。而分页机制是使用单位“页”来管理线性地址空间和物理地址空间的映射关系。同时，分页机制允许一个页面存放在物理内存中或磁盘的交换区域（如Linux下的Swap分区，Windows下的虚拟内存文件）中，程序可以使用比</p><p>机器物理内存更大的内存区域，从而实现现代操作系统中虚拟内存机制。<strong>（注意：操作系统的虚拟内存原理和映射关系和后面要讲的计算虚拟化技术中内存虚拟化技术基本一致，只是VMM实现时又多了一层嵌套）。</strong></p><p>在x86架构下，页的典型大小为4KB，于是一个4GB的线性地址空间被划分成1024×1024个页面，参见本文线性地址空间示意图。物理地址空间的划分与此类似。x86架构允许大于4KB的页面大小（如2MB、4MB、1GB）等。</p><p>分页机制的核心思想是通过页表将线性地址转换为物理地址，并配合旁路转换缓冲区（Translation Lookaside Buffer，后面简称为TLB）来加速地址转换的过程。分页机制主要由<strong>页表</strong>、<strong>CR3 寄存器</strong>和<strong>TLB</strong>三个部件构成，如下图所示。</p><p><img src="https://i.loli.net/2019/04/21/5cbc271d94801.jpg"></p><p>页表是用于将线性地址转换成物理地址的主要数据结构。一个地址对齐到页边界后的值称为页帧号（或者页框架），它实际上就是该地址所在页面的基地址。比如：一个页大小为4kB，那么第一个页帧号就是0，第二个页帧号就是4097，依次类推。线性地址对应的页帧号叫做虚拟页帧号（Virtual Frame Number，下面简称为VFN），物理地址对应的页帧号叫做物理页帧号（Physical Frame Number，下面简称为PFN）或机器页帧号。<strong>页表实际上是存储VFN到PFN映射的数据结构。</strong></p><p>在传统的32位的保护模式中（未启用物理地址扩展PAE功能），x86处理器使用两级转换方案，在这种方案中，CR3寄存器指向一个4KB大小的页目录表，页目录中共有1024个记录，每一项记录大小4B空间，都指向一个4KB大小的页表，页表中也有1024项，每项大小4B空间，所以，最后整个线性地址空间大小就是1024 个长为4KB的页，即总共4GB大小的空间。未启用PAE 的4KB大小的页面如下图所示。</p><p><img src="https://i.loli.net/2019/04/21/5cbc2739116af.jpg"></p><p><strong>页目录项（Page Directory Entry，下面简称为PDE）</strong>，包含页表的物理地地址，PDE存放在页目录表中。</p><p><strong>页表项（Page Table Entry，下面简称为PTE）</strong>：包含该线性地址对应的物理页帧号PFN，PTE存在页表中，确定物理页帧号PFN 后，再将线性地址的0~11位偏移量与其相加，就可以确定该线性地址对应的物理地址。</p><blockquote><p><strong>虚拟内存实现的关键在于PDE和PTE都包含一个P（Present）字段：</strong></p><p><strong>当P=1时</strong>，物理页面存在于物理内存中，CPU完成地址转换后可以直接访问该页面。</p><p><strong>当P=0时</strong>，物理页面不在物理内存中（在硬盘的交换分区中），当CPU访问该页面时，会产生一个<strong>缺页错误中断</strong>，由操作系统的缺页处理机制将存放在硬盘上的页面调入物理内存，使访问可以继续。同时，由于程序的局部性特点，操作系统会将该页面附近的页面一起调入物理内存，方便CPU的访问。所以，为了减少内存占用，要求程序开发人员尽量少的使用全局索引或递归调用等机制。</p><p>P=0时的PDE和PTE的1~31位都将为操作系统提供物理页面在硬盘上的信息，这些位存储着物理页面在硬盘上的位置。</p></blockquote><p>启用物理地址扩展（之后简称为PAE）后，页表结构将发生相应的变化。页表和页目录的总大小仍是4KB，但页表和页目录中的表项都从32位扩为64位，以使用附加的地址位。这样，页表和页目录都只有512个表项，变成了原来方案的一半，所以又加入了一个级：<strong>CR3 指向页目录指针表</strong>，即一个包含4个页目录指针的表。启用PAE 的4KB大小的页面使用的三级页表如下图所示：</p><p><img src="https://i.loli.net/2019/04/21/5cbc277ea692a.jpg"></p><p>CR3寄存器也称为<strong>页目录基地址寄存器</strong>（Page-Directory Base Register，PDBR），存放着页目录的物理地址。一个进程在运行前，必须将其页目录的基地址存入CR3，而且，页目录的基地址必须对齐到4KB页边界。启用PAE时，CR3指向页目录指针表，每一项都指向一个页目录表，共有4个页目录表。</p><p>为了提高地址转换的效率，x86架构使用TLB对最近用到的页面映射进行缓存。TLB中存放着VFN到PFN的转换记录，当CPU访问某个线性地址时，如果其所在页面的映射存在于TLB中，无须查找页表，即可得到该线性地址对应的PFN，CPU 再将它与线性地址的偏移相加，就能得到最后的物理地址。</p><p><strong>x86架构内存管理中心分页机制总结：</strong></p><p>1）CPU访问一个线性地址，在TLB中进行匹配，如果地址转换在TLB中，则跳到步骤6。否则，发生了一次TLB Miss（TLB 缺失），继续步骤2。</p><p>2）查找页表，如果页面在物理内存中，则跳到步骤4。</p><p>3）如果页面不在物理内存中，则产生缺页错误，由操作系统的缺页错误处理程序进行以下处理。</p><ul><li>将页面从磁盘复制到物理内存中。</li><li>更改对应的PTE，设置P 位为1，并对其他字段进行相应的设置。</li><li>刷新TLB 中对应的PTE。</li><li>从缺页错误处理程序中返回。</li></ul><p>4）此时，页面已经存在于物理内存中，并且页表也已经包含了这个映射。重新在TLB中进行匹配，如果地址转换在TLB中，则跳到步骤6。否则，发生了一次TLB Miss（TLB 缺失），继续步骤5。</p><p>5）CPU重新查页表，把对应的映射插入到TLB中。</p><p>6）此时，TLB已经包含了该线性地址对应的PFN。将PFN和线性地址中的偏移量相加，就得到了对应的物理地址。</p><h2 id="中断与异常"><a href="#中断与异常" class="headerlink" title="中断与异常"></a>中断与异常</h2><p>程序的执行往往不只是按顺序执行那么简单，一些异常和中断会打断顺序执行的程序流，转而进入一条完全不同的执行路径。中断提供给外部设备一种“打断CPU当前执行任务，并响应自身服务”的手段。中断(interrupt)是异步的事件，典型的比如由I/O设备触发；异常(exception)是同步的事件，典型的比如处理器执行某条指令时发现出错了等等，其实异常的本质就是同步中断。</p><p>中断通常被定义为一个打断CPU芯片指令执行的事件，该事件对应到CPU芯片内部或者外部的电路产生的电子信号。</p><p>中断信号可以被划分为<strong>同步中断</strong>和<strong>异步中断</strong>：</p><p>同步中断，该类型中断由CPU的控制单元在执行指令的时候产生，并且是在当前指令执行完毕下一个指令执行之前产生。</p><p>异步中断，该类型中断由其他硬件设备在任意的时间产生，并且遵循CPU的时钟信号传递给CPU。</p><blockquote><p>对于Intel的CPU而言，它将同步中断称作异常，而将异步中断称作中断。</p></blockquote><p>通常中断（即异步中断）由时钟定时器或者其他I/O设备产生，如键盘接收到敲击某个按键的信号后产生的中断信号。而异常（即同步中断）则通常由于编程错误或者由CPU检测到异常条件需要内核进行处理而产生，如上面讲到的Page Fault Exception（缺页异常），异常可以由程序通过int或者sysenter指令主动产生。</p><p>对于Intel x86 CPU而言，它将中断和异常进行了如下归类：</p><p><strong>中断，即异步中断</strong>，中断信息随着CPU的时钟信号传递到CPU内部。中断分为<strong>可屏蔽中断</strong>和<strong>不可屏蔽中断</strong>两类。</p><ul><li><strong>可屏蔽中断</strong>，所有由I/O设备产生的IRQ请求都被归为可屏蔽中断。一个可屏蔽中断可以有两种状态，屏蔽或者不屏蔽，当一个中断被屏蔽时，该中断信号将被对应的控制单元所忽略。</li><li><strong>不可屏蔽中断</strong>，即控制单元无法忽略该类型的中断信号，CPU肯定会接收到该类型的中断，一般对应到一些紧要的事件，比如硬件错误。</li></ul><p><strong>异常，即同步中断</strong>，中断信号在CPU执行完某个指令后产生并接收到。处理器检测到的异常，即当CPU执行指令的时候检测到硬件上存在一些异常条件的时候就会产生该信号。这种类型的异常根据产生时在内核堆栈中保存的EIP寄存器的值（即异常恢复后CPU重新执行的位置）进行细分：</p><ul><li><strong>Faults，该异常可以被内核正确纠正，并且纠正后重新执行引起该异常的指令时不会造成程序的中断或者功能的异常。</strong>这时候保存到EIP寄存器的值是引起异常的指令的地址，故异常恢复的时候会重新执行该指令，如Page Fault Exception（缺页异常），当访问的内存地址没有被映射到物理内存时，产生异常，内核分配新的物理内存页并建立映射关系，然后异常处理完毕后，CPU重新访问该地址，即可访问到正确的物理内存。</li></ul><ul><li><strong>Traps，该异常发生时，内核堆栈EIP寄存器保存的地址指向引起该异常的指令的下一条指令，即当该异常处理返回后会继续程序的执行，而不是重新执行引起异常的指令。</strong>x86 CPU的硬件虚拟化功能就是利用陷入（Traps）再模拟的方法，当CPU执行虚拟机指令的时候，如果执行的是敏感指令，就会触发Traps类型的异常，让VMM（Virtual Machine Monitor）对该敏感指令进行模拟，然后继续恢复虚拟机的运行。</li></ul><ul><li><strong>Aborts，当发生严重的错误时，CPU已经无法保证内核堆栈中EIP寄存器存放的值是引起该异常的指令的地址。</strong>该异常用于汇报严重的错误，如硬件错误或者是内存的不一致性。该异常信号让CPU切换到相应的abort exception handler，该处理函数由于无法确认错误，只能结束当前进程。</li></ul><p>我们在写程序时，经常会在容易产生错误的地方进行异常抛出，然后针对抛出的异常定义执行策略。这类编程产生的异常，由程序主动执行int或者int3之类的指令产生。CPU像处理Traps一样处理这些程序主动产生的异常，该类异常通常被称为<strong>软件中断（software interrupt）</strong>。这类异常主要有两种用途：实现系统调用和通知某个debugger特定的事件发生。</p><p>这些异常或中断由0~255的数字唯一标识，也就是经常说的中断信号量。对于不可屏蔽中断和异常来说，相应的中断信号量是固定的，而可屏蔽中断对应的中断信号量则可以通过设置中断控制器来更改。</p><h2 id="x86系统的I-O架构"><a href="#x86系统的I-O架构" class="headerlink" title="x86系统的I/O架构"></a>x86系统的I/O架构</h2><p>计算机所处理的任务其实只有两种：CPU运算和I/O操作。这部分内容是后续学习计算虚拟化中I/O虚拟化的基础。I/O（输入/输出）是CPU访问外部设备的方法。设备通常通过寄存器和设备RAM将自身功能展现给CPU，CPU通过读/写这些寄存器和RAM完成对设备的访问及其他操作。按访问方式的不同，x86架构的I/O分为如下两类：</p><p><strong>1）端口I/O（后文简称为Port I/O）：</strong>即通过I/O端口访问设备寄存器。x86有65536个8位的I/O端口，编号为0x0~0xFFFF。CPU将端口号作为设备端口的地址，进而对设备进行访问。这65536个端口构成了64KB的I/O端口地址空间。I/O端口地址空间是独立的，不是线性地址空间或物理地址空间的一</p><p>部分。需要使用特定的操作命令IN/OUT对端口进行访问，此时CPU通过一个特殊的芯片管脚标识这是一次I/O端口访问，于是芯片组知道地址线上的地址是I/O端口号并相应地完成操作。此外，2个或4个连续的8位I/O端口可以组成16位或32位的I/O端口。</p><p><strong>2）内存映射I/O（Memory Map I/O，后文简称为MMIO）：</strong>即通过内存访问的形式访问设备寄存器或设备RAM。MMIO要占用CPU的物理地址空间，它将设备寄存器或设备RAM映射到物理地址空间的某段地址，然后使用MOV等访存指令访问此段地址，即可访问到映射的设备。MMIO方式访问设备也需</p><p>要进行线性地址到物理地址的转换，但是这个转换过程中的MMIO地址不可缓存到TLB中。MMIO是一种更普遍、更先进的I/O访问方式，很多CPU 架构都没有Port I/O，采用统一的MMIO方式。</p><h2 id="DMA技术"><a href="#DMA技术" class="headerlink" title="DMA技术"></a>DMA技术</h2><p>直接内存访问（Direct Memory Access，后文简称为DMA）是所有现代计算机的重要特色。DMA允许设备绕开CPU直接向内存中复制或读取数据。如果设备向内存复制数据都经过CPU，则CPU会有大量中断负载，中断过程中，CPU对其他任务来讲无法使用，不利于系统性能的提高。通过DMA，CPU只负责初始化这个传输动作，而传输动作本身由DMA 控制器（简称为DMAC）来实行和完成。在实现DMA传输时，由DMAC直接控制总线，在DMA传输前，CPU要把总线控制权交给DMAC，结束DMA传输后，DMAC立即把总线控制权交回给CPU。</p><p><strong>一个完整的DMA 传输过程的基本流程如下：</strong></p><p><strong>1）DMA请求：</strong>CPU对DMAC进行初始化，并向I/O端口发出操作命令，I/O端口提出DMA请求。</p><p><strong>2）DMA响应：</strong>DMAC对DMA请求进行优先级判别和屏蔽判别，然后向总线控制芯片提出总线请。CPU执行完当前总线周期后释放总线控制权。此时，总线控制芯片发出总线应答，表示DMA请求已被响应，并通过DMAC通知I/O端口开始DMA传输。</p><p><strong>3）DMA传输：</strong>DMAC获得总线控制权后，CPU即可挂起或只执行内部操作，由DMAC发出读/写命令，直接控制RAM与I/O端口进行DMA传输。</p><p><strong>4）DMA结束：</strong>当完成规定的成批数据传送后，DMAC释放总线控制权，并向I/O端口发出结束信号。当I/O端口接收到结束信号后，停止I/O设备的工作并向CPU提出中断请求，使CPU执行一段检查本次DMA传输操作正确性判断的代码，并从不介入的状态退出。</p><p>由此可见，DMA无须CPU直接控制传输，也没有中断处理方式那样保留现场和恢复现场的过程，通过硬件（DMAC）为RAM与I/O设备开辟了一条直接传送数据的通路，极大地提高了CPU效率。需要注意的是，DMA操作访问的必须是连续的物理内存。DMA 传输的过程如下图所示。</p><p><img src="https://i.loli.net/2019/04/21/5cbc280a44322.jpg"></p><h2 id="进程、线程和协程"><a href="#进程、线程和协程" class="headerlink" title="进程、线程和协程"></a>进程、线程和协程</h2><p><strong>什么是进程和线程</strong></p><p>进程是什么呢？大白话讲，进程就是应用程序的启动实例。比如我们运行一个游戏，打开一个软件，就是开启了一个进程。进程拥有代码和打开的文件资源、数据资源、独立的内存空间。</p><p>线程又是什么呢？线程从属于进程，是程序的实际执行者。一个进程至少包含一个主线程，也可以有更多的子线程。线程拥有自己的栈空间。</p><p><img src="https://i.loli.net/2019/04/21/5cbc282ce34ef.jpg"></p><p><strong>对操作系统来说，线程是最小的执行单元，进程是最小的资源管理单元</strong>。无论进程还是线程，都是由操作系统所管理的。线程一般具有五种状态：初始化&gt;&gt;&gt;可运行&gt;&gt;&gt;运行中&gt;&gt;&gt;阻塞&gt;&gt;&gt;销毁。线程不同状态之间的转化均需要CPU开销来完成。</p><p><strong>什么是协程协程</strong></p><p>携程英文Coroutines，是一种比线程更加轻量级的存在。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p><p><img src="https://i.loli.net/2019/04/21/5cbc28480061c.jpg"></p><p>在Python语言中有个生成器的概念，里面有个关键字yield，当程序执行到yield关键字时，会暂停在那一行，等到主线程调用send方法发送了数据，协程才会接到数据继续执行。但是，yield让程序暂停，和线程的阻塞是有本质区别的。通过yield关键字的暂停完全由程序控制，线程的阻塞状态是由操作系统内核来进行切换。大家可以在Python脚本中写入如下代码并执行体验下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consume</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="comment"># consume等待接收数据</span></span><br><span class="line">number = <span class="keyword">yield</span></span><br><span class="line">print(<span class="string">"我要执行啦。。。。开始计数："</span>,number)</span><br><span class="line">consumer = consume()</span><br><span class="line">next(consumer)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">100</span>):</span><br><span class="line">print(<span class="string">"开始执行："</span>,num)</span><br><span class="line">consumer.send(num)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;标准服务器技术是网络功能虚拟化（NFV）实现的一个关键因素，了解一些x86架构的基础知识对大家后续了解电信云关键技术，尤其是掌握虚拟化技术原理和关键优化方案是必须具备的。本文主要从x86架构的CPU指令集增强，内存管理、中断和异常、IO架构等部分进行阐述，以及包含一些基础IT的基本概念的讲解。
    
    </summary>
    
      <category term="NFV关键技术" scheme="https://kkutysllb.cn/categories/NFV%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="电信云" scheme="https://kkutysllb.cn/tags/%E7%94%B5%E4%BF%A1%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>2019-04-20-Linux系统命令-第三篇《文件过滤及内容编辑处理》</title>
    <link href="https://kkutysllb.cn/2019/04/20/2019-04-20-Linux%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4-%E7%AC%AC%E4%B8%89%E7%AF%87%E3%80%8A%E6%96%87%E4%BB%B6%E8%BF%87%E6%BB%A4%E5%8F%8A%E5%86%85%E5%AE%B9%E7%BC%96%E8%BE%91%E5%A4%84%E7%90%86%E3%80%8B/"/>
    <id>https://kkutysllb.cn/2019/04/20/2019-04-20-Linux系统命令-第三篇《文件过滤及内容编辑处理》/</id>
    <published>2019-04-20T11:00:36.000Z</published>
    <updated>2019-04-20T12:28:42.604Z</updated>
    
    <content type="html"><![CDATA[<h2 id="cat：合并文件或查看文件内容"><a href="#cat：合并文件或查看文件内容" class="headerlink" title="cat：合并文件或查看文件内容"></a>cat：合并文件或查看文件内容</h2><p>cat命令可以理解为英文单词concatenate的缩写，其功能是连接多个文件并且打印到屏幕输出，或者重定向到指定的文件中。此命令常用来显示单个文件内容，或者将几个文件内容连接起来一起显示，还可以从标准输入中读取内容并显示，生产环境中它常与重定向或追加符号配合使用。<a id="more"></a></p><p><strong>cat命令具备5大常用功能</strong></p><p><img src="https://i.loli.net/2019/04/20/5cbafc16222d5.jpg"></p><p><strong>语法格式：cat [option] [file]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/04/20/5cbafc44edbdf.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）在/home/kkutysllb目录下生成一个data001文件</strong></p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># EOF这里要按回车才能结束，另外，EOF必须成对出现，但也可以用别的成对标签来替换。</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; [root@C7-Server01 kkutysllb]<span class="comment"># cat &gt;&gt; data001 &lt;&lt; EOF</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; &gt; day001...</span><br><span class="line">&gt; &gt; day002...</span><br><span class="line">&gt; &gt; day003...</span><br><span class="line">&gt; &gt; day004...</span><br><span class="line">&gt; &gt; ...</span><br><span class="line">&gt; &gt; day00n...</span><br><span class="line">&gt; &gt; EOF</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 使用cat -n查看刚编辑生成的文件data001 </span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# cat -n data001       </span><br><span class="line"></span><br><span class="line">1day001...      </span><br><span class="line"></span><br><span class="line">2day002...      </span><br><span class="line"></span><br><span class="line">3day003...      </span><br><span class="line"></span><br><span class="line">4day004...      </span><br><span class="line"></span><br><span class="line">5...      </span><br><span class="line"></span><br><span class="line">6day00n...</span><br></pre></td></tr></table></figure><p><strong>2）直接执行cat命令，不带任何选项</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 查看当前目录下soft_link软链接文件的内容 </span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# cat soft_link  </span><br><span class="line"></span><br><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4 </span><br><span class="line"></span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br></pre></td></tr></table></figure><p><strong>3）执行cat命令，分别带-n及-b选项，并对比区别</strong></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; # 新生成data002文件，输入以下内容，注意其中的空行要保留</span><br><span class="line">&gt; </span><br><span class="line">&gt; [root@C7-Server01 kkutysllb]# cat &gt;&gt; data002 &lt;&lt; EOF</span><br><span class="line">&gt; </span><br><span class="line">&gt; &gt; www.sina.com.cn</span><br><span class="line">&gt; &gt;</span><br><span class="line">&gt; &gt; www.baidu.com</span><br><span class="line">&gt; &gt;</span><br><span class="line">&gt; &gt; www.chinamobile.com</span><br><span class="line">&gt; &gt;</span><br><span class="line">&gt; &gt; sn.chinamobile.com</span><br><span class="line">&gt; &gt;</span><br><span class="line">&gt; &gt; EOF</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; # 使用-n选项查看data002文件的内容</span><br><span class="line">&gt; </span><br><span class="line">&gt; # 文件内容中的空行也被标识行号</span><br><span class="line">&gt; </span><br><span class="line">&gt; [root@C7-Server01 kkutysllb]# cat -n data002</span><br><span class="line">&gt; 1www.sina.com.cn</span><br><span class="line">&gt; 2</span><br><span class="line">&gt; 3www.baidu.com</span><br><span class="line">&gt; 4</span><br><span class="line">&gt; 5www.chinamobile.com</span><br><span class="line">&gt; 6</span><br><span class="line">&gt; 7sn.chinamobile.com</span><br><span class="line">&gt; 8</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; # 使用-b选项查看data002文件的内容，会忽略显示空白行行号</span><br><span class="line">&gt;</span><br><span class="line">&gt; [root@C7-Server01 kkutysllb]# cat -b data002</span><br><span class="line">&gt; 1www.sina.com.cn</span><br><span class="line">&gt; 2www.baidu.com</span><br><span class="line">&gt; 3www.chinamobile.com</span><br><span class="line">&gt; 4sn.chinamobile.com</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>3）执行cat命令，带-E选项</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># -E选项会在显示文件的每行行尾加上$符号 </span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# cat -E data001 </span><br><span class="line"></span><br><span class="line">day001...$ </span><br><span class="line"></span><br><span class="line">day002...$ </span><br><span class="line"></span><br><span class="line">day003...$ </span><br><span class="line"></span><br><span class="line">day004...$ </span><br><span class="line"></span><br><span class="line">...$ </span><br><span class="line"></span><br><span class="line">day00n...$</span><br></pre></td></tr></table></figure><p><strong>4）cat的一个特殊小用法（没基础的可以先大致了解，后续学了shell脚本后再看这部分）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 利用cat在shell脚本中显示帮助菜单 </span><br><span class="line"></span><br><span class="line">#!/bin/bash </span><br><span class="line"></span><br><span class="line">exportfs_usage() </span><br><span class="line"></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">cat &lt;&lt; END</span><br><span class="line"></span><br><span class="line">USAGE:  $0 &#123;start|stop|monitor|status|validate-all&#125;</span><br><span class="line"></span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exportfs_usage</span><br></pre></td></tr></table></figure><p><strong>执行上述脚本的输出如下：</strong></p><p><img src="https://i.loli.net/2019/04/20/5cbafdfe746ff.jpg"></p><p>为了实现自动化运维，有时运维人员不得不通过脚本把操作写好，然后让其他同事，通过傻瓜式的菜单选择，来完成相应的工作，进而提升工作效率。因此，cat命令在shell编程中常用来描写菜单输出操作。</p><p><strong>小练习：其他选项用法请自行练习，将结果贴在讨论区。提示：与cat命令作用相反的命令为tac，其作用是方向显示文件的内容，请自行研究练习。</strong></p><p><strong>补充知识：LInux系统中的重定向</strong></p><blockquote><p><strong>重定向简介</strong></p><p>重定向是Linux中一个重要知识点，对于它的作用，直白点儿说，就是可以让数据从一个地方（文件或工具）无损地流到另一个地方。</p><p><strong>标准输入/输出/错误输出</strong></p><p>标准输入是一个名称，它表示数据的一个流入方向，通常表示数据从文件等流入到处理的工具或命令中，用代码0表示，使用&lt;或&lt;&lt;符号来指示数据朝箭头所指的方向流动。</p><p>标准输出也是一个名称，也表示数据的一个流入方向，通常用代码1表示，使用&gt;或&gt;&gt;符号来指示数据朝箭头的方向流动。和标准输入不同的是，1表示将命令等处理的一般信息输出到文件。</p><p>标准错误输出是另一个名称，也是表示数据的一个流入方向，通常用代码2表示，使用&gt;或&gt;&gt;符号来指示数据朝箭头的方向流动。和标准输出不同的是，标准错误输出2表示将错误的信息输出到文件等，不输出正确的普通信息（仅输出错误信息）。</p></blockquote><h2 id="more：分页显示文件内容"><a href="#more：分页显示文件内容" class="headerlink" title="more：分页显示文件内容"></a>more：分页显示文件内容</h2><p>more命令的功能类似于cat，但cat命令是将整个文件的内容一次性显示在屏幕上，而more则会一页一页地显示文件内容。但more的功能还是比较简单的，有一个增强版的命令是less，将在后面讲解。（其实，学会了less命令，大家就可以把more命令忘记了）</p><p><strong>语法格式：more [option] [file]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/04/20/5cbb018212065.jpg"></p><p>在交互模式下，使用more命令打开文本之后，会进入一个基于vi的交互界面，在这里可以使用部分vi编辑器的功能，如搜索功能，还可以切换到vi编辑器。常用操作方式如下：</p><p><img src="https://i.loli.net/2019/04/20/5cbb01a03a20b.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）more命令后面不接任何参数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 显示/etc/services文件内容 </span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# more /etc/services</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/20/5cbb01c87fcd5.jpg"></p><p><strong>2）显示指定行数的内容</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 显示/etc/service文件的前5行内容</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# more -5 /etc/services </span><br><span class="line"></span><br><span class="line"># /etc/services:</span><br><span class="line"></span><br><span class="line"># $Id: services,v 1.55 2013/04/14 ovasik Exp $</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># Network services, Internet style</span><br><span class="line"></span><br><span class="line"># IANA services version: last updated 2013-04-10</span><br></pre></td></tr></table></figure><p><strong>3）从指定的行数开始显示内容</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># 从465行开始显示/etc/service文件的内容</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# more -5 /etc/services </span><br><span class="line"></span><br><span class="line"># /etc/services:</span><br><span class="line"></span><br><span class="line"># $Id: services,v 1.55 2013/04/14 ovasik Exp $</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># Network services, Internet style</span><br><span class="line"></span><br><span class="line"># IANA services version: last updated 2013-04-10</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# more +465 /etc/services </span><br><span class="line">bpjava-msvc     13722/tcp                       # BP Java MSVC Protocol</span><br><span class="line">bpjava-msvc     13722/udp                       # BP Java MSVC Protocol</span><br><span class="line">vnetd           13724/tcp                       # Veritas Network Utility</span><br><span class="line">vnetd           13724/udp                       # Veritas Network Utility</span><br><span class="line">bpcd            13782/tcp                       # VERITAS NetBackup</span><br><span class="line">bpcd            13782/udp                       # VERITAS NetBackup</span><br><span class="line">vopied          13783/tcp                       # VOPIED Protocol</span><br><span class="line">vopied          13783/udp                       # VOPIED Protocol</span><br><span class="line"></span><br><span class="line"># This port is registered as wnn6, but also used under the unregistered name</span><br><span class="line"></span><br><span class="line"># &quot;wnn4&quot; by the FreeWnn package.</span><br><span class="line"></span><br><span class="line">wnn6            22273/tcp       wnn4</span><br><span class="line">wnn6            22273/udp       wnn4</span><br><span class="line"></span><br><span class="line">quake           26000/tcp</span><br><span class="line">quake           26000/udp</span><br><span class="line">wnn6-ds         26208/tcp</span><br><span class="line">wnn6-ds         26208/udp</span><br><span class="line">traceroute      33434/tcp</span><br><span class="line">traceroute      33434/udp</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># Datagram Delivery Protocol services</span><br><span class="line"></span><br><span class="line">。。。</span><br></pre></td></tr></table></figure><p><strong>4）分页显示目录下的内容</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 分页显示/etc/目录下的内容，每页显示10行内容 </span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# ls -l /etc/|more -10 </span><br><span class="line"></span><br><span class="line">total 1108 </span><br><span class="line"></span><br><span class="line">-rw-r--r--.  1 root root       16 Apr  7 20:39 adjtime </span><br><span class="line"></span><br><span class="line">-rw-r--r--.  1 root root     1518 Jun  7  2013 aliases </span><br><span class="line"></span><br><span class="line">-rw-r--r--.  1 root root    12288 Apr  7 20:43 aliases.db </span><br><span class="line"></span><br><span class="line">drwxr-xr-x.  2 root root      236 Apr  7 20:35 alternatives </span><br><span class="line"></span><br><span class="line">-rw-------.  1 root root      541 Apr 11  2018 anacrontab </span><br><span class="line"></span><br><span class="line">-rw-r--r--.  1 root root       55 Apr 11  2018 asound.conf </span><br><span class="line"></span><br><span class="line">drwxr-x---.  3 root root       43 Apr  7 20:35 audisp </span><br><span class="line"></span><br><span class="line">drwxr-x---.  3 root root       83 Apr  7 20:43 audit </span><br><span class="line"></span><br><span class="line">drwxr-xr-x.  2 root root       33 Apr  7 20:35 bash_completion.d </span><br><span class="line"></span><br><span class="line">--More-- 。。。</span><br></pre></td></tr></table></figure><p><strong>小练习：more的其它用法请自行练习，可在讨论区进行讨论</strong></p><h2 id="less：分页显示文件内容"><a href="#less：分页显示文件内容" class="headerlink" title="less：分页显示文件内容"></a>less：分页显示文件内容</h2><p>如果使用man less查看less的帮助文档，会发现官方的解释是less为more的反义词（opposite of more）。但less命令的名称只是个文字游戏，它是more命令的高级版本（less这个名称来自俗语“越简单就越丰富”，即less is more）。</p><p>less命令的基本功能类似于more命令，可以分页显示文件内容，但比more的功能更强大。less命令在读取文件内容时，并不是像more、vi命令一样，要一次性将整个文件加载之后再显示，而是会根据需要来加载文件的内容，这样打开文件的速度会更快。而且less命令支持[page up]、[page down]等按键的功能，可以通过该功能向前或向后翻看文件，这样更容易查看一个文件的内容。</p><p><strong>语法格式：less [option] [file]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/04/20/5cbb0240a4397.jpg"></p><p>在交互模式下，less命令也是基于more命令和vi命令的，在这里可以使用vi编辑器的部分功能，如搜索功能，还可以切换到vi编辑器。表3-7给出了less命令的交互式子命令。</p><p><strong>less交互式命令说明</strong></p><p><img src="https://i.loli.net/2019/04/20/5cbb0259c2592.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）查看文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"># 使用less查看/etc/services文件内容</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# less /etc/services </span><br><span class="line"></span><br><span class="line"># /etc/services:</span><br><span class="line"></span><br><span class="line"># $Id: services,v 1.55 2013/04/14 ovasik Exp $</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># Network services, Internet style</span><br><span class="line"></span><br><span class="line"># IANA services version: last updated 2013-04-10</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># Note that it is presently the policy of IANA to assign a single well-known</span><br><span class="line"></span><br><span class="line"># port number for both TCP and UDP; hence, most entries here have two entries</span><br><span class="line"></span><br><span class="line"># even if the protocol doesn&apos;t support UDP operations.</span><br><span class="line"></span><br><span class="line"># Updated from RFC 1700, ``Assigned Numbers&apos;&apos; (October 1994).  Not all ports</span><br><span class="line"></span><br><span class="line"># are included, only the more common ones.</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># The latest IANA port assignments can be gotten from</span><br><span class="line"></span><br><span class="line"># http://www.iana.org/assignments/port-numbers</span><br><span class="line"></span><br><span class="line"># The Well Known Ports are those from 0 through 1023.</span><br><span class="line"></span><br><span class="line"># The Registered Ports are those from 1024 through 49151</span><br><span class="line"></span><br><span class="line"># The Dynamic and/or Private Ports are those from 49152 through 65535</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># Each line describes one service, and is of the form:</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># service-name  port/protocol  [aliases ...]   [# comment]</span><br><span class="line"></span><br><span class="line">tcpmux          1/tcp                           # TCP port service multiplexer</span><br><span class="line">tcpmux          1/udp                           # TCP port service multiplexer</span><br><span class="line">rje             5/tcp                           # Remote Job Entry</span><br><span class="line">rje             5/udp                           # Remote Job Entry</span><br><span class="line">echo            7/tcp</span><br><span class="line">echo            7/udp</span><br><span class="line">discard         9/tcp           sink null</span><br><span class="line">discard         9/udp           sink null</span><br><span class="line">systat          11/tcp          users</span><br><span class="line">systat          11/udp          users</span><br><span class="line">daytime         13/tcp</span><br><span class="line">daytime         13/udp</span><br><span class="line">。。。</span><br></pre></td></tr></table></figure><p><strong>2）显示行号</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># 使用less -N查看文件/etc/services的内容</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# less -N /etc/services </span><br><span class="line">1 # /etc/services:</span><br><span class="line">2 # $Id: services,v 1.55 2013/04/14 ovasik Exp $</span><br><span class="line">3 #</span><br><span class="line">4 # Network services, Internet style</span><br><span class="line">5 # IANA services version: last updated 2013-04-10</span><br><span class="line">6 #</span><br><span class="line">7 # Note that it is presently the policy of IANA to assign a single well-known</span><br><span class="line">8 # port number for both TCP and UDP; hence, most entries here have two entries</span><br><span class="line">9 # even if the protocol doesn&apos;t support UDP operations.</span><br><span class="line">10 # Updated from RFC 1700, ``Assigned Numbers&apos;&apos; (October 1994).  Not all ports</span><br><span class="line">11 # are included, only the more common ones.</span><br><span class="line">12 #</span><br><span class="line">13 # The latest IANA port assignments can be gotten from</span><br><span class="line">14 #       http://www.iana.org/assignments/port-numbers</span><br><span class="line">15 # The Well Known Ports are those from 0 through 1023.</span><br><span class="line">16 # The Registered Ports are those from 1024 through 49151</span><br><span class="line">17 # The Dynamic and/or Private Ports are those from 49152 through 65535</span><br><span class="line">18 #</span><br><span class="line">19 # Each line describes one service, and is of the form:</span><br><span class="line">20 #</span><br><span class="line">21 # service-name  port/protocol  [aliases ...]   [# comment]</span><br><span class="line">22 </span><br><span class="line">23 tcpmux          1/tcp                           # TCP port service multiplexer</span><br><span class="line">24 tcpmux          1/udp                           # TCP port service multiplexer</span><br><span class="line">25 rje             5/tcp                           # Remote Job Entry</span><br><span class="line">26 rje             5/udp                           # Remote Job Entry</span><br><span class="line">27 echo            7/tcp</span><br><span class="line">28 echo            7/udp</span><br><span class="line">29 discard         9/tcp           sink null</span><br><span class="line">30 discard         9/udp           sink null</span><br><span class="line">31 systat          11/tcp          users</span><br><span class="line">32 systat          11/udp          users</span><br><span class="line">33 daytime         13/tcp</span><br><span class="line">34 daytime         13/udp</span><br><span class="line">35 qotd            17/tcp          quote</span><br><span class="line">36 qotd            17/udp          quote</span><br><span class="line">37 msp             18/tcp                          # message send protocol (historic)</span><br><span class="line">38 msp             18/udp                          # message send protocol (historic)</span><br><span class="line">39 chargen         19/tcp          ttytst source</span><br></pre></td></tr></table></figure><p><strong>小练习：使用less分页显示/etc/目录下的内容。（提示：可参照more使用示例）</strong></p><h2 id="head：显示文件内容头部"><a href="#head：显示文件内容头部" class="headerlink" title="head：显示文件内容头部"></a>head：显示文件内容头部</h2><p>head命令用于显示文件内容头部，它默认输出文件的开头10行。如果指定了多个文件，则在每一段输出前会给出文件名作为文件头。</p><p><strong>语法格式：head [option] [file]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/04/20/5cbb02beca189.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）不带任何参数，默认显示文件的前10行内容</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 显示/etc/passwd文件的前10行内容</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# head /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line">lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br><span class="line">sync:x:5:0:sync:/sbin:/bin/sync</span><br><span class="line">shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown</span><br><span class="line">halt:x:7:0:halt:/sbin:/sbin/halt</span><br><span class="line">mail:x:8:12:mail:/var/spool/mail:/sbin/nologin</span><br><span class="line">operator:x:11:0:operator:/root:/sbin/nologin</span><br></pre></td></tr></table></figure><p><strong>2）显示文件的前n行内容</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 显示/etc/passwd文件的前5行内容</span><br><span class="line"></span><br><span class="line"># 选项n可带也可不带，通常情况下，为简化指令一般不带选项n，直接输入数字即可</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# head -5 /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line">lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br></pre></td></tr></table></figure><p><strong>3） 读取文件的前10个字节</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用-c选项，读取/etc/hosts文件的前10个字节</span><br><span class="line"></span><br><span class="line"># 注意：空格符也统计在内</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# head -c 10 /etc/hosts</span><br><span class="line">127.0.0.1 # 这行最后有一个空格</span><br></pre></td></tr></table></figure><p><strong>4） 显示多个文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 同时显示/etc/hosts和/etc/passwd文件的前5行内容</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# head -c 10 /etc/hosts</span><br><span class="line">127.0.0.1 [root@C7-Server01 kkutysllb]# head -5 /etc/hosts /etc/passwd</span><br><span class="line">==&gt; /etc/hosts &lt;==  # 每个文件名作为文件头</span><br><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line">==&gt; /etc/passwd &lt;== # 每个文件名作为文件头</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line">lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br></pre></td></tr></table></figure><p><strong>小练习：使用head命令只显示/etc/services文件的最后一行内容</strong></p><h2 id="tail：显示文件内容尾部"><a href="#tail：显示文件内容尾部" class="headerlink" title="tail：显示文件内容尾部"></a>tail：显示文件内容尾部</h2><p>tail命令用于显示文件内容的尾部，它默认输出文件的最后10行。如果指定了多于一个文件，则在每一段输出前会给出文件名作为文件头。</p><p><strong>语法格式：tail [option] [file]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/04/20/5cbb031ae5511.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）不带任何参数，默认显示文件的最后10行</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 显示/etc/passwd文件的最后10行内容</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# tail /etc/passwd</span><br><span class="line">nobody:x:99:99:Nobody:/:/sbin/nologin</span><br><span class="line">systemd-network:x:192:192:systemd Network Management:/:/sbin/nologin</span><br><span class="line">dbus:x:81:81:System message bus:/:/sbin/nologin</span><br><span class="line">polkitd:x:999:998:User for polkitd:/:/sbin/nologin</span><br><span class="line">tss:x:59:59:Account used by the trousers package to sandbox the tcsd daemon:/dev/null:/sbin/nologin</span><br><span class="line">sshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin</span><br><span class="line">postfix:x:89:89::/var/spool/postfix:/sbin/nologin</span><br><span class="line">chrony:x:998:996::/var/lib/chrony:/sbin/nologin</span><br><span class="line">ntp:x:38:38::/etc/ntp:/sbin/nologin</span><br><span class="line">kkutysllb:x:1000:1000::/home/kkutysllb:/bin/bash</span><br></pre></td></tr></table></figure><p><strong>2）显示文件的末尾5行内容</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 与head命令一样，可以省略-n选项，直接填写数字</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# tail -5 /etc/services </span><br><span class="line">com-bardac-dw   48556/tcp               # com-bardac-dw</span><br><span class="line">com-bardac-dw   48556/udp               # com-bardac-dw</span><br><span class="line">iqobject        48619/tcp               # iqobject</span><br><span class="line">iqobject        48619/udp               # iqobject</span><br><span class="line">matahari        49000/tcp               # Matahari Broker</span><br></pre></td></tr></table></figure><p><strong>3）实时监控文件的变化</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 使用-f选项实时监控系统安全日志/var/log/secure</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# tail -f /var/log/secure</span><br></pre></td></tr></table></figure><p><strong><em>初始状态如下</em></strong></p><p><img src="https://i.loli.net/2019/04/20/5cbb0377470ea.jpg"></p><p><strong><em>当我再次打开一个终端时，文件实时发生变化</em></strong></p><p><img src="https://i.loli.net/2019/04/20/5cbb03921a52c.jpg"></p><p><strong>需要说明的是：使用tail -f实时跟踪日志文件结束后，必须使用Ctrl+C退出。同时，在Linux系统还有一个专门跟踪系统日志文件的命令tailf，功能几乎等同于tail-f，与tail-f不同的是，如果文件不增长，那么它不会去访问磁盘文件，也不会更改文件的访问时间。</strong></p><h2 id="cut：从文本中提取一段文字并输出"><a href="#cut：从文本中提取一段文字并输出" class="headerlink" title="cut：从文本中提取一段文字并输出"></a>cut：从文本中提取一段文字并输出</h2><p>cut命令从文件的每一行剪切字节、字符或字段，并将这些字节、字符或字段输出至标准输出。</p><p><strong>语法格式：cut [option] [file]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/04/20/5cbb03a92ad40.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）以字节为分隔符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># 显示当前目录下data001文件的内容</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# cat data001</span><br><span class="line">day001...</span><br><span class="line">day002...</span><br><span class="line">day003...</span><br><span class="line">day004...</span><br><span class="line">...</span><br><span class="line">day00n...</span><br><span class="line"></span><br><span class="line"># 以-b选项，只显示data001文件每行的第3个字节内容</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# cut -b 3 data001</span><br><span class="line">y</span><br><span class="line">y</span><br><span class="line">y</span><br><span class="line">y</span><br><span class="line">.</span><br><span class="line">y</span><br><span class="line"></span><br><span class="line"># 显示data001文件每行的第3到第5个字节内容</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# cut -b 3-5 data001</span><br><span class="line">y00</span><br><span class="line">y00</span><br><span class="line">y00</span><br><span class="line">y00</span><br><span class="line">.</span><br><span class="line">y00</span><br><span class="line"></span><br><span class="line"># 显示data001文件每行从第1个字节到第3个字节的内容</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# cut -b -3 data001</span><br><span class="line">day</span><br><span class="line">day</span><br><span class="line">day</span><br><span class="line">day</span><br><span class="line">...</span><br><span class="line">day</span><br></pre></td></tr></table></figure><p><strong>2）以字符为分隔符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 显示data001文件每行的第2到5个字符</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# cut -c 2-5 data001</span><br><span class="line">ay00</span><br><span class="line">ay00</span><br><span class="line">ay00</span><br><span class="line">ay00</span><br><span class="line">..</span><br><span class="line">ay00</span><br></pre></td></tr></table></figure><p><strong>发现与-b选项的输出没有区别，这是英文是以单字母为字符的，如果换成中文就看出区别了，请大家自行练习。</strong></p><p><strong>3）自定义分隔符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"># 使用：作为分隔符，显示/etc/passwd文件所有行的第一列的内容</span><br><span class="line"></span><br><span class="line"># 此方法和后续三剑客中awk使用场景类似</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# cut -d : -f 1 /etc/passwd</span><br><span class="line">root</span><br><span class="line">bin</span><br><span class="line">daemon</span><br><span class="line">adm</span><br><span class="line">lp</span><br><span class="line">sync</span><br><span class="line">shutdown</span><br><span class="line">halt</span><br><span class="line">mail</span><br><span class="line">operator</span><br><span class="line">games</span><br><span class="line">ftp</span><br><span class="line">nobody</span><br><span class="line">systemd-network</span><br><span class="line">dbus</span><br><span class="line">polkitd</span><br><span class="line">tss</span><br><span class="line">sshd</span><br><span class="line">postfix</span><br><span class="line">chrony</span><br><span class="line">ntp</span><br><span class="line">kkutysllb# 以：为分隔符，显示/etc/passwd文件每行的3-5列内容</span><br><span class="line">[root@C7-Server01 kkutysllb]# cut -d : -f 3-5 /etc/passwd</span><br><span class="line">0:0:root</span><br><span class="line">1:1:bin</span><br><span class="line">2:2:daemon</span><br><span class="line">3:4:adm</span><br><span class="line">4:7:lp</span><br><span class="line">5:0:sync</span><br><span class="line">6:0:shutdown</span><br><span class="line">7:0:halt</span><br><span class="line">8:12:mail</span><br><span class="line">11:0:operator</span><br><span class="line">12:100:games</span><br><span class="line">14:50:FTP User</span><br><span class="line">99:99:Nobody</span><br><span class="line">192:192:systemd Network Management</span><br><span class="line">81:81:System message bus</span><br><span class="line">999:998:User for polkitd</span><br><span class="line">59:59:Account used by the trousers package to sandbox the tcsd daemon</span><br><span class="line">74:74:Privilege-separated SSH</span><br><span class="line">89:89:</span><br><span class="line">998:996:</span><br><span class="line">38:38:</span><br><span class="line">1000:1000:</span><br></pre></td></tr></table></figure><h2 id="sort：文本排序"><a href="#sort：文本排序" class="headerlink" title="sort：文本排序"></a>sort：文本排序</h2><p>sort命令将输入的文件内容按照指定的规则进行排序，然后将排序结果输出。</p><p><strong>语法格式：sort [option] [file]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/04/20/5cbb0404b1851.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）默认以行为单位进行比较</strong></p><p>默认比较的原则是从首字符向后，依次按ASCII码值进行比较，输出默认按升序进行排列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 生成一个实验文件，写入如下内容</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# cat &gt;&gt; data003 &lt;&lt; EOF</span><br><span class="line"></span><br><span class="line">&gt; 10.0.2.1</span><br><span class="line">&gt; 10.0.2.56</span><br><span class="line">&gt; 10.0.2.3</span><br><span class="line">&gt; 10.0.2.5</span><br><span class="line">&gt; 10.0.2.14</span><br><span class="line">&gt; 10.0.2.11</span><br><span class="line">&gt; EOF</span><br><span class="line"></span><br><span class="line"># 使用sort默认对data003文件进行升序排序输出</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# sort data003</span><br><span class="line">10.0.2.1</span><br><span class="line">10.0.2.11</span><br><span class="line">10.0.2.14</span><br><span class="line">10.0.2.3</span><br><span class="line">10.0.2.5</span><br><span class="line">10.0.2.56</span><br></pre></td></tr></table></figure><p><strong>2）使用-n选项使输出按数字从小到大的顺序进行排列</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]# sort -n data003</span><br><span class="line">10.0.2.1</span><br><span class="line">10.0.2.11</span><br><span class="line">10.0.2.14</span><br><span class="line">10.0.2.3</span><br><span class="line">10.0.2.5</span><br><span class="line">10.0.2.56</span><br></pre></td></tr></table></figure><p><strong>3）结合-r选项进行反向排序</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]# sort -nr data003</span><br><span class="line">10.0.2.56</span><br><span class="line">10.0.2.5</span><br><span class="line">10.0.2.3</span><br><span class="line">10.0.2.14</span><br><span class="line">10.0.2.11</span><br><span class="line">10.0.2.1</span><br></pre></td></tr></table></figure><p><strong>4）使用-t和-k按照指定格式要求进行排序</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 对/etc/passwd文件按要求进行排序</span><br><span class="line"></span><br><span class="line"># 使用-t选项指定分割符为：</span><br><span class="line"></span><br><span class="line"># 使用-k数字选项指定按照分割后的第3列进行排序</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# sort -t : -k 3 /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">kkutysllb:x:1000:1000::/home/kkutysllb:/bin/bash</span><br><span class="line">operator:x:11:0:operator:/root:/sbin/nologin</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">games:x:12:100:games:/usr/games:/sbin/nologin</span><br><span class="line">ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin</span><br><span class="line">systemd-network:x:192:192:systemd Network Management:/:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line">ntp:x:38:38::/etc/ntp:/sbin/nologin</span><br><span class="line">lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br><span class="line">sync:x:5:0:sync:/sbin:/bin/sync</span><br><span class="line">tss:x:59:59:Account used by the trousers package to sandbox the tcsd daemon:/dev/null:/sbin/nologin</span><br><span class="line">shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown</span><br><span class="line">halt:x:7:0:halt:/sbin:/sbin/halt</span><br><span class="line">sshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin</span><br><span class="line">mail:x:8:12:mail:/var/spool/mail:/sbin/nologin</span><br><span class="line">dbus:x:81:81:System message bus:/:/sbin/nologin</span><br><span class="line">postfix:x:89:89::/var/spool/postfix:/sbin/nologin</span><br><span class="line">chrony:x:998:996::/var/lib/chrony:/sbin/nologin</span><br><span class="line">polkitd:x:999:998:User for polkitd:/:/sbin/nologin</span><br><span class="line">nobody:x:99:99:Nobody:/:/sbin/nologin</span><br></pre></td></tr></table></figure><p><strong>5）使用-k选项的进阶用法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 使用-k选项指定字符范围进行排序</span><br><span class="line"></span><br><span class="line"># -k4.1,4,2表示按照第4列的第一个字符到第二个字符范围整体排序</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# sort -n -t . -k 4.1,4.2 data003</span><br><span class="line">10.0.2.1</span><br><span class="line">10.0.2.3</span><br><span class="line">10.0.2.5</span><br><span class="line">10.0.2.11</span><br><span class="line">10.0.2.14</span><br><span class="line">10.0.2.56</span><br></pre></td></tr></table></figure><h2 id="uniq：去除重复行"><a href="#uniq：去除重复行" class="headerlink" title="uniq：去除重复行"></a>uniq：去除重复行</h2><p>uniq命令可以输出或忽略文件中的重复行。在工作中，我们常用的场景是使用sort命令对文件排序，然后使用uniq命令去重并计数。</p><p><strong>语法格式：uniq [option] [INPUT]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/04/20/5cbb046a974b3.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）去重测试</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 创建测试文件</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# cat data003</span><br><span class="line">10.0.2.1</span><br><span class="line">10.0.2.56</span><br><span class="line">10.0.2.3</span><br><span class="line">10.0.2.5</span><br><span class="line">10.0.2.14</span><br><span class="line">10.0.2.11</span><br><span class="line">10.0.2.2</span><br><span class="line">10.0.2.2</span><br><span class="line">10.0.2.3</span><br><span class="line">10.0.2.11</span><br><span class="line">10.0.2.1</span><br><span class="line">10.0.2.1</span><br><span class="line">10.0.2.1</span><br><span class="line"></span><br><span class="line"># 使用uniq指令去重，结合sort指令一起使用</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# sort data003 | uniq</span><br><span class="line">10.0.2.1</span><br><span class="line">10.0.2.11</span><br><span class="line">10.0.2.14</span><br><span class="line">10.0.2.2</span><br><span class="line">10.0.2.3</span><br><span class="line">10.0.2.5</span><br><span class="line">10.0.2.56</span><br></pre></td></tr></table></figure><p><strong>2）显示重复行的个数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]# sort -n -t . -k 4.1,4.2 data003 | uniq -c</span><br><span class="line">4 10.0.2.1</span><br><span class="line">2 10.0.2.2</span><br><span class="line">2 10.0.2.3</span><br><span class="line">1 10.0.2.5</span><br><span class="line">2 10.0.2.11</span><br><span class="line">1 10.0.2.14</span><br><span class="line">1 10.0.2.56</span><br></pre></td></tr></table></figure><p><strong>3）只显示重复行</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]# sort -n -t . -k 4.1,4.2 data003 | uniq -cd</span><br><span class="line">4 10.0.2.1</span><br><span class="line">2 10.0.2.2</span><br><span class="line">2 10.0.2.3</span><br><span class="line">2 10.0.2.11</span><br></pre></td></tr></table></figure><p><strong>4）只显示唯一行</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]# sort -n -t . -k 4.1,4.2 data003 | uniq -u</span><br><span class="line">10.0.2.5</span><br><span class="line">10.0.2.14</span><br><span class="line">10.0.2.56</span><br></pre></td></tr></table></figure><h2 id="wc：统计文件的行数、单词数或字节数"><a href="#wc：统计文件的行数、单词数或字节数" class="headerlink" title="wc：统计文件的行数、单词数或字节数"></a>wc：统计文件的行数、单词数或字节数</h2><p>wc命令用于统计文件的行数、单词数或字节数。</p><p><strong>语法格式：wc [option] [file]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/04/20/5cbb0c7696443.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）查看文件的字节数、字数、行数等</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 查看/etc/hosts的统计值（字节数、字数、行数等）</span><br><span class="line"></span><br><span class="line"># 什么参数都不加时，显示的三个数字从左到右分别是行数，单词数和字节数</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# wc /etc/hosts</span><br><span class="line">2  10 158 /etc/hosts</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 显示文件的字节数</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# wc -c /etc/hosts</span><br><span class="line">158 /etc/hosts</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 显示文件的单词数</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# wc -w /etc/hosts</span><br><span class="line">10 /etc/hosts</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 显示文件的行数</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# wc -l /etc/hosts</span><br><span class="line">2 /etc/hosts</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 显示文件最长行的长度</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# wc -L /etc/hosts</span><br><span class="line">78 /etc/hosts</span><br></pre></td></tr></table></figure><p><strong>2）在shell脚本常用来判断某个软件包是否安装</strong></p><p><img src="https://i.loli.net/2019/04/20/5cbb0cd6eb1a6.jpg"></p><h2 id="diff：比较两个文件的不同"><a href="#diff：比较两个文件的不同" class="headerlink" title="diff：比较两个文件的不同"></a>diff：比较两个文件的不同</h2><p>diff命令可以逐行比较纯文本文件的内容，并输出文件的差异。只能同时比较2个文件。</p><p><strong>语法格式：diff [option] [file1] [file2]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/04/20/5cbb0ceb49eaf.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）比较两个文本文件</strong></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&gt; # 将data003文件去重后生成一个新文件data004</span><br><span class="line">&gt; </span><br><span class="line">&gt; [root@C7-Server01 kkutysllb]# sort data003 | uniq &gt; data004</span><br><span class="line">&gt; [root@C7-Server01 kkutysllb]# cat data004</span><br><span class="line">&gt; 10.0.2.1</span><br><span class="line">&gt; 10.0.2.11</span><br><span class="line">&gt; 10.0.2.14</span><br><span class="line">&gt; 10.0.2.2</span><br><span class="line">&gt; 10.0.2.3</span><br><span class="line">&gt; 10.0.2.5</span><br><span class="line">&gt; 10.0.2.56</span><br><span class="line">&gt; </span><br><span class="line">&gt; # 比较data003和data004两个文件</span><br><span class="line">&gt; </span><br><span class="line">&gt; [root@C7-Server01 kkutysllb]# diff data003 data004</span><br><span class="line">&gt; 2,5d1   # 以data003为基准，data003比data004多了2,3,4,5行，所以data003的2-5行需要删除</span><br><span class="line">&gt; &lt; 10.0.2.56</span><br><span class="line">&gt; &lt; 10.0.2.3</span><br><span class="line">&gt; &lt; 10.0.2.5</span><br><span class="line">&gt; &lt; 10.0.2.14</span><br><span class="line">&gt; 7c3  # 以data003为基准，其第7行对应data004的第3行，两者结果不一致，需要修改</span><br><span class="line">&gt; </span><br><span class="line">&gt; ## &lt; 10.0.2.2</span><br><span class="line">&gt; </span><br><span class="line">&gt; &gt; 10.0.2.14</span><br><span class="line">&gt; &gt; 10,13c6,7  # 以data003为基准，其第10,11行对应data004的第6,7行，两者结果不一致，需要修改。同时，data003多了12,13两行内容</span><br><span class="line">&gt; &gt; &lt; 10.0.2.11</span><br><span class="line">&gt; &gt; &lt; 10.0.2.1</span><br><span class="line">&gt; &gt; &lt; 10.0.2.1</span><br><span class="line">&gt; &gt; &lt; 10.0.2.1</span><br><span class="line">&gt; </span><br><span class="line">&gt; ------</span><br><span class="line">&gt; </span><br><span class="line">&gt; &gt; 10.0.2.5</span><br><span class="line">&gt; &gt; 10.0.2.56</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><p><strong>2） 并排格式输出</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 使用-y选项就可以并排格式输出对比</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# diff -y data003 data004</span><br><span class="line">10.0.2.110.0.2.1</span><br><span class="line">10.0.2.56      &lt;</span><br><span class="line">10.0.2.3      &lt;</span><br><span class="line">10.0.2.5      &lt;</span><br><span class="line">10.0.2.14      &lt;</span><br><span class="line">10.0.2.1110.0.2.11</span><br><span class="line">10.0.2.2      |10.0.2.14</span><br><span class="line">10.0.2.210.0.2.2</span><br><span class="line">10.0.2.310.0.2.3</span><br><span class="line">10.0.2.11      |10.0.2.5</span><br><span class="line">10.0.2.1      |10.0.2.56</span><br><span class="line">10.0.2.1      &lt;</span><br><span class="line">10.0.2.1      &lt;</span><br></pre></td></tr></table></figure><p><strong>3） 使用-c选项就可以上下文输出</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># -表示data004比data003少的行数</span><br><span class="line"></span><br><span class="line"># +表示data004比data003多的行数</span><br><span class="line"></span><br><span class="line"># !表示两者不一样的行数</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# diff -c data003 data004</span><br><span class="line">*** data0032019-04-20 15:44:51.488782009 +0800</span><br><span class="line">--- data0042019-04-20 17:21:03.569053069 +0800</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">  *** 1,13 ****</span><br><span class="line">    10.0.2.1</span><br><span class="line"></span><br><span class="line">- 10.0.2.56</span><br><span class="line">  - 10.0.2.3</span><br><span class="line">  - 10.0.2.5</span><br><span class="line">  - 10.0.2.14</span><br><span class="line">    10.0.2.11</span><br><span class="line">    ! 10.0.2.2</span><br><span class="line">    10.0.2.2</span><br><span class="line">    10.0.2.3</span><br><span class="line">    ! 10.0.2.11</span><br><span class="line">    ! 10.0.2.1</span><br><span class="line">    ! 10.0.2.1</span><br><span class="line">    ! 10.0.2.1</span><br><span class="line">    --- 1,7 ----</span><br><span class="line">    10.0.2.1</span><br><span class="line">    10.0.2.11</span><br><span class="line">    ! 10.0.2.14</span><br><span class="line">    10.0.2.2</span><br><span class="line">    10.0.2.3</span><br><span class="line">    ! 10.0.2.5</span><br><span class="line">    ! 10.0.2.56</span><br></pre></td></tr></table></figure><p>​    </p><p><strong>小练习：除了diff指令可以比较两个文件外，vimdiff指令还可以可视化比较两个文件，大家自行研究。</strong></p><h2 id="tee：多重定向"><a href="#tee：多重定向" class="headerlink" title="tee：多重定向"></a>tee：多重定向</h2><p>tee命令用于将数据重定向到文件，同时提供一份重定向数据的副本作为后续命令的标准输入。简单地说就是把数据重定向到给定文件和屏幕上。</p><p><strong>语法格式：tee [option] [file]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/04/20/5cbb0d47b66ac.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）tee命令允许标准输出同时把内容写入（覆盖）到文件中</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># 显示当前目录下内容详细信息，并将结果写入到data005文件中（如果data005文件不存在，则直接创建，否则将内容覆盖原文件内容）</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# ls -lhi | tee data005</span><br><span class="line">total 28K</span><br><span class="line">1231037 -rw-r--r--  1 root root   0 Apr 16 18:35 202012312234.55</span><br><span class="line">34100198 drwxr-xr-x  5 root root  45 Apr 17 11:59 data</span><br><span class="line">1231031 -rw-r--r--  1 root root  54 Apr 19 17:14 data001</span><br><span class="line">1231047 -rw-r--r--  1 root root  73 Apr 19 17:31 data002</span><br><span class="line">1231030 -rw-r--r--  1 root root 121 Apr 20 15:44 data003</span><br><span class="line">1231056 -rw-r--r--  1 root root  66 Apr 20 17:21 data004</span><br><span class="line">1231024 -rw-r--r--  1 root root   0 Apr 20 17:41 data005</span><br><span class="line">1231057 drwxr-xr-x  5 root root  45 Apr 17 11:59 data_tmp</span><br><span class="line">33583813 -rw-r--r--. 1 root root 158 Jun  7  2013 hard_link</span><br><span class="line">1231054 -rw-r--r--  1 root root   0 Apr 16 17:56 image008</span><br><span class="line">1231055 -rw-r--r--  1 root root   0 Apr 16 17:56 image009</span><br><span class="line">1231032 -rw-r--r--  1 root root   0 Apr 17 11:46 image010</span><br><span class="line">1231039 drwxr-xr-x  2 root root   6 Apr 16 14:30 mytest</span><br><span class="line">1231043 lrwxrwxrwx  1 root root  10 Apr 17 14:04 soft_link -&gt; /etc/hosts</span><br><span class="line">1231022 -rw-r--r--  1 root root   0 Apr 20 17:10 test01</span><br><span class="line">1231025 -rw-r--r--  1 root root  82 Apr 20 17:08 test01.sh</span><br><span class="line">1231052 -rw-r--r--  1 root root 114 Apr 19 18:03 test.sh</span><br><span class="line">[root@C7-Server01 kkutysllb]# cat -n data005</span><br><span class="line">1total 28K</span><br><span class="line">2 1231037 -rw-r--r--  1 root root   0 Apr 16 18:35 202012312234.55</span><br><span class="line">334100198 drwxr-xr-x  5 root root  45 Apr 17 11:59 data</span><br><span class="line">4 1231031 -rw-r--r--  1 root root  54 Apr 19 17:14 data001</span><br><span class="line">5 1231047 -rw-r--r--  1 root root  73 Apr 19 17:31 data002</span><br><span class="line">6 1231030 -rw-r--r--  1 root root 121 Apr 20 15:44 data003</span><br><span class="line">7 1231056 -rw-r--r--  1 root root  66 Apr 20 17:21 data004</span><br><span class="line">8 1231024 -rw-r--r--  1 root root   0 Apr 20 17:41 data005</span><br><span class="line">9 1231057 drwxr-xr-x  5 root root  45 Apr 17 11:59 data_tmp</span><br><span class="line">1033583813 -rw-r--r--. 1 root root 158 Jun  7  2013 hard_link</span><br><span class="line">11 1231054 -rw-r--r--  1 root root   0 Apr 16 17:56 image008</span><br><span class="line">12 1231055 -rw-r--r--  1 root root   0 Apr 16 17:56 image009</span><br><span class="line">13 1231032 -rw-r--r--  1 root root   0 Apr 17 11:46 image010</span><br><span class="line">14 1231039 drwxr-xr-x  2 root root   6 Apr 16 14:30 mytest</span><br><span class="line">15 1231043 lrwxrwxrwx  1 root root  10 Apr 17 14:04 soft_link -&gt; /etc/hosts</span><br><span class="line">16 1231022 -rw-r--r--  1 root root   0 Apr 20 17:10 test01</span><br><span class="line">17 1231025 -rw-r--r--  1 root root  82 Apr 20 17:08 test01.sh</span><br><span class="line">18 1231052 -rw-r--r--  1 root root 114 Apr 19 18:03 test.sh</span><br></pre></td></tr></table></figure><p><strong>2）tee命令允许标准输出同时把内容追加到文件中</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"># 使用-a选项，会将内容追加到目标文件最后</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# ls -lhi /boot | tee -a data005</span><br><span class="line">total 123M</span><br><span class="line">    72 -rw-r--r--. 1 root root 145K Apr 21  2018 config-3.10.0-862.el7.x86_64</span><br><span class="line">    81 -rw-r--r--  1 root root 149K Mar 18 23:10 config-3.10.0-957.10.1.el7.x86_64</span><br><span class="line">    67 drwxr-xr-x. 3 root root   17 Apr  7 20:33 efi</span><br><span class="line">    68 drwxr-xr-x. 2 root root   27 Apr  7 20:34 grub</span><br><span class="line">786496 drwx------. 5 root root  132 Apr 20 16:09 grub2</span><br><span class="line">    76 -rw-------. 1 root root  50M Apr  7 20:38 initramfs-0-rescue-e344b139f44946638783478bcb51f820.img</span><br><span class="line">    75 -rw-------  1 root root  19M Apr 20 16:09 initramfs-3.10.0-862.el7.x86_64.img</span><br><span class="line">    78 -rw-------  1 root root  11M Apr 20 16:08 initramfs-3.10.0-862.el7.x86_64kdump.img</span><br><span class="line">    84 -rw-------  1 root root  19M Apr 20 16:09 initramfs-3.10.0-957.10.1.el7.x86_64.img</span><br><span class="line">    73 -rw-r--r--. 1 root root 298K Apr 21  2018 symvers-3.10.0-862.el7.x86_64.gz</span><br><span class="line">    82 -rw-r--r--  1 root root 307K Mar 18 23:10 symvers-3.10.0-957.10.1.el7.x86_64.gz</span><br><span class="line">    71 -rw-------. 1 root root 3.3M Apr 21  2018 System.map-3.10.0-862.el7.x86_64</span><br><span class="line">    80 -rw-------  1 root root 3.4M Mar 18 23:10 System.map-3.10.0-957.10.1.el7.x86_64</span><br><span class="line">    77 -rwxr-xr-x. 1 root root 6.0M Apr  7 20:38 vmlinuz-0-rescue-e344b139f44946638783478bcb51f820</span><br><span class="line">    74 -rwxr-xr-x. 1 root root 6.0M Apr 21  2018 vmlinuz-3.10.0-862.el7.x86_64</span><br><span class="line">    83 -rwxr-xr-x  1 root root 6.4M Mar 18 23:10 vmlinuz-3.10.0-957.10.1.el7.x86_64</span><br><span class="line">[root@C7-Server01 kkutysllb]# </span><br><span class="line">[root@C7-Server01 kkutysllb]# cat -n data005</span><br><span class="line">     1total 28K</span><br><span class="line">     2 1231037 -rw-r--r--  1 root root   0 Apr 16 18:35 202012312234.55</span><br><span class="line">     334100198 drwxr-xr-x  5 root root  45 Apr 17 11:59 data</span><br><span class="line">     4 1231031 -rw-r--r--  1 root root  54 Apr 19 17:14 data001</span><br><span class="line">     5 1231047 -rw-r--r--  1 root root  73 Apr 19 17:31 data002</span><br><span class="line">     6 1231030 -rw-r--r--  1 root root 121 Apr 20 15:44 data003</span><br><span class="line">     7 1231056 -rw-r--r--  1 root root  66 Apr 20 17:21 data004</span><br><span class="line">     8 1231024 -rw-r--r--  1 root root   0 Apr 20 17:41 data005</span><br><span class="line">     9 1231057 drwxr-xr-x  5 root root  45 Apr 17 11:59 data_tmp</span><br><span class="line">    1033583813 -rw-r--r--. 1 root root 158 Jun  7  2013 hard_link</span><br><span class="line">    11 1231054 -rw-r--r--  1 root root   0 Apr 16 17:56 image008</span><br><span class="line">    12 1231055 -rw-r--r--  1 root root   0 Apr 16 17:56 image009</span><br><span class="line">    13 1231032 -rw-r--r--  1 root root   0 Apr 17 11:46 image010</span><br><span class="line">    14 1231039 drwxr-xr-x  2 root root   6 Apr 16 14:30 mytest</span><br><span class="line">    15 1231043 lrwxrwxrwx  1 root root  10 Apr 17 14:04 soft_link -&gt; /etc/hosts</span><br><span class="line">    16 1231022 -rw-r--r--  1 root root   0 Apr 20 17:10 test01</span><br><span class="line">    17 1231025 -rw-r--r--  1 root root  82 Apr 20 17:08 test01.sh</span><br><span class="line">    18 1231052 -rw-r--r--  1 root root 114 Apr 19 18:03 test.sh</span><br><span class="line">    19total 123M</span><br><span class="line">    20    72 -rw-r--r--. 1 root root 145K Apr 21  2018 config-3.10.0-862.el7.x86_64</span><br><span class="line">    21    81 -rw-r--r--  1 root root 149K Mar 18 23:10 config-3.10.0-957.10.1.el7.x86_64</span><br><span class="line">    22    67 drwxr-xr-x. 3 root root   17 Apr  7 20:33 efi</span><br><span class="line">    23    68 drwxr-xr-x. 2 root root   27 Apr  7 20:34 grub</span><br><span class="line">    24786496 drwx------. 5 root root  132 Apr 20 16:09 grub2</span><br><span class="line">    25    76 -rw-------. 1 root root  50M Apr  7 20:38 initramfs-0-rescue-e344b139f44946638783478bcb51f820.img</span><br><span class="line">    26    75 -rw-------  1 root root  19M Apr 20 16:09 initramfs-3.10.0-862.el7.x86_64.img</span><br><span class="line">    27    78 -rw-------  1 root root  11M Apr 20 16:08 initramfs-3.10.0-862.el7.x86_64kdump.img</span><br><span class="line">    28    84 -rw-------  1 root root  19M Apr 20 16:09 initramfs-3.10.0-957.10.1.el7.x86_64.img</span><br><span class="line">    29    73 -rw-r--r--. 1 root root 298K Apr 21  2018 symvers-3.10.0-862.el7.x86_64.gz</span><br><span class="line">    30    82 -rw-r--r--  1 root root 307K Mar 18 23:10 symvers-3.10.0-957.10.1.el7.x86_64.gz</span><br><span class="line">    31    71 -rw-------. 1 root root 3.3M Apr 21  2018 System.map-3.10.0-862.el7.x86_64</span><br><span class="line">    32    80 -rw-------  1 root root 3.4M Mar 18 23:10 System.map-3.10.0-957.10.1.el7.x86_64</span><br><span class="line">    33    77 -rwxr-xr-x. 1 root root 6.0M Apr  7 20:38 vmlinuz-0-rescue-e344b139f44946638783478bcb51f820</span><br><span class="line">    34    74 -rwxr-xr-x. 1 root root 6.0M Apr 21  2018 vmlinuz-3.10.0-862.el7.x86_64</span><br><span class="line">    35    83 -rwxr-xr-x  1 root root 6.4M Mar 18 23:10 vmlinuz-3.10.0-957.10.1.el7.x86_64</span><br></pre></td></tr></table></figure><p><strong>3）tee还有个用法类似cat的创建/追加文件的用法，区别是不需要添加输出重定向符号</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 创建docker.service.d目录</span><br><span class="line"></span><br><span class="line">mkdir /etc/systemd/system/docker.service.d</span><br><span class="line"></span><br><span class="line"># 在docker.service.d/目录下创建一个kolla.conf文件，并完成相应配置</span><br><span class="line"></span><br><span class="line">tee /etc/systemd/system/docker.service.d/kolla.conf &lt;&lt; &apos;EOF&apos;</span><br><span class="line">[Service]</span><br><span class="line">MountFlags=shared</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h2 id="tr：替换或删除字符"><a href="#tr：替换或删除字符" class="headerlink" title="tr：替换或删除字符"></a>tr：替换或删除字符</h2><p>tr命令从标准输入中替换、缩减或删除字符，并将结果写到标准输出。</p><p><strong>语法格式：tr [option] [SET1] [SET2]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/04/20/5cbb0da12a5e2.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）将文件中出现的“www”替换为“xyz”</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 生成测试文件</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# tee data005 &lt;&lt; &apos;EOF&apos;</span><br><span class="line"></span><br><span class="line">&gt; www.sina.com.cn</span><br><span class="line">&gt; www.aliyun.com</span><br><span class="line">&gt; www.chinamobile.com</span><br><span class="line">&gt; www.openstack.org</span><br><span class="line">&gt; www.tsinghua.edu.cn</span><br><span class="line">&gt; kkutysllb.cn</span><br><span class="line">&gt; EOF</span><br><span class="line">&gt; www.sina.com.cn</span><br><span class="line">&gt; www.aliyun.com</span><br><span class="line">&gt; www.chinamobile.com</span><br><span class="line">&gt; www.openstack.org</span><br><span class="line">&gt; www.tsinghua.edu.cn</span><br><span class="line">&gt; kkutysllb.cn</span><br><span class="line"></span><br><span class="line"># 不使用任何选项参数时，默认按照set1和set2的对应字符位置替换</span><br><span class="line"></span><br><span class="line"># 下面的例子w对应z，所有全部替换为z</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# tr &apos;www&apos; &apos;xyz&apos; &lt; data005</span><br><span class="line">zzz.sina.com.cn</span><br><span class="line">zzz.aliyun.com</span><br><span class="line">zzz.chinamobile.com</span><br><span class="line">zzz.openstack.org</span><br><span class="line">zzz.tsinghua.edu.cn</span><br><span class="line">kkutysllb.cn</span><br></pre></td></tr></table></figure><p><strong>2）使用tr命令“统一”字母大小写</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 这个例子中使用了正则的匹配规则，后续正则表达式会专门讲解</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# tr &apos;[a-z]&apos; &apos;[A-Z]&apos; &lt; data005</span><br><span class="line">WWW.SINA.COM.CN</span><br><span class="line">WWW.ALIYUN.COM</span><br><span class="line">WWW.CHINAMOBILE.COM</span><br><span class="line">WWW.OPENSTACK.ORG</span><br><span class="line">WWW.TSINGHUA.EDU.CN</span><br><span class="line">KKUTYSLLB.CN</span><br></pre></td></tr></table></figure><p><strong>3）删除所有的点”.”</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]# tr -d &quot;.&quot; &lt; data005</span><br><span class="line">wwwsinacomcn</span><br><span class="line">wwwaliyuncom</span><br><span class="line">wwwchinamobilecom</span><br><span class="line">wwwopenstackorg</span><br><span class="line">wwwtsinghuaeducn</span><br><span class="line">kkutysllbcn</span><br></pre></td></tr></table></figure><p><strong>4）将所有的非w字符替换为&amp;</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]# tr -c &apos;w&apos; &apos;&amp;&apos; &lt; data005</span><br><span class="line"></span><br><span class="line"># 除w字符外，其它所有字符被替换为&amp;，包括换行符\n和制表符\t</span><br><span class="line"></span><br><span class="line">www&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;www&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;www&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;www&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;www&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span><br></pre></td></tr></table></figure><p><strong>小练习：想想怎么使用br指令完成整单词替换？</strong></p><h2 id="vi-vim编辑器"><a href="#vi-vim编辑器" class="headerlink" title="vi/vim编辑器"></a>vi/vim编辑器</h2><p>vi是Linux命令行界面下的文字编辑器，几乎所有的Linux系统都安装了vi，只要学会了vi这个编辑工具，就可以在任何Linux系统上使用它。而vim是vi命令的增强版（Vi IMproved），与vi编辑器完全兼容，此外还有很多增强功能，例如用不同颜色高亮显示代码。因此，如果系统有vim命令，那么建议大家就使用vim编辑文本。</p><p><strong>语法格式：vim [option] [file]</strong></p><p><strong>【vim的三种模式】</strong></p><p>一般来说，vim可分为三种模式：普通模式、编辑模式、命令模式。这三种模式的作用分别如下。</p><p>（1）普通模式</p><p>用vim命令打开一个文件，默认的状态就是普通模式。在这个模式中，不能进行编辑输入操作，但可以按“上下左右”键来移动光标，也可以执行一些操作命令进行如删除、复制、粘贴等之类的工作。</p><p>（2）编辑模式</p><p>在普通模式下不能进行编辑输入操作，只有按下“i，I，o，O，a，A，r，R，s，S”（其中“I”最常用）等字母进入编辑模式之后才可以执行录入文字等编辑操作。看文件是否处于编辑模式状态有一个重要的特征，那就是在窗口的左下角要有插入的标记“——INSERT——”或“——插入——”，如下图所示：</p><p><img src="https://i.loli.net/2019/04/20/5cbb0e38b205b.jpg"></p><p>（3）命令模式</p><p>在普通模式下，输入“：”或“/”或“?”时，光标会自动定位在那一行，在这个模式中，可以执行保存、退出、搜索、替换、显示行号等相关操作。如下图所示：</p><p><img src="https://i.loli.net/2019/04/20/5cbb0e5093673.jpg"></p><p><strong>【vi/vim的操作示意图</strong>】</p><p><img src="https://i.loli.net/2019/04/20/5cbb0e68e47fd.jpg"></p><p><strong>1）进入编辑模式指令</strong></p><ul><li>i：在当前光标所在处输入文字</li><li>a：在当前光标所在的下一个字符处插入文字</li><li>I：在当前所在行的行首第一个非空格字符处开始插入文字、和A相反</li><li>A：在当前所在行的行尾最后一个字符处开始插入文字，和I相反</li><li>O：在当前所在行的上一行处插入新的一行</li><li>o：在当前所在行的下一行处插入新的一行</li><li>Esc：退出编辑模式，回到命令模式中。</li></ul><p><strong>2）命令行模式下指令</strong></p><ul><li>:wq：退出并保存</li><li>:wq!：退出并强制保存。</li><li>:q!：强制退出，不保存</li><li>:n1,n2,w filename：n1、n2为数字，将n1行到n2行的内容保存成filename这个文件。</li><li>:n1,n2 co n3：n1、n2为数字，将n1行到n2行内容拷贝到n3位置下。</li><li>:n1,n2 m n3：n1、n2为数字，将n1行到n2行的内容移动到n3位置下。</li><li>:!command：暂时离开vi到命令行模式下执行command的显示结果</li><li>:set nu：显示行号</li><li>:set nonu：与set nu相反，取消行号</li><li>:vs filename：垂直分屏显示，同时显示当前文件和filename对应文件的内容</li><li>:sp filename：水平分屏显示，同时当前文件和filename对应文件的内容</li><li>I+#+ESC：在可视模式下（Ctrl+v），一次性注释所选的多行，取消注释可用n1,n2s/#//gc。这里操作是一个通用操作，#可以换成tab键，这样可以实现批量缩进</li><li>Del：在可视块模式下（Ctrl+v），一次性删除所选内容</li><li>r：在可视块模式下（Ctrl+v），一次性替换所选内容</li></ul><p><strong>【常用操作】</strong></p><p><strong>1）普通模式下移动光标的操作</strong></p><ul><li>G：将光标自动文件的最后一行</li><li>gg：将光标移动文件的第一行</li><li>0：数字0，将光标从所在位置移动到当前行的开头</li><li>$：从光标所在位置移动到当前行的结尾</li><li>n<enter>：n为数字，<enter>为回车键，将光标从当前位置向下移动n行</enter></enter></li><li>ngg：n为数字，移动光标到文件的第n行</li><li>H：光标移动当前窗口最上方那一行</li><li>M：光标移动到当前窗口中间的那一行</li><li>L：光标移动到当前窗口最下方的那一行</li><li>h或向左箭头：光标向左移动一个字符</li><li>j或向下箭头：光标向下移动一个字符</li><li>k或向上箭头：光标向上移动一个字符</li><li>l或向右箭头：光标向右移动一个字符</li></ul><p><strong>2）普通模式下搜索与替换操作：</strong></p><ul><li>/关键字：从光标位置开始向下搜索关键字行</li><li>?关键字：从光标位置开始向上搜索关键字</li><li>n：从光标位置开始，向下重复前一个搜索的动作</li><li>N：从光标位置开始，向上重复前一个搜索的动作</li><li>:g/A/s/B/g：把符合A的内容全部替换为B，左斜线为分隔符，可以用@、#等替换</li><li>:%s/A/B/g：把符合A的内容全部替换为B，左斜线为分隔符，可以用@、#等替换。</li><li>:n1,n2s/A/B/gc：n1、n2为数字，在第n1行和n2行间寻找A，用B替换</li></ul><p><strong>3）普通模式下复制、粘贴、删除等操作</strong></p><ul><li>yy：复制光标所在行的全部内容</li><li>nyy：n为数字，复制光标开始向下共n行的内容</li><li>p/P：p将已复制的数据粘贴到光标的下一行，P则为粘贴到光标的上一行</li><li>dd：删除所在的当前行</li><li>ndd：n为数字，删除从光标开始向下的共n行。</li><li>u：恢复（回滚）前一个执行过的操作</li><li>.：点号。重复前一个执行过的动作</li><li>%：向后删除字符</li><li>X：向前删除字符</li><li>d1G：删除当前行至第一行</li><li>dG：删除当前行至最后一行</li><li>d0：删除当前光标文本至行首</li><li>d$：删除当前光标文本至行尾</li></ul><p><strong>vi/vim编辑器是Linux运维、开发、测试中最常用的工具，需要大家重点掌握。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;cat：合并文件或查看文件内容&quot;&gt;&lt;a href=&quot;#cat：合并文件或查看文件内容&quot; class=&quot;headerlink&quot; title=&quot;cat：合并文件或查看文件内容&quot;&gt;&lt;/a&gt;cat：合并文件或查看文件内容&lt;/h2&gt;&lt;p&gt;cat命令可以理解为英文单词concatenate的缩写，其功能是连接多个文件并且打印到屏幕输出，或者重定向到指定的文件中。此命令常用来显示单个文件内容，或者将几个文件内容连接起来一起显示，还可以从标准输入中读取内容并显示，生产环境中它常与重定向或追加符号配合使用。
    
    </summary>
    
      <category term="核心命令" scheme="https://kkutysllb.cn/categories/%E6%A0%B8%E5%BF%83%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Linux" scheme="https://kkutysllb.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>2019-04-19-中国移动NovoNet2020</title>
    <link href="https://kkutysllb.cn/2019/04/19/2019-04-19-%E4%B8%AD%E5%9B%BD%E7%A7%BB%E5%8A%A8NovoNet2020/"/>
    <id>https://kkutysllb.cn/2019/04/19/2019-04-19-中国移动NovoNet2020/</id>
    <published>2019-04-19T03:14:23.000Z</published>
    <updated>2019-04-19T03:54:35.196Z</updated>
    
    <content type="html"><![CDATA[<p>2015年7月，中国移动发布了NovoNet 2020愿景，推出下一代革新网络NovoNet，2016—2020年将成为中国移动SDN/NFV技术的关键部署期。中国移动希望利用SDN、NFV等新技术，构建一张资源可全局调度、能力可全面开放、容量可弹性伸缩、架构可灵活调整的新一代网络，满足“互联网+”、物联网等创新型业务对通信网络的需求。<a id="more"></a></p><p><img src="https://i.loli.net/2019/04/19/5cb946747cb72.jpg"></p><h2 id="中国移动网络重构战略"><a href="#中国移动网络重构战略" class="headerlink" title="中国移动网络重构战略"></a>中国移动网络重构战略</h2><p>中国移动NovoNet的核心发展理念是实现网络的“三化”和“三可”，即网络功能部署的软件化、虚拟资源的共享化、硬件基础设施的通用化，同时达到网络开放可编程、控制转发可解耦、功能编排可调度的能力，以便在移动网络、IP承载网络、传送网络、数据中心等领域实现网络和业务的虚拟化、软件化。</p><p>中国移动NovoNet的愿景是实现网络可编程、部署更灵活、调度更高效、网络更智能、服务更开放、成本更低廉的总体效果，通过SDN和NFV两大基础技术，在网络架构、运营管理和网络开放等层面持续优化网络和服务。</p><p><strong>网络架构</strong></p><p><img src="https://i.loli.net/2019/04/19/5cb9453ade41d.jpg"></p><blockquote><p><strong>1、 网络功能软件化</strong></p><p>将软件和硬件解耦，网元功能以软件部署在通用硬件平台上，实现业务的快速部署和升级，有利于运营商快速满足客户的业务需求。</p><p><strong>2、资源共享化</strong></p><p>借助NFV技术，实现硬件资源的通用化和虚拟资源的共享化，可以降低硬件件成本，实现资源的灵活配置和调度，有利于运营商开发创新业务并灵活部署。</p><p><strong>3、 网络可编程</strong></p><p>应用SDN技术，将网络控制与物理网络拓扑分离，实现网络可编程，有利于快速响应和满足用户的业务需求，最大化利用运营商的网络资源。</p></blockquote><p><strong>网络运营管理</strong></p><p>在2017全球未来网络发展峰会网络重构与转型论坛上，中国移动通信研究院副院长杨志强明确指出，5G和固定宽带业务将会成为运营商未来网络的核心应用，在开源软件和硬件的基础上进行自主研发和运营将成为新的主流运营模式。</p><p><img src="https://i.loli.net/2019/04/19/5cb9457cee35e.jpg"></p><blockquote><p><strong>1、集中控制</strong></p><p>网络功能的控制和调度通过软件完成，提升网络的调度优化能力，可以逐步实现面向全局最优的网络管理和简化网络运维。</p><p><strong>2、灵活调度</strong></p><p>实现业务部署、业务资源的动态调度，可快速、灵活调度网络资源，应对网络故障、突发事件等。</p><p><strong>3、绿色节能</strong></p><p>根据业务量需求动态调度网络资源，并可实现高效率集中控制，大幅提升网络资源的利用效率，构建绿色节能的通信网络。</p></blockquote><p><strong>网络服务</strong></p><p><img src="https://i.loli.net/2019/04/19/5cb9459d9a22a.jpg"></p><blockquote><p><strong>1、全面开放的服务</strong></p><p>提供全面的开放能力，构建与第三方业务开发者合作共赢的生态环境，全面服务“互联网+”。</p><p><strong>2、高效敏捷的服务</strong></p><p>具备完善的业务部署和调度能力，能够有效疏导网络流量、对业务提供完善的生命周期管理能力，支持业务的快速迭代、灵活部署、高效使用。</p><p><strong>3、按需调度的服务</strong></p><p>计算、存储、网络资源可全局调度，网络可动态编程，可根据用户、业务的需求动态调配资源。</p></blockquote><h2 id="中国移动网络重构目标"><a href="#中国移动网络重构目标" class="headerlink" title="中国移动网络重构目标"></a>中国移动网络重构目标</h2><p>中国移动将SDN/NFV作为网络重构的技术基础，实现基础设施云化、网元功能软件化以及运营管理智能化。未来网络的核心是通过SDN/NFV的引入，实现网络的软件化、资源池化、集中控制、灵活的编排与调度，构建云化的部署形态、智能化的网络调度、全局化的网络编排管理。</p><blockquote><p>（1）引入网络功能虚拟化（NFV）技术，采用IT通用服务器构建资源池，电信设备软硬解耦，以软件形成电信云，并支撑内容分发、边缘计算等。</p><p>（2）引入软件定义网络（SDN）技术，采用控制转发分离和路由集中计算，实现网络灵活、智能调度和网络能力的开放。</p><p>（3）引入协同编排技术，实现跨领域、端到端的全网资源、网元和流量流向的管理编排与调度。</p></blockquote><p>中国移动网络重构主要包括节点重构、架构重构、网元功能重构以及网络管理与业务运营重构四个方面。</p><p><img src="https://i.loli.net/2019/04/19/5cb945d6c35ee.jpg"></p><p><strong>节点重构</strong></p><p>构建云化数据中心，替代传统的核心网机房。云化数据中心采用标准化和微模块方式构建，易于快速复制部署，是电信云的基本组件和满足电信网络要求的关键基础设施，可以承载各类虚拟化的电信类软件应用。</p><blockquote><p>① 标准化的组网：以电信标准为基准的更为严格的网段隔离和网络平面划分原则，业务、管理、基础设施平面独立。</p><p>② 标准化的基础设施：硬件采用通用的X86硬件架构，增强性能要求和电信级管理要求；以统一的云操作系统支持统一的虚拟层指标要求；以电信级增强的OpenStack/VIM实现云资源的管理和分配。</p><p>③ 统一的管理编排体系：以整合的NFVO和SDN编排器和控制器作为统一的管理编排体系。</p></blockquote><p><strong>架构重构</strong></p><blockquote><p>① 构建基础设施资源池：分布式部署云化数据中心，形成基础设施资源池，承载不同的网络功能。</p><p>② 控制功能集中化：网络控制功能集中在核心云数据中心。</p><p>③ 媒体面下沉：靠近接入点设置边缘云数据中心，将大流量的媒体内容调度到网络边缘，实现快速疏导，提升用户体验。</p></blockquote><p><strong>网元功能重构</strong></p><p>通过基于服务的网络架构、切片、控制转发分离等，结合云化技术，实现网络的定制化、开放化、服务化，支持大流量、大连接和低时延的万物互联需求。</p><blockquote><p>① 用户面功能可实现灵活部署和独立扩缩容，采用集中式部署支持广域移动性和业务连续性，采用网络边缘部署，实现流量本地卸载，支持端到端毫秒级时延，降低回传网络和集中式用户面的处理压力。</p><p>② 网络切片提供端到端资源隔离的逻辑专网，可基于行业用户的需求，实现专网专用，基于业务场景灵活组合网络功能，灵活扩缩容，功能扩展敏捷。</p><p>③ 固网宽带业务控制设备通过转发控制分离，应对固网发展中面临的运维复杂、资源利用率低及业务开通慢等挑战。</p></blockquote><p><strong>网络管理与业务运营重构</strong></p><p>构建下一代网络编排器，实施对网络资源池的管理，完成网络和网元部署以及生命周期管理，协调SDN控制器完成网络的统一调度，实现业务的统一编排和对外开放。</p><h2 id="中国移动网络重构研发与实践"><a href="#中国移动网络重构研发与实践" class="headerlink" title="中国移动网络重构研发与实践"></a>中国移动网络重构研发与实践</h2><p>为了验证NovoNet的理念，中国移动已开展了相关研发和测试，包括研发SDN应用和控制器、SDN交换机、多厂家vIMS、vEPC软硬件解耦测试及MANO实验室验证、基于SDN网元功能重构的EPC原型验证、三层解耦的Nanocell网关测试等实验室验证。同时，中国移动也在数据中心、RCS、IMS、SPTN等领域开展了现网的试点及试商用的探索。NovoNet试验网由陕西、安徽、山东、河北、浙江、广东6个省组成，试验网的每个节点均构建两层云数据中心，用全局的编排器实现全网资源和网络的编排调度，以统一的资源池支持数据中心SDN、广域网SDN、SPTN、固网宽带、物联网、VoLTE、vCDN等多业务环境。</p><p><img src="https://i.loli.net/2019/04/19/5cb9461d0f8dd.jpg"></p><p>基于NovoNet的发展理念，中国移动加快推动SDN/NFV开源开放和相关产业发展，积极参与相关标准组织的项目推进。从2013年开始，中国移动牵头推动成立了Carrier Grade SDN工作组并任主席，参与无线和移动、光传送网、北向接口工作组标准化工作。2014年5月，中国移动与华为联合发起3GPP第一个NFV虚拟网络管理研究项目，并得到23家单位的支持。中国移动在SA1牵头发起Service Chaining立项，研究Gi-LAN场景业务链的场景和需求。2014年9月，中国移动联合国际运营商和厂商发起成立开源组织OPNFV，并出任董事会要职。2016年9月，中国移动加入领先的开源可编程、软件定义网络平台OpenDaylight项目，并利用该平台和OpenStack在其NovoDC项目中部署企业私有云服务产品。</p><p>2014年，中国移动完成7家厂商的OpenStack+SDN数据中心解决方案测试，以及2家厂商的广域网方案测试。2015年，中国移动成立Open NFV实验室，引入了15个合作厂商，进行三层解耦测试，搭建云数据中心平台，就NFV部署展开了相关实践。目前，实验室和外场均已按计划开展三层解耦的集成和测试、OPNFV开源平台测试，已搭建了多套基于多厂家NFV组件互操作的云数据中心平台，可模拟核心云数据中心和边缘云数据中心。</p><p>2015年，中国移动完成业界首次SDN+NFV的面向商用外场测试，在中国移动自有数据中心采用该架构进行了国内第一次比较全面的组合测试。</p><p><img src="https://i.loli.net/2019/04/19/5cb9463b68c48.jpg"></p><blockquote><p>① 在VoLTE和vIMS方面，中国移动进行了NFV实践，2015年-2019年连续5年在陕西、安徽、河北、广东、浙江和山东共6个城市验证了3个系统厂商以及自研产品的核心网云化的快速上线、弹性伸缩、网络快速更新等能力。</p><p>② 在虚拟化RCS（Rich Comunication Suite，富媒体通信套件）方面，中国移动融合通信业务平台（新消息、VoWiFi、业务管理功能）基于NFV架构进行部署，采用软硬件解耦方案，硬件由惠普和思科提供，中兴提供虚拟层和虚拟网元功能并完成系统集成，目前已在中国南北基地进行部署商用。</p><p>③ 在Nanocell商用方面，2016年中国移动基于NFV的4G一体化小基站（Nanocell）开始部署商用。</p></blockquote><h2 id="中国移动网络重构小结"><a href="#中国移动网络重构小结" class="headerlink" title="中国移动网络重构小结"></a>中国移动网络重构小结</h2><p>NovoNet是中国移动面向2020年的网络愿景和行动计划，NovoNet的目标形态是通过NFV和SDN技术的结合，打造以DC为部署核心、以MANO/SDN控制器体系为管理控制核心、以虚拟化和软件化实现网元功能、以SDN技术实现网络灵活调度的电信云。NovoNet是中国移动下一代网络发展的愿景，也是中国移动下一代网络发展的重大项目和平台，是中国移动对未来网络的重新定义。</p><p>标准化和开源系统是SDN和NFV发展的两个重要基石，国际合作和产业推进是NovoNet发展的助推器。中国移动正面向未来网络发展的方向，围绕着NovoNet的引入策略、技术攻关、试验验证、产业推进、测试认证五个方面全面展开工作，以开放共赢的理念从顶层设计、标准推动、开源开放等多个层面全面推动产业发展，积极构建NovoNet试验网，推动NovoNet网络技术和管理成熟。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2015年7月，中国移动发布了NovoNet 2020愿景，推出下一代革新网络NovoNet，2016—2020年将成为中国移动SDN/NFV技术的关键部署期。中国移动希望利用SDN、NFV等新技术，构建一张资源可全局调度、能力可全面开放、容量可弹性伸缩、架构可灵活调整的新一代网络，满足“互联网+”、物联网等创新型业务对通信网络的需求。
    
    </summary>
    
      <category term="NFV基础" scheme="https://kkutysllb.cn/categories/NFV%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="电信云" scheme="https://kkutysllb.cn/tags/%E7%94%B5%E4%BF%A1%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>2019-04-19-电信云落地过程若干问题</title>
    <link href="https://kkutysllb.cn/2019/04/19/2019-04-19-%E7%94%B5%E4%BF%A1%E4%BA%91%E8%90%BD%E5%9C%B0%E8%BF%87%E7%A8%8B%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/"/>
    <id>https://kkutysllb.cn/2019/04/19/2019-04-19-电信云落地过程若干问题/</id>
    <published>2019-04-19T02:50:12.000Z</published>
    <updated>2019-04-19T07:54:09.273Z</updated>
    
    <content type="html"><![CDATA[<p>NFV技术从诞生起，从根本上来说就是为了解决运营商网络演进中部署成本高，迭代更新慢，架构僵化等痛点问题。同时，在引入NFV技术前，旧有产业链相对单一，核心成员主要包括设备制造商、芯片制造商等，而NFV引入后拉长了整体通信产业链条，传统设备制造商面临严峻的挑战，原本软硬件一体化设备销售模式被拆解为通用硬件、虚拟化平台和网元功能三部分销售模式。这也直接决定了运营商期望的多层解耦部署模式推行困难。<a id="more"></a>同时，在NFV的转发性能提升、MANO管理模式选型、VNFM选型和NFVO部署等方面也多多少少存在影响电信云落地的问题。</p><h2 id="NFV部署模式选型"><a href="#NFV部署模式选型" class="headerlink" title="NFV部署模式选型"></a>NFV部署模式选型</h2><p>NFV通过软硬件解耦，使得网络设备开放化，软硬件可以独立演进，避免厂家锁定。基于NFV分层解耦的特性，根据软硬件解耦的开放性不同，可将集成策略分为单厂家、共享资源池、硬件独立和三层全解耦4种方案，如下图所示。</p><p><img src="https://i.loli.net/2019/04/19/5cb937b669bc5.jpg" alt></p><ul><li><strong>方案1：</strong>单厂家方案，优点就是可以实现快速部署，整体系统的性能、稳定性与可靠性都比较理想，不需要进行异构厂商的互通测试与集成。缺点是与传统网络设备一样，存在软硬件一体化和封闭性问题，难以实现灵活的架构部署，不利于实现共享；与厂商存在捆绑关系，不利于竞争，会再次形成烟囱式部署，总体成本较高，也不利于自主创新以及灵活的迭代式部署升级。目前，中国电信的4G/VoLTE/IMS网络就是采用这种方式，在短期内对中国移动的业务发展形成较大压力。</li><li><strong>方案2：</strong>倾向于IT化思路，选择最好的硬件平台和虚拟机产品，要求上层应用向底层平台靠拢。只对VNF与NFVI层解耦，VNF能够部署于统一管理的虚拟资源之上，并确保功能可用、性能良好、运行情况可监控、故障可定位；不同供应商的VNF可灵活配置、可互通、可混用、可集约管理。其中，VNFM与VNF通常为同一厂商（即“专用VNFM”），这种情况下VNF与VNFM之间的接口不需标准化；特殊场景下采用跨厂商的“VNFM”（即“通用VNFM”）。VMware的解决方案就是典型的方案二厂商A的定位，考虑到中国移动苏州研发中心与VMware的战略合作情况，可以预期不远的将来中国移动的NFV网络架构中会出现类似部署方案。</li><li><strong>方案3：</strong>倾向于电信思路，通用硬件与虚拟化层软件解耦，基础设施全部采用通用硬件，实现多供应商设备混用；虚拟化层采用商用/开源软件进行虚拟资源的统一管理。可以由电信设备制造商提供所有软件，只是适配在IT平台上。目前，中国移动大区集中化网络建设就是采用此部署方案。</li><li><strong>方案4：</strong>全解耦的好处是可以实现通用化、标准化、模块化、分布式部署，架构灵活，而且部分核心模块可选择进行定制与自主研发，也有利于形成竞争，降低成本，实现规模化部署；不利的地方是需要规范和标准化，周期很长，也需要大量的多厂商互通测试，需要很强的集成开发能力，部署就绪时间长，效率较低，后续的运营复杂度高，故障定位和排除较为困难，对运营商的运营能力要求较高。该模式是中国移动一直不遗余力推广的模式，目前在陕西移动已初步完成苏研VIM+分布式存储、华为VNFM和研究院NFVO+的标准三层部署模式验证，并打通了标准三层组网下FirstCall。</li></ul><p>另外，以上各方案都涉及MANO的解耦，涉及运营商自主开发或者第三方的NFVO与不同厂商的VNFM、VIM之间的对接和打通，屏蔽了供应商间的差异，统一实现网络功能的协同、面向业务的编排与虚拟资源的管理。但是，NFVO+的解耦目前还停留在实验验证阶段，在中国移动的电信云一阶段还是采用NFVO与VNFM同厂商捆绑的模式。</p><h2 id="NFV转发性能的提升"><a href="#NFV转发性能的提升" class="headerlink" title="NFV转发性能的提升"></a>NFV转发性能的提升</h2><p>NFV设计的初衷是针对部分低转发流量类业务功能，x86服务器在配备高速网卡（10Gbit/s）后，业务应用不经特殊优化，基本也可以满足大多数低速率转发业务的处理要求（即使后续随着SDN技术的推动，引入了40Gbit/s的高速转发能力，但目前也只是实验验证阶段，并未实际部署）。</p><p>传统硬件网元能够通过专用芯片实现高转发性能，而x86环境下的虚拟化网元尚不具备万兆以上端口的小包线速转发能力，在同等业务量的情况下，虚拟化网元和传统设备相比存在一定的性能差距。x86服务器采用软件转发和交换技术，报文在服务器各层面间传递，会受到CPU开销等多方面因素的影响，因此服务器的内部转发性能是NFV系统的主要瓶颈。</p><p>NFV中的网络业务应用运行于服务器的虚拟化环境中，单个应用业务流量的收发要经过虚拟化层、服务器I/O通道、内核协议栈等多个处理流程，而多个应用业务之间又可以用复杂的物理或虚拟网络相连接。因此，NFV系统的整体性能取决于单服务器转发性能与业务组链转发性能两个方面。如下所示：</p><p><img src="https://i.loli.net/2019/04/19/5cb939697812d.jpg"></p><p>业务应用流量的收发I/O通道依次包括物理网卡、虚拟交换机、虚拟网卡3个环节（见上图左半部分）；从软件结构上看，报文的收发需要经过物理网卡驱动、宿主机内核网络协议栈、内核态虚拟交换层、虚拟机网卡驱动、虚拟机内核态网络协议栈、虚拟机用户态应用等多个转发通道（见上图右半部分），存在着海量系统中断、内核上下文切换、内存复制、虚拟化封装/解封等大量CPU开销操作过程。</p><p>影响NFV转发性能的主要因素整理如下：</p><p><strong>1. 网卡硬件中断</strong></p><p>目前大量流行的PCI/PCIe（Peripheral Component Interconnect，外设部件互连标准/PCI-Express）网卡在收到报文后，一般采用DMA（Direct Memory Access，直接存储器存取）方式直接写入内存并产生CPU硬件中断，在低速转发应用中此方法十分有效。</p><p>但是，当网络流量激增时，CPU的大部分时间阻塞于中断响应。在多核系统中，可能存在多块网卡绑定同一个CPU核的情况，使其占用率达到100%。中断处理方式在低速网络I/O场景下非常有效。然而，随着高速网络接口等技术的迅速发展，10Gbit/s、40Gbit/s甚至100Gbit/s的网络端口已经出现。随着网络I/O速率的不断提高，网卡面对大量高速数据分组引发频繁的中断，中断引起的上下文切换开销将变得不可忽视，造成较高的时延，并引起吞吐量下降。因此，网卡性能改进一般采用减少或关闭中断（如轮询取代中断、零复制技术、大页内存技术等）、多核CPU负载均衡等优化措施。</p><p><strong>2. 内核网络协议栈</strong></p><p>在Linux或FreeBSD系统中，用户态程序调用系统套接字进行数据收发时，会使用内核网络协议栈。这将产生两方面的性能问题：一是系统调用导致的内核上下文切换，会频繁占用CPU周期；二是协议栈与用户进程间的报文复制是一种费时的操作。</p><p>NFV系统中，业务应用报文处理从物理网卡到业务应用需要完成收发操作各1次，至少经过4次上下文切换（宿主机2次以及VM内2次）和4次报文复制。将网络协议栈移植到用户态是一种可行的思路，但这种方法违反了GNU协议。GNU是GNU GPL（GNU General Public License，通用公共许可证）的简称，Linux内核受GNU GPL保护，内核代码不能用于Linux内核外。因此，弃用网络协议栈以换取转发性能，是唯一可行的办法，但需要付出大量修改业务应用代码的代价。</p><p><strong>3. 虚拟化层的封装效率</strong></p><p>业务应用中存在两类封装：服务器内部的I/O封装和网络层对流量的虚拟化封装。前者是由于NFV的业务应用运行于VM中，流量需要经历多次封装/解封装过程，包括：宿主机虚拟化软件对VM的I/O封装、虚拟交换机对端口的封装、云管理平台对虚拟网络端口的封装；后者是为实现NFV用户隔离，在流量中添加的用户标识，如VLAN、VxLAN（Virtual Extensible Local Area Network，可扩展虚拟局域网）等。这两类封装/解封均要消耗CPU周期，会降低NFV系统的转发效率。</p><p><strong>4. 业务链网络的转发效率</strong></p><p>NFV的业务链存在星形和串行两种组网方式，如下图所示。</p><p><img src="https://i.loli.net/2019/04/19/5cb939e34d89f.jpg"></p><p>星形连接依赖于物理网络设备的硬件转发能力，整体转发性能较优，但当应用的数量较大时，会消耗大量网络设备端口。因此，在业务链组网范围不大时，如在IDC内部，为简化组网和节约端口，更多地采用串行连接。</p><p>当串行连接时，NFV控制器需要在多个业务应用中选择合适位置的应用进程或进程组来处理流量，以均衡各应用负荷并兼顾业务链网络性能。不合适的负载均衡算法会造成流量在不同进程组的上下行链路之间反复穿越，严重降低业务链网络的带宽利用率。</p><p><strong>5. 其他开销</strong></p><p>（1）缓存未命中开销：缓存是一种能够有效提高系统性能的方式，然而，由于设计的不合理造成频繁的缓存未命中，则会严重削弱NFV数据平面的性能。</p><p>（2）锁开销：当多个线程或进程需要对某一共享资源进行操作时，往往需要通过锁机制来保证数据的一致性和同步性，而加锁带来的开销会显著降低数据处理的性能。</p><p>（3）上下文切换开销：NFV的扩展需要多核并行化的支持，然而在该场景下，数据平面需要进行资源的分配调度，调度过程中涉及多种类型的上下文切换。在网卡中断、系统调用、进程调度与跨核资源访问等上下文切换过程中，操作系统均需要保存当前状态，而这一类的切换开销往往相当昂贵，严重影响系统性能。</p><p>以上3种开销对于NFV转发性能的影响较大，在实际的转发过程中，开销不止这3种。</p><p>针对以上影响转发性能的挑战，NFV在落地过程引入不同开源技术进行应对，具体的实现原理会在第二部分《NFV关键技术》中详细阐述，这里只是做一个简单的介绍，使初学者有个概念性的了解。</p><p><strong>1. 轮询取代中断</strong></p><p>作为I/O通信的另一种方式，轮询不存在中断所固有的开销。以网卡接收分组为例，在轮询模式下，系统会在初始化时屏蔽收发分组中断，并使用一个线程或进程来不断检测收取分组描述符中的收取分组成功标志是否被网卡置位，以此来判断是否有数据分组。整个收取过程没有发生上下文切换，因此也就避免了相应的开销。</p><p>当I/O速率接近CPU速率时，中断的开销变得不可忽略，轮询模式的优势明显；相反，如果数据吞吐率很低，中断能有更好的CPU利用率，此时不宜采用轮询模式。基于以上分析，针对网络流量抖动较大的场景，可以选用中断与轮询的混合模式，即在流量小时使用中断模式，当遇到大流量时切换为轮询模式。目前Linux内核与DPDK都支持这种混合中断轮询模式。</p><p><strong>2. 零复制技术</strong></p><p>零复制技术主要用以避免CPU将数据从一个内存区域复制到另一个内存区域带来的开销。在NFV数据平面操作的场景下，零复制指的是除网卡将数据DMA复制进内存外（非CPU参与），从数据分组接收到应用程序处理数据分组，整个过程中不存在数据复制。零复制技术对于高速网络而言是十分必要的。</p><p>DPDK、Netmap、PF-ring等高性能数据分组处理框架都运用了零复制技术，可以实现在通用平台下高效的网络处理，大幅提升单服务器内的报文转发性能。进一步地，DPDK不仅实现了网卡缓冲区到用户空间的零复制，还提供虚拟环境下的虚拟接口、兼容OpenvSwitch虚拟交换机、专为短小报文提供的hugepage访问机制等实用技术。</p><p>上述开源方案能很好地满足NFV中DPI（Deep Packet Inspection，深度数据包检测）、防火墙、CGN（Carrier-Grade NAT <network address translation>，运营商级网络地址转换）等无需协议栈的网络业务功能，但存在着大量改写原有业务应用套接字的问题，应用中需要在性能提升与代码改动之间进行取舍。</network></p><p><strong>3. 高效虚拟化技术</strong></p><p>目前在NFV领域常用的高效虚拟化技术大致可以归为以下两类。</p><p><strong>（1）基于硬件的虚拟化技术</strong></p><p>I/O透传与SR-IOV是两种经典的虚拟化技术。I/O透传指的是将物理网卡直接分配给客户机使用，这种由硬件支持的技术可以达到接近宿主机的性能。不过，由于PCIe设备有限，PCI研究组织提出并制定了一套虚拟化规范——SR-IOV，即单根I/O虚拟化，也就是一个标准化的多虚机共享物理设备的机制。完整的带有SR-IOV能力的PCIe设备，能像普通物理PCIe设备那样被发现、管理和配置。</p><p>SR-IOV主要的应用还是在网卡上，通过SR-IOV，每张虚拟网卡都有独立的中断、收发队列、QoS等机制，可以使一块物理网卡提供多个虚拟功能（VF），而每个VF都可以直接分配给客户机使用。</p><p>SR-IOV使虚拟机可以直通式访问物理网卡，并且同一块网卡可被多个虚拟机共享，保证了高I/O性能，但SR-IOV技术也存在一些问题。由于VF、虚端口和虚拟机之间存在映射关系，对映射关系的修改存在复杂性，因此除华为外，大部分厂商目前还无法支持SR-IOV场景下的虚拟机迁移功能。另外，SR-IOV特性需要物理网卡的硬件支持，并非所有物理网卡都提供支持。</p><p><strong>（2）半虚拟化技术</strong></p><p>半虚拟化无需对硬件做完全的模拟，而是通过客户机的前端驱动与宿主机的后端驱动一同配合完成通信，客户机操作系统能够感知自己处在虚拟化环境中，故称为半虚拟化。由于半虚拟化拥有前后端驱动，不会造成VM-exit，所以半虚拟化拥有更高的性能。主流虚拟化平台Xen就使用了半虚拟化的驱动，半虚拟化比起SR-IOV的优势在于支持热迁移，并且可以与主流虚拟交换机对接。但是，在大流量转发场景下，前后端驱动中Domain0也是最大的瓶颈。</p><p><strong>4. 硬件分流CPU能力</strong></p><p>CPU具有通用性，需要理解多种指令，具备中断机制协调不同设备的请求，因此CPU拥有非常复杂的逻辑控制单元和指令翻译结构，这使得CPU在获得通用性的同时，损失了计算效率，在高速转发场景下降低了NFV的转发性能。</p><p>业界普遍采用硬件分流方法来解决此问题，CPU仅用于对服务器进行控制和管理，其他事务被卸载到硬件进行协同处理，降低CPU消耗，提升转发性能。</p><p>网卡分流技术是将部分CPU事务卸载到硬件网卡进行处理，目前大多数网卡设备已经能够支持卸载特性。网卡卸载的主要功能有：数据加解密、数据包分类、报文校验、有状态流量分析、Overlay报文封装和解封装、流量负载均衡，以及根据通信协议最大传输单元限制，将数据包进行拆分或整合。</p><p>除此之外，CPU+专用加速芯片的异构计算方案也是一种硬件分流思路。异构计算主要是指使用不同类型指令集（X86、ARM、MIPS、POWER等）和体系架构的计算单元（CPU、GPU、NP、ASIC、FPGA等）组成系统的计算方式。在NFV转发性能方面，使用可编程的硬件加速芯片（NP、GPU和FPGA）协同CPU进行数据处理，可显著提高数据处理速度，从而提升转发性能。</p><p><strong>5．整体优化方案DPDK</strong></p><p>PCI直通、SR-IOV方案消除了物理网卡到虚拟网卡的性能瓶颈，但在NFV场景下，仍然有其他I/O环节需要进行优化，如网卡硬件中断、内核协议栈等。开源项目DPDK作为一套综合解决方案，对上述问题进行了优化与提升，可以应用于虚拟交换机和VNF。DPDK是Intel提供的数据平面开发工具集，为Intel处理器架构下用户空间高效的数据包处理提供库函数和驱动的支持。它不同于Linux系统以通用性设计为目的，而是专注于网络应用中数据包的高性能处理。有关DPDK的详细介绍，大家可参见《深入浅出DPDK》这本书。</p><p>一般来说，服务器上的每个CPU核会被多个进程/线程分时使用，进程/线程切换时，会引入系统开销。DPDK支持CPU亲和性技术，优化多核CPU任务执行，将某进程/线程绑定到特定的CPU核，消除切换带来的额外开销，从而保证处理性能。</p><p>同时，DPDK支持巨页内存技术。一般情况下，页表大小为4KB，巨页技术将页表尺寸增大为2MB或1GB，使一次性缓存内容更多，有效缩短查表消耗时间。同时，DPDK提供内存池和无锁环形缓存管理机制，加快了内存访问效率。</p><p>报文通过网卡写入服务器内存的过程中，会产生CPU硬件中断，在数据流较大的情况下，硬件中断会占用大量时间。DPDK采用轮询机制，跳过网卡中断处理过程，释放了CPU处理时间。服务器对报文进行收发时，会使用内核网络协议栈，由此产生内核上下文频繁切换和报文拷贝问题，占用了CPU周期，消耗了处理时间。DPDK使用户态进程可直接读写网卡缓冲区，旁路了内核协议栈处理。</p><p>DPDK以用户数据I/O通道优化为基础，结合Intel虚拟化技术（主要是VT-d技术）、操作系统、虚拟化层与虚拟交换机等多种优化方案，形成了完善的转发性能加速架构，并开放了用户态API供用户应用程序访问。DPDK已逐渐演变为业界普遍认可的完整NFV转发性能优化技术方案。但目前DPDK还无法达到小包线速转发，仍需进行性能提升研究和测试验证工作。</p><h2 id="运营商如何推动三层解耦落地？"><a href="#运营商如何推动三层解耦落地？" class="headerlink" title="运营商如何推动三层解耦落地？"></a>运营商如何推动三层解耦落地？</h2><p>在NFV方面，解耦是首当其冲的问题，目前业界有不解耦、软硬件解耦和三层解耦这3种思路，其中软硬件解耦又分为共享虚拟资源池和硬件独立两种方案，不同方案的对比介绍在本文的NFV部署模式部分已有介绍，这里不再赘述。</p><p>不解耦无法实现硬件共享，运营商依赖厂商，网络开放能力弱，不支持自动化部署，显然不符合NFV技术的初衷；而仅硬件解耦不支持多厂商VNF在同一云平台部署，运营商仍旧依赖厂商；三层解耦可以解决上述问题，但其涉及多厂商垂直互通，系统集成和维护难度大，部署周期长。NFV三层解耦要求在部署NFV时不同组件由不同的厂商提供，需要比传统电信网络更复杂的测试验证、集成和规划部署工作。</p><p>NFV分层解耦的方式由于缺乏主集成商（苏研努力的目标，陕西目前试点的主要目的）和完整验证，距离开放的全解耦目标还有相当距离，运营商会面临一定的运维风险和技术挑战。NFV分层解耦的技术挑战主要有以下几点：</p><p>（1）不同厂商的硬件设备之间存在管理和配置的差异，如存储设备管理配置、安全证书、驱动、硬件配置等方面的问题，会导致统一资源管理困难、自动化配置失效；另一方面，各类VNF和虚拟化软件部署于不同的硬件设备上，在缺乏预先测试验证的情况下，硬件板卡或外设之间，如PCIe网卡、RAID卡硬件、BIOS，存在兼容性不一致问题。因此，NFV三层解耦规模商用前，需要运营商细化服务器安全证书、硬件选型方面的规范要求，重点关注硬件可靠性和兼容性问题，在商用前进行软硬件兼容性和可靠性验证。以上问题需要通过大量的适配、验证和调优来解决。</p><p>（2）不同基础软件之间存在兼容性问题，如操作系统与驱动层之间、虚拟交换机与操作系统之间、虚拟化软件与VNF之间，不同的模块和不同的版本，以及不同的配置参数、优化方法，都会造成性能、稳定性、兼容性的较大差异，有待进一步测试与验证。为此，需要尽量减少虚拟化层类型，适时引入自主研发虚拟化层软件，减少持续不断的三层解耦测试工作量。采用集中的云管平台（统一VIM），降低NFVO与VIM集成的复杂度。</p><p>（3）分层之后，从NFV各层之间的接口定义与数据类型，到层内功能的实现机制，乃至层间的协同处理均需要运营商去推动和完善。如VNF在发生故障时，涉及VM迁移与业务倒换机制以及NFVI、NFVO和VIM的处理流程；又如VNF对配置文件管理和存储设备使用不当，同样会导致VM实例化失效。因而，在VNF多厂家集成过程中，集成方或者运营商需要需要有角色对问题定界、定位进行裁决，在集成和运维的过程中，对技术问题进行端到端的管理，对各层的功能进行详细定义或者详细规范。</p><p>（4）NFV系统集成涉及多厂商、多软硬组件的高度集成，由于虚拟化环境的存在，在初期的测试验证、中期的系统部署、后期的运维过程中，进行系统评测与管理部署都较为困难。这就要求运营商在提升DevOps能力的基础上，依托持续集成与持续部署和运维自动化技术，形成NFV系统的持续集成、测试和部署能力，大白话就是要求运营商亟待需要提升自主开发、自主集成和自主测试能力。同时，MANO架构需要全网统一。由于目前VNFM通常与VNF是绑定的厂商组件，而实际上真正的VIM也是厂商提供的，因此VNFM、VIM仍然是与VNF、NFVI就近部署。所以需要尽早明确NFVO的架构（例如，采用集团NFVO+区域NFVO两层架构），明确VNFM和VIM的跨专业、跨地域部署能力和部署位置，明确已部署的云管平台与VIM架构的关系，以及已有的EMS、NMS与VNFM架构的关系。</p><p>对于运营商来说，三层解耦会是一个较长的过程，与厂商的博弈也需要时间，再加上自主能力（研发、测试、集成）也需要时间，在实现最终目标之前可以先选择过渡方案，例如厂商一体化方案（不适合作为商业化规模部署方案）、部分解耦方案（硬件与软件解耦、MANO中的NFVO解耦出来）等，在试点和小规模部署过程中培育能力，逐渐实现最终的解耦目标，并在解耦基础上逐步提升自主研发比例，增强对网络NFV化的掌控力。</p><h2 id="MANO管理模式利弊分析"><a href="#MANO管理模式利弊分析" class="headerlink" title="MANO管理模式利弊分析"></a>MANO管理模式利弊分析</h2><p>EISI NFV对MANO的资源管理提出直接模式和间接模式两种方案。NFV-MANO允许NFVO和VNFM两者都能管理VNF生命周期所需的虚拟化资源，直接和间接是相对VNFM而言的。</p><p>（1）直接（Direct）模式：VNFM直接通过VIM分配VNF生命周期管理所需的虚拟化资源。VNFM向NFVO提出对VNF的生命周期管理操作进行资源授权，NFVO根据操作请求及整体资源情况返回授权结果；VNFM根据授权结果直接与VIM交互完成资源的调度（分配、修改、释放等）；VNFM向NFVO反馈资源变更情况。如下图所示：</p><p><img src="https://i.loli.net/2019/04/19/5cb93a7c84822.jpg"></p><p>（2）间接（Indirect）模式：VNFM向NFVO提出对VNF的生命周期管理操作进行资源授权，NFVO根据操作请求及整体资源情况返回授权结果；VNFM根据授权结果向NFVO提出资源调度（分配、修改、释放等）请求，NFVO与VIM交互完成实际的资源调度工作；NFVO向VNFM反馈资源变更情况。如下图所示：</p><p><img src="https://i.loli.net/2019/04/19/5cb93abc21fdc.jpg"></p><p>总体而言，两者都由VNFM提供VNF生命周期管理。在执行VNF生命周期管理操作之前，无论该操作新增资源，还是修改或者释放已分配的资源，VNFM都需要向NFVO请求资源授权；资源容量和状态等信息由NVFO统一维护管理。两种模式的不同主要体现在：直接模式下，VNFM和NFVO都需要与VIM交互，将VIM的虚拟资源管理接口暴露给VNFM使用；间接模式下，VFNM不需要和VIM进行交互，NFVO需要提供VIM代理能力。</p><p>两种模式在架构、业务成效、性能、集成复杂度以及安全性方面的对比分析如下所示：</p><p><img src="https://i.loli.net/2019/04/19/5cb93adcf3f9a.jpg"></p><p>综合以上分析，从功能、落地部署、安全性、未来演进角度考虑，间接模式较好；性能方面，直接模式占优；系统集成复杂度两者相当。考虑网络的未来发展，从运营商对网络的自主掌控能力出发，要求厂商必须支持间接模式，以推进分层解耦、实现对虚拟资源的统一管控。</p><h2 id="VNFM如何选型？"><a href="#VNFM如何选型？" class="headerlink" title="VNFM如何选型？"></a>VNFM如何选型？</h2><p>通用VNFM和专用VNFM是ETSI定义的两种架构选项。</p><p>（1）通用VNFM：通用VNFM可以服务于不同类型或不同厂商提供的VNF，对它所管理的多种类型、多厂商VNF的操作没有依赖性，但它必须能够在VNF包中定义的不同VNF的特定脚本。按照管理要求，可能有多个通用VNFM，每个VNFM管理一定VNF的子集。在这种情况下，NFVO需要同时处理多个通用VNFM。下图展示了通用VNFM的架构。</p><p><img src="https://i.loli.net/2019/04/19/5cb93b2890c9a.jpg"></p><p>（2）专用VNFM：专用VNFM与它所管理的VNF之间具有依赖性，一般管理由同一厂商提供的VNF。NFV架构框架同时也允许一个或多个专用VNFM连接到单个NFVO。在VNF生命周期管理过程复杂，且一些管理特性与这些VNF紧耦合的场景下，就需要使用专用VNFM。下图展示了专用VNFM的架构。</p><p><img src="https://i.loli.net/2019/04/19/5cb93b5404b01.jpg"></p><p>两种架构选项具有相同的VNFM功能要求，如VNFD解析，获得部署VNF所需资源要求及所需部署的业务软件；NFVI告警与VNF告警关联、VNF弹性策略执行；VNF生命周期管理，包括实例化、查询、扩/缩容、终止等。但是，两种架构在技术实现难度、运维复杂度等方面却存在着差异。</p><p><img src="https://i.loli.net/2019/04/19/5cb93c4f9deb6.jpg"></p><h2 id="NFVO如何部署？"><a href="#NFVO如何部署？" class="headerlink" title="NFVO如何部署？"></a>NFVO如何部署？</h2><p>目前，ETSI NFV进一步细化了NFVO功能模块的具体功能要求。按照MANO规范，NFVO可以分解为网络服务编排（Network Service Orchestrator，NSO）和资源编排（Resource Orchestrator，RO）。网络服务生命周期的管理功能，即NSO功能；跨VIM的NFVI资源编排功能，即RO功能。NFVO作为MANO的一个功能实体，在部署时，可以有如下两种部署形态。</p><p><strong>1. NFVO功能不分解部署</strong></p><p>NFVO作为一个独立的实体部署，可采用级联的方式来部署。如下图所示，每个管理域可以被当作一个或多个数据中心，在该管理域中部署一套独立的NFVO，以及VNFMs、VIMs，用来管理该域中的网络服务。另外，再部署一套顶层NFVO，用来管理域间的网络服务，它并不管理下层管理域中的网络服务，不过它可以接收下层管理域中网络服务实例化、弹性伸缩，以及终止操作的请求，并将此请求直接传递给下层管理域中的NFVO，由下层管理域的NFVO来完成实际的操作。</p><p><img src="https://i.loli.net/2019/04/19/5cb93c79072b7.jpg"></p><p><strong>2. NFVO功能分解部署</strong></p><p>NFVO可以分为两个独立的实体来部署，NSO主要完成NS的生命周期管理，包括NS模板以及VNF包的管理，如下图所示。NSO不再关注资源的状态以及资源所在的管理域，仅关注资源的额度。RO主要完成管理域内资源的管理和编排，如资源的预留、分配、删除等操作，以及支持资源的使用率和状态的监控。</p><p><img src="https://i.loli.net/2019/04/19/5cb93c976dfb3.jpg"></p><p>NFVO功能不分解部署时，资源申请效率高；集成难度相对较低；若NFVO故障，则只会影响该NFVO管理域的业务和资源。NFVO分解后，VNFM访问或申请资源的效率会降低；如果RO出现故障，则只会影响该RO管理的资源；但是，一旦NSO出现故障，则将影响所有整个NFV的业务功能；NFVO分解为NSO、RO之后，或增加NSO-RO之间的接口，增加系统集成难度。</p><p>根据分析比较，在一定的业务规模下，将NFVO分解为NSO、RO难以带来明显的优势或收益，反而会导致性能降低、集成复杂。因此，建议NFVO采用不分解架构。另外，考虑后续的演进和发展，在技术架构上可将NSO和RO进行内部功能解耦，并实现微服务化，以增强未来NFVO部署的灵活性。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NFV技术从诞生起，从根本上来说就是为了解决运营商网络演进中部署成本高，迭代更新慢，架构僵化等痛点问题。同时，在引入NFV技术前，旧有产业链相对单一，核心成员主要包括设备制造商、芯片制造商等，而NFV引入后拉长了整体通信产业链条，传统设备制造商面临严峻的挑战，原本软硬件一体化设备销售模式被拆解为通用硬件、虚拟化平台和网元功能三部分销售模式。这也直接决定了运营商期望的多层解耦部署模式推行困难。
    
    </summary>
    
      <category term="NFV基础" scheme="https://kkutysllb.cn/categories/NFV%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="电信云" scheme="https://kkutysllb.cn/tags/%E7%94%B5%E4%BF%A1%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>2019-04-19-NFV网络参考架构</title>
    <link href="https://kkutysllb.cn/2019/04/19/2019-04-19-NFV%E7%BD%91%E7%BB%9C%E5%8F%82%E8%80%83%E6%9E%B6%E6%9E%84/"/>
    <id>https://kkutysllb.cn/2019/04/19/2019-04-19-NFV网络参考架构/</id>
    <published>2019-04-19T02:23:24.000Z</published>
    <updated>2019-04-19T02:41:03.284Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ETSI定义的NFV网络参考架构"><a href="#ETSI定义的NFV网络参考架构" class="headerlink" title="ETSI定义的NFV网络参考架构"></a>ETSI定义的NFV网络参考架构</h2><p>ETSI作为NFV的发起标准组织，于2015年年初发布了NFV参考架构等系列文稿，具体包括：用例文档、架构框架、虚拟化需求、NFV基础设施、NFV MANO、VNF、服务质量、接口、安全、PoC框架、最佳实践等内容。虽然ETSI NFV阶段成果不是强制执行的标准，但是得到了业界的普遍认可，已经成为了业界的事实标准。<a id="more"></a></p><p>目前，NFV标准框架已基本稳定，如下图所示。NFV标准框架主要包括NFV 基础设施、虚拟网络功能和NFV管理与编排（NFV Management and Orchestration，NFV MANO）。ETSI定义的NFV技术架构同当前网络架构（独立的业务网络+OSS系统）相比，NFV从纵向和横向上进行了解耦，<strong>纵向分为3层：基础设施层、虚拟网络层和运营支撑层。横向分为两个域：业务网络域和管理编排域。</strong></p><p><img src="https://i.loli.net/2019/04/19/5cb931ba78d7f.jpg" alt></p><p>​                                        <strong><em>VIM + NFVI 基本等同于OpenStack管理下的IaaS</em></strong></p><p><strong>NFVI</strong>包括各种计算、存储、网络等硬件设备，以及相关的虚拟化控制软件，将硬件相关的计算、存储和网络资源全面虚拟化，实现资源池化。NFVI物理基础设施可以是多个地理上分散的数据中心，通过高速通信网连接起来，实现资源池统一管理。</p><p><strong>VNF</strong>运行在NFVI之上。VNF旨在实现各个电信网络的业务功能，将物理网元映射为虚拟网元 VNF，VNF所需资源需要分解为虚拟的计算、存储、交换资源。VNF作为一种软件功能，部署在一个或多个虚机上，并由NFVI来承载。VNF之间可以采用传统网络定义的信令接口进行信息交互。VNF的性能和可靠性可通过负载均衡和HA等软件措施以及底层基础设施的动态资源调度来解决。</p><p><strong>EMS（Element Management System，网元管系统）</strong>可以管理VNF，厂商通常对原网管系统进行扩展，统一管理虚拟化和非虚拟化的网元。</p><p><strong>运营支撑层OSS/BSS</strong>，就是目前的OSS/BSS系统，需要为虚拟化进行必要的修改和调整。为了适应 NFV 发展趋势，未来的业务支撑系统（BSS)与运营支撑系统（OSS）将进行升级（中国移动目前正推出OSS4.0系统），实现与VNF Manager和网元编排管理的互通。</p><p><strong>NFV MANO（NFV Management and Orchestration，NFV管理与编排）</strong>负责对整个NFVI资源的管理和编排，业务网络和NFVI资源的映射和关联，OSS业务资源流程的实施等。MANO内部包括编排管理（Orchestrator）、虚拟化的网络功能管理（VNF Manager，VNFM）和虚拟化的基础设施管理（Virtualised Infrastructure Manager，VIM）3个实体，分别完成对NFVI、VNF和NS（Network Service，业务网络提供的网络服务）3个层次的管理。其中，Orchestrator编排管理NFV基础设施和软件资源，在NFVI上实现网络服务的业务流程和管理。VNFM实现VNF生命周期管理，如实例化、更新、查询和弹性等。VIM控制和管理VNF所需要的与算、存储和网络资源的管理和调度，即所谓的Cloud OS。</p><h2 id="NFVI到底是个什么鬼？"><a href="#NFVI到底是个什么鬼？" class="headerlink" title="NFVI到底是个什么鬼？"></a>NFVI到底是个什么鬼？</h2><p>NFVI能够同时为一个或多个VNF实例提供基础设施资源，并实现不同VNF资源的动态配置。ETSI对NFVI功能架构和接口进行了定义，将NFVI细分为<strong>计算域、管理域和网络域</strong>3个功能域。每个域自主管控，通过标准接口进行信息交互，协作实现对VNF的具体承载。</p><p><img src="https://i.loli.net/2019/04/19/5cb9322b40969.jpg" alt></p><ul><li><strong>计算域</strong>包括通用高容量服务器和存储设备。</li><li><strong>管理域</strong>包括各种Hypervisor，对硬件进行抽象以支撑软件应用在不同服务器之间的可移植性；为虚拟机VM分配计算域资源；为编排和管理系统提供管理界面，允许虚拟机VM的加载和监控。</li><li><strong>网络域</strong>包括所有的通用高容量交换机，这些交换机互联形成一个可配置网络，提供基础设施网络服务。</li></ul><p><strong>NFVI内部3个域之间接口示意如下图所示：</strong></p><p><img src="https://i.loli.net/2019/04/19/5cb932ab216a8.jpg" alt></p><p><img src="https://i.loli.net/2019/04/19/5cb932c91623b.jpg" alt></p><p>计算域包括各种服务器与存储设备，其作用是结合Hypervisor域的一个管理程序，负责VNF各个组件的需求，提供COTS计算和存储资源。概括地说，计算域提供与网络基础设施领域的接口，但其自身不支持网络连接。根据给定计算域的元素：服务器、存储和网络结构，各种接口可以被归类为：<strong>物理网络接口、内部和外部域接口、管理和编排接口。</strong></p><blockquote><p><strong>物理网络接口：</strong>有几种不同类型的设备接口可能被利用，这些接口包括以太网、光纤通道、无线接入（这几个接口是比较常用的，但不仅限于这3类）。</p><p><strong>内部和外部域接口：</strong>该部分主要是两个接口，一个是NFVI与VIM的内部接口，另一个是与VNF应用的外部接口。NFVI与VIM（Nf-Vi）的接口主要负责VIM与NFVI相连，被用作管理接口，是一个内部接口。而VIM被作为一个单独的外部服务，这样做既考虑了逻辑上的隔离，同时也顾及到安全方面的因素。Nf-Vi接口是唯一授权的NFV管理界面和交互接口，其管理组件就是VIM。同时，在NFVI内，Vl-Ha/CSr连接到外部计算域，包括所有的基础设施，是计算域和Hypervisor域之间的接口，该接口被Hypervisor/OS用于监控计算域内可用的物理资源。</p><p><strong>管理和编排接口：</strong>NFVI的编排和管理是严格通过Nf-Vi接口的。为了正常工作，应当有某种类型的接口，物理接口的类型并不重要，重要的是需要有一个专门的安全接口，该接口将被用来建立基础设施的鉴权和授权。除此接口外，每个底层域组件（如计算、存储、网络）都应当有相应的代理。</p></blockquote><p>Hypervisor域本身是抽象硬件和实现服务的软件环境，如启动/终止虚拟机，作用于策略、缩放、实时迁移和高可用性。仅当VIM被告知或者指示Hypervisor域的主要接口时，服务才能被启用。Hypervisor域的主要接口包括NF-Vi、Vi-Ha和Vn-NF接口，其内部结构如下图示。</p><p><img src="https://i.loli.net/2019/04/19/5cb9330668e87.jpg" alt></p><blockquote><p><strong>NF-Vi接口：</strong>对接VIM的接口，虚拟机监控程序服务请求需通过该接口。只有VIM或NFVO才能通过这些接口与Hypervisor交互。Hypervisor不得自主执行业务，除非是在VIM应用策略的范围内。</p><p><strong>Vi-Ha接口：</strong>通过该接口Hypervisor获取硬件信息，并创建虚拟机需要使用的虚拟硬件组件。</p><p><strong>Vn-NF接口：</strong>该接口是VM到VNF的逻辑接口。一个VNF由一个或多个虚拟机创建。虚拟机在本质上是软件运行某种函数、算法、应用，而忽略其类型、模型、实际物理单元的数量。</p></blockquote><p>网络域的主要功能包括：分布式VNF的虚拟网络功能组件之间进行通信的通道、不同VNF之间通信的通道、VNF编排和管理模块之间的通信通道、NFVI编排和管理功能模块之间的通信通道、VNFC远程部署的方案和现有运营商网络之间交互通信的方案。</p><p><img src="https://i.loli.net/2019/04/19/5cb9333ca3ab9.jpg" alt></p><p>网络域的网络架构应该提前设置好VNF的网络结构，同时提供足够的网络连接。为了实现上述功能，网络架构需要包含足够多的组件来提供网络域的功能。包含的组件如下：</p><blockquote><p>1）网络架构的寻址机制，可以有多于一种的寻址机制，同时该机制还包括地址定位和管理功能；</p><p>2）路由机制，该机制用来生成网络拓扑，并进行路由转发；</p><p>3）带宽定位机制；</p><p>4）OAM集合，用来检测可靠性、可用性、连接服务的完整性。</p></blockquote><p>网络域中的虚拟网络由NFVI中网络组件提供，通常在数据中心内部或数据中心之间使用使用L2或L3的overlay网络来实现。所谓的overlay网络，就是重叠在数据中心内部TOR/EOR交换机组成的物理网络之上的网络，通过在多个虚拟网络功能实体之间建立隧道来完成互联。</p><p>网络域的内部接口可以南北接口和东西接口，按类型分为管理协议接口、管理模块/信息接口、数据模型和流监控协议接口三类。南北向接口可以参见传统网络SNMP接口模型，通过MIB模块中的数据模块提供管理协议接口。新的南北向接口是NetConf接口，使用YANG数据模型，定义简单，支持多种协议，典型应用就是SDN控制器的管理。东西向接口主要分为前向关联和后向反射两种模式。前向关联模式主要用来探测服务故障，后向反射模式主要用来进行故障状态的上报和恢复检测。</p><p>网络域的外部接口主要有：不同网络资源之间的接口[Vi-Ha]/Nr，例如网络资源、端口资源之间就是采用这类接口；[Vn-Nf]/N接口用于VNF（虚拟网元）接入到虚拟网络的接口；Ha/CSr-Ha/Nr计算域、网络域与物理资源的接口；Ex-Nf是NFVI与现有网络之间的永久接口。</p><p>虚拟化场景下的逻辑组网如下</p><p><img src="https://i.loli.net/2019/04/19/5cb933788cc58.jpg" alt></p><ul><li><strong>虚拟层 DVS：</strong>虚拟分布式交换机，与物理交换机一样，构建起虚拟机之间的网络，并提供与外部网络互通的能力.</li><li><strong>接入层：</strong>划分为存储网络，业务网络和管理网络，各个网络层面间，通过划分不同的vlan将管理、业务、存储三个平面逻辑隔离。为简化组网提高组网可靠性，建议接入交换机采用堆叠方式</li><li><strong>汇聚层：</strong>接入交换机上行到汇聚层交换机，采用ETH-TRUNK上行至汇聚交换机，汇聚交换机堆叠之后，无需启用VRRP功能，如果需要汇聚交换机提供网关功能，则直接将VLANIF接口作为用户网关地址。建议采用集群方式。.</li><li><strong>核心层：</strong>汇聚交换机上行接入核心层交换机，核心交换机采用OSPF或者静态路由的方式同上层设备进行对接.建议采用集群方式。</li></ul><h2 id="虚拟网元层VNF"><a href="#虚拟网元层VNF" class="headerlink" title="虚拟网元层VNF"></a>虚拟网元层VNF</h2><p>虚拟网元功能VNF旨在通过虚拟化技术实现各种电信业务网络功能，将物理网元映射为虚拟网元VNF，VNF所需资源可以分解为虚拟的计算、存储和交换资源，由NFVI来承载。如下图所示：</p><p><img src="https://i.loli.net/2019/04/19/5cb933ea434ed.jpg" alt></p><p>ETSI NFV架构中，VNF是NFV总体架构的一个功能单元，通过接口参考点Vn-Nf和Ve-Vnfm，分别与NFVI模块和MANO 的VNFM模块进行信息交互。VNF以软件模块形式部署在NFVI提供的资源上，从而实现网络功能虚拟化。</p><p>VNF之间的接口指两个实体之间的交互点，这些实体可以是软硬件服务或者资源。软件接口将各个软件功能实体分开，它们被创建并用于软件实体之间的相互作用与交互，同时限制各软件实体之间的通信。ETSI和3GPP为VNF定义了以下5种接口：</p><p><img src="https://i.loli.net/2019/04/19/5cb93411aa116.jpg" alt></p><ul><li><strong>SWA-1接口：</strong>这是各种网络功能之间明确定义的通信接口，表示网络功能上信令或媒体的接口。SWA-1接口是在2个VNF，或者一个VNF和PNF，或者一个VNF和一个节点之间。一个VNF可以支持多个SWA-1接口。</li><li><strong>SWA-2接口：</strong>属于VNF内部接口，如VNFC到VNFC的通信。这些接口由VNF厂商定义，因此是私有接口。这些接口对底层虚拟化基础设施有明确要求，但对一个 VNF 而言用户是不可见的。SWA-2 接口利用底层的通信机制连接到SWA-5接口上网络连接模块。</li><li><strong>SWA-3接口：</strong>VNF与NFV管理和编排器间的接口，特别是与VNFM间的接口。管理接口用来为一个或多个 VNF 执行生命周期管理，SWA-3 接口可以使用IP/ L2连接。</li><li><strong>SWA-4接口：</strong>EM使用SWA-4接口与VNF通信，用于VNF的运行期的管理。</li><li><strong>SWA-5接口：</strong>对应VNF-NFVI接口，存在于每个VNF和底层NFVI之间的接口。每个不同的VNF依赖于一组不同的SWA-5接口提供的NFVI资源，如网络、计算、存储等。SWA-5接口描述了一种用于VNF的可部署实例的执行环境，是NFVI和VNF本身之间的所有子接口的抽象，SWA-5子接口为：通用计算功能、专用功能、存储、网络I/O。</li></ul><h2 id="NFV管理与编排层"><a href="#NFV管理与编排层" class="headerlink" title="NFV管理与编排层"></a>NFV管理与编排层</h2><p>在传统的网络中，网络功能实现常常与它们运行的架构、资源等紧紧联系在一起。NFV引入了一个新的虚拟化层，让云化后的网络管理格局变得更加复杂，需要更多编排工作，以管理 VNF 和网络服务（Network Service, NS）的全生命周期。VNF能够被其他的VNF或者物理网络关联来实现一个网络服务。VNF软件和NFVI之间的解耦，NS可以包括相关虚拟链路、物理网络功能、虚拟网络功能、网络功能虚拟化基础设置以及相互之间的关系等等这些，它们的协作处理需要一组新的管理和业务流程功能。为此，在NFV网络架构引入了MANO这个逻辑实体，实现NFV网络架构在横向的业务网络管理和编排管理。</p><p>在ETSI的定义中，对引入NFV-MANO架构框架，要求遵循一些原则：</p><blockquote><p>1、编排由多个功能块提供，功能块不进行优先级区分，即没有哪个功能块是优先于其他功能块。</p><p>2、在架构功能的分类上要求遵循总体平等的架构原则。</p><p>3、NFV-MANO功能可能以不同的方式实现，如作为整体的单一实例、作为一个带有多负载均衡的可扩展系统、作为一个分布式协作系统、一个功能上分解的分布式的系统。它也可以实现为云网一体化管理的扩展，或者作为一个实现 NFV功能的与云网管理系统交互的单独系统。</p></blockquote><p>基于上述原则，NFV-MANO既可以通过虚拟化以纯软件的方式实现，也可以异构管理跨地域的NFVI，实现基于策略的分布式统一纳管和自动化响应能力。</p><p>参考ETSI NFV文稿，MANO内部包括虚拟<strong>基础设施管理</strong>、<strong>虚拟网络功能管理</strong>和<strong>网元/服务编排器</strong>3个实体，分别实现对NFVI、VNF和NS这3个层次的管理。MANO的架构如下图右边所示</p><p><img src="https://i.loli.net/2019/04/19/5cb934a9b3902.jpg" alt></p><ul><li><strong>NFVO：</strong>编排器，具有两个主要职责，一是执行资源编排功能，对多VIM之间的NFVI资源进行编排；二是完成网络服务生命周期管理，执行网络服务编排功能。</li><li><strong>VNFM：</strong>虚拟网元管理单元，负责VNF实例的生命周期管理，每个VNF均有一个与之关联的 VNF Manager，一个VNF Manager可以管理一个或多个VNF。</li><li><strong>VIM：</strong>虚拟化基础设施管理单元，主要实现对NFVI纳管的计算、存储和网络资源的控制与管理，通常在一个运营商的基础设施域内。</li><li><strong>NS Catalogue：</strong>网络服务目录，代表所有加载的网络服务资源，通过 NFVO所公开的接口支持创建和管理NS部署模板，包括网络服务描述（Network Service Descriptor，NSD）、虚拟链路描述（Virtual Link Descriptor，VLD）和VNF转发图描述（VNF Forwarding Graph Descriptor，VNFFGD）。</li><li><strong>VNF Catalogue：</strong>虚拟网络功能服务目录，代表了所有加载的VNF网元资源，通过NFVO公开的接口来创建和管理VNF网元，包括虚拟网元功能描述（VNF Descriptor，VNFD）、软件镜像、清单文件和策略文件等。NFVO和VNFM均可通过查询VNF Catalogue来发现和检索VNFD以支持不同的操作，如鉴权授权或检查实例的可行性。</li><li><strong>NFV Instances Repository：</strong>NFV实例库，记录所有VNF实例和网络服务NS实例的信息。每个VNF实例由一条VNF记录来表示，每个NS实例由一条NS记录来表示。这些记录在每个实例的生命周期中被反复刷新，用于反映执行NS生命周期管理操作或VNF生命周期管理操作的变化。</li><li><strong>NFVI Resources Repository：</strong>NFVI资源库，记录可用的、保留的及可分配的NFVI资源信息，支持资源预留、分配和用于监控的有用信息。NFVI资源库主要用于NFVO的资源编排和管理，允许根据与NS和VNF实例相关联的资源来追踪NFVI保留和分配资源，如某个VNF实例在其生命周期内的任意时刻所使用VM的数量、配额、端口和弹性IP等信息。</li></ul><p>NFV-MANO与多个模块或系统具有接口关系，包括资源管理、虚拟化网络功能、运营系统支撑、业务系统支撑功能和NFV基础设施等，例如：Os-Ma-nfvo为OSS/BSS和NFVO之间的接口；Ve-Vnfm-em是EM和VNFM之间的接口等等，通过这些定义良好的接口，实现MANO和外围模块或系统之间良好协作，华为IES，中国移动OSS4.0等都是基于MANO的这些接口实现。</p><p>参考上述ETSI NFV架构，结合电信业务特点，给出一种NFV-MANONFV-MANO系统实现方案。如下图所示，该系统的主要功能模块包括：网络服务编排管理模块（NFVO）、虚拟化网络功能管理模块（VNFM）、虚拟资源管理模块（VIM）、视图管理、接口管理和Rest API。</p><p><img src="https://i.loli.net/2019/04/19/5cb93518b3cc1.jpg" alt></p><p>结合上图实现虚拟化编排的主要系统流程。</p><blockquote><p>1）用户上传VNF以及NS模板；</p><p>2）选取需要实例化NS模板，如IMS；</p><p>3）系统解析模板，根据策略配置决定如何初始化VNF；</p><p>4）根据VNF模板配置初始化需要的虚拟网络环境，如子网、路由、ACL、NAT等；</p><p>5）创建VNF需要的云主机；</p><p>6）实例化NS所需的VNF；</p><p>7）监控脚本监控VNF服务是否启动，并发送监控数据；</p><p>8）通过监控脚本判断IMS是否启动成功。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ETSI定义的NFV网络参考架构&quot;&gt;&lt;a href=&quot;#ETSI定义的NFV网络参考架构&quot; class=&quot;headerlink&quot; title=&quot;ETSI定义的NFV网络参考架构&quot;&gt;&lt;/a&gt;ETSI定义的NFV网络参考架构&lt;/h2&gt;&lt;p&gt;ETSI作为NFV的发起标准组织，于2015年年初发布了NFV参考架构等系列文稿，具体包括：用例文档、架构框架、虚拟化需求、NFV基础设施、NFV MANO、VNF、服务质量、接口、安全、PoC框架、最佳实践等内容。虽然ETSI NFV阶段成果不是强制执行的标准，但是得到了业界的普遍认可，已经成为了业界的事实标准。
    
    </summary>
    
      <category term="NFV基础" scheme="https://kkutysllb.cn/categories/NFV%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="电信云" scheme="https://kkutysllb.cn/tags/%E7%94%B5%E4%BF%A1%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>2019-04-18-NFV基础概念</title>
    <link href="https://kkutysllb.cn/2019/04/19/2019-04-18-NFV%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>https://kkutysllb.cn/2019/04/19/2019-04-18-NFV基础概念/</id>
    <published>2019-04-19T01:56:34.000Z</published>
    <updated>2019-04-19T02:14:32.355Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NFV技术的起源和概念"><a href="#NFV技术的起源和概念" class="headerlink" title="NFV技术的起源和概念"></a>NFV技术的起源和概念</h2><p>在移动互联网时代，运营商面临内外困局。就自身而言，采用的流量增长—网络扩容—收入增长的商业模型正在失效，庞大、僵化的电信基础网络，不能够满足用户的丰富需求；就竞争对手而言，互联网企业以天为计的业务迭代时间，能够很好地贴合用户需求，飞速发展的OTT业务，使运营商越来越趋向于管道工的角色。<a id="more"></a></p><p>随着云计算普及和x86服务器性能提高，各大运营商为了避免进一步成为哑管道的尴尬，由全球各大运营商牵头提出<strong>网络功能虚拟化技术（Network Function Virtualization，NFV）</strong>。NFV的思路是通过虚拟化技术降低成本，实现业务的灵活配置。对运营商来说，NFV是一次改变困局、实现跨越发展的难得机遇，一方面可以降低CAPEX和OPEX成本，降低整体的TCO；另一方面也可以加速新产品推出和业务创新。</p><p><strong>所谓的网络功能虚拟化就是利用IT虚拟化技术将现有网络设备功能整合进标准x86服务器、存储和网络数通设备，以软件的形式实现网络功能，以此取代目前网络中私有、专有和封闭的网元设备。</strong>NFV网络功能示意图如下所示：</p><p><img src="https://i.loli.net/2019/04/19/5cb92bdc10b10.jpg" alt></p><p><img src="https://i.loli.net/2019/04/19/5cb92bfbe3648.jpg" alt></p><blockquote><p><strong>维基百科对NFV的定义是：</strong>NFV是一种网络架构概念，给予IT虚拟化技术将网络功能节点虚拟化为可以链接在一起提供通信服务的功能模块。</p><p><strong>OpenStack基金会对NFV的定义是：</strong>通过软件和自动化替代专用网络设备来定义、创建和管理网络功能的新方式。</p><p><strong>ETSI NFV标准化组织对NFV的定义是：</strong>NFV致力于改变网络运营商构建网络的方式，通过IT虚拟化技术将各种网元变成独立的应用，可以灵活部署在基于标准服务器、存储、交换机构建的统一平台上，实现在数据中心、网络节点和用户端等各个位置的部署与配置。</p></blockquote><p><strong>NFV并非只是简单地在设备中部署虚拟机，其重要特征在于引入虚拟化层之后，虚拟功能网元与硬件完全解耦，改变了电信领域软件、硬件绑定的设备提供模式。打破了传统电信设备的竖井式体系，其核心是网元的分层解耦和引入新的MANO管理体系实现全生命周期管理。</strong></p><h2 id="NFV的组织"><a href="#NFV的组织" class="headerlink" title="NFV的组织"></a>NFV的组织</h2><p>NFV的工作开展涉及标准化和开源两条线，需要多组织的协作，促进NFV技术架构的成熟。其中，标准化线中3GPP SA5、TMF等组织负责NFV流程与接口的设计，ETSI NFV ISG以及ITU-T等组织负责NFV的需求和框架，并为流程和接口提供管理功能。而开源线中包括开源集成软件NFV开放平台项目（OPNFV,Open Platform for NFV)以及相应的开源组件（OpenStack，KVM，OVS等）。</p><p><strong>标准化线条</strong></p><ul><li><strong>ETSI：</strong>在2012年，由全球13家网络运营商（AT&amp;T、BT、Century Link、中国移动、Colt、Deutsche、Telecom、KDDI、NTT、Orange、Telecom Italia、Telefonica、Telstra、Verizon）提出NFV的目标与行动计划，并主要负责NFV接口参考点定义、流程、需求和信元定义。</li><li><strong>3GPP：</strong>在2013年Rel-13中也开始关注NFV移动网络虚拟化的研究，其主要负责NFV技术在5G业务和市场的应用。</li><li><strong>DMTF：</strong>2015年开始将自身研究与NFV工作结合，开始支持NFVD需求，支持VNF的管理和网络管理。</li><li><strong>CCSA：</strong>国内主导NFV技术的组织，主要负责承载网、核心网、接入网等网络功能虚拟化技术研究，编排和接口功能需求以及虚拟化管理技术研究。</li></ul><p><strong>开源线条</strong></p><ul><li><strong>OPNFV：</strong>2014年，由AT&amp;T、NTT、中国移动、RedHat、爱立信等厂商发起OPNFV开源社区，目的是为NFV提供一个统一的开源基础平台，集成OpenStack、OpenDaylight、OVS、ceph等上游社区的成果，推动上游社区加速接纳NFV架构。</li><li><strong>OPEN-O：</strong>2016年，由华为与Linux基金会、中国移动共同举办OPEN-O新闻发布会，携手中国电信、韩国电信、爱立信、因特尔、RedHat、F5等15家产业领导者发起全球首个统一SDN和NFV开源协同器OPEN-O，主要负责NFV的管理和编排方面的研究。</li></ul><h2 id="NFV的技术基础"><a href="#NFV的技术基础" class="headerlink" title="NFV的技术基础"></a>NFV的技术基础</h2><p>NFV的目标是降低运营商成本的同事提供服务的灵活性和资源的利用率。近几年，标准服务器技术、虚拟化技术、云计算、SDN、开源项目的发展都推动了NFV技术产生和应用。</p><p><strong>1、标准服务器</strong></p><p>移动通信网络是一个“<strong>标准先行</strong>”的网络。在传统网络下，由于所有的网络流程、协议信元都经过深入讨论形成标准之后，各设备厂商才设计产品、实现功能。因此，不同的硬件根据实现的功能不同其设计标准、布局和元器件选择等均不相同，不同硬件之间无法兼容替换。同时，由于移动通信协议是固定的，厂商产品所处理的内容不会超过协议定义的范围，一般采用专有芯片来处理完成。因此，这类硬件无法承担较复杂的计算任务，虽然性能优越，但部署成本较高。如下图所示两种专有硬件设计：</p><p><img src="https://i.loli.net/2019/04/19/5cb92ca6c8597.jpg" alt></p><p>在网络功能虚拟化技术中，行业标准服务器的使用是一个关键，不仅软硬件兼容可替换，且供应商市场充分竞争。近几年，x86、ARM架构的快速发展，使得服务器平台多CPU、多核、多线程技术非常成熟。同时，随着SR-IOV网卡的广泛应用，DPDK技术的开源化，使得通用芯片的计算能力，通用网卡的转发能力也越来越强（已经达到40Gbit/s等）。</p><p><strong>2、虚拟化技术</strong></p><p>在计算机科学中，虚拟化技术是一种资源管理技术，将物理资源抽象，提供给用户使用，打破物理资源的实现方式、地理位置、封装等限制。不仅提高了资源的最优化利用，而且还可实现资源的负载均衡、节能减排和自愈等功能。主要涉及计算虚拟化、存储虚拟化和网络虚拟化三大领域虚拟化技术。</p><p>在虚拟化技术实现中，Hypervisor是所有虚拟化技术实现的核心，它是运行基础服务器和操作系统之间的中间层软件，如VMware的ESX。通过它，多个操作系统和应用程序可以共享硬件资源，协调和管理服务器上所有物理设备和虚拟机，因此，也称为虚拟机监视器VMM（Virttual Machine Monitor）。主流的Hypervisor有VMware vSphere、Hyper-V、XenServer、PowerVM、KVM、FusionCompute等。</p><p><strong>3、云计算</strong></p><p>目前，云计算没有一个统一的定义。维基百科的定义是：云计算是一种基于互联网的计算方式，通过这种方式，共享软硬件资源和信息可以按需提供为计算机和其它设备。云计算的核心思想是将大量用网络连接的计算资源统一管理和调度，构成一个计算资源池向用户按需服务。提供资源的网络就称为“云”。</p><p>云计算提供三种服务模式，分为<strong>基础设施即服务（IaaS）、平台即服务（PaaS）和软件即服务（SaaS）</strong>。网络功能虚拟化NFV主要用于电信网络领域，因此也被称为电信网络云化实现，简称电信云。既然是“云”，那就必然离不开云计算的三种服务模式。在NFV的网路架构中，VIM/NFVI是真正的与“云”有关联的部分，其对应云计算三种服务模式的IaaS。而NFV的VNFM和NFVO部分其本质只是“云”上的APP应用。</p><p><a href="https://kkutysllb.cn/2018/10/10/2018-10-10-%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9A%84%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/">云计算部分详见《云计算的技术架构》。</a></p><p>提到云计算必然要提及OpenStack，这一个开源云操作系统从诞生起，社区活跃度就非常高。目前，除了Amazon、微软外，几乎所有的私有云和公有云解决方案都是基于开源OpenStack的改造和增强版。那么NFV，也就是电信云的VIM+NFVI是否也可以采用OpenStack？从NFV的技术特点和应用场景来看，其对OpenStack有三点基本诉求：</p><p><strong>1、业务面的高性能要求：涉及虚拟机性能和网络转发性能两个方面。</strong></p><p><strong>2、高可用和高可靠性要求：涉及控制平面、业务平面和存储平面三个方面。</strong></p><p><strong>3、易运维要求：涉及云化电信网络统一管理、统一调度、自动化运维等方面。</strong></p><p>为此，为了适用NFV，OpenStack需要在业务平面进行相应增强，具体如下图所示：</p><p><img src="https://i.loli.net/2019/04/19/5cb92d65518b0.jpg" alt></p><p>上述增强技术主要涉及VIM层面和OpenStack+KVM的场景，主要改变在Nova和Neutron中，本质上是对虚拟化性能优化技术的充分利用。</p><p><strong>4、SDN</strong></p><p>网络设备一般由控制平面和数据平面组成。控制平面为数据平面制定转发策略，规划转发路径，如路由协议、网关协议等。数据平面则是执行控制平面策略的实体，包括数据的封装/解封装、查找转发表等。目前，设备的控制面和转发面都是由设备厂商自行设计和开发，不同厂家实现的方式不尽相同。并且，软件化的网络控制面功能被固化在设备中，使设备使用者没有任何控制网络的能力。这种控制平面和数据平面紧耦合的方式带来了网络管理复杂、网络测试繁杂、网络功能上线周期漫长等问题。因而，软件定义网络应运而生。</p><p><strong>SDN技术是软件定义网络，</strong>本质是把网络软件化，提高网络可编程能力和易修改性。SDN没有改变网络的功能，而是重构了网络的架构。<strong>SDN的价值在于：</strong>网络业务自动化和网络自治，更快部署网络业务实例。更快在网络中增加新业务，大量需求仅需要升级控制器软件就可以实现。同时，简化了网络协议，大量网络业务协议逐渐消失，用户的策略处理集中在控制器实现。通过集中控制，对网络资源进行统筹调度和深度挖掘，提高网络资源利用率，接入更多业务，从垂直整合走向水平整合，使得芯片、设备、控制器各层可以独立分层充分竞争。</p><p>NFV没有改变设备的功能，而是改变了设备的形态。NFV的本质是把专用硬件设备变成一个通用软件设备，共享硬件基础设施。<strong>NFV的价值在于：</strong>软件设备的发行安装速度远比硬件设备快，容量伸缩更快，避免硬件采购安装的长周期，可按需实时扩容。实现新需求新业务更快，避免了硬件的冗长开发周期。同时，简化了设备形态，统一了底层硬件资源，都是服务器和交换机。采用通用服务器作为和交换机作为基础设施，大大降低设备成本。水平整合改变了原来的竞争格局，各个层次可以分层竞争。</p><p><strong>SDN与NFV有什么关系？</strong>NFV的软件设备（统称VNF）快速部署以及VNF之间网络快速建立，需要支持网络自动化和虚拟化能力，这需要SDN网络提供支持。在SDN网络情况下的一些网络诉求，比如能够快速提供虚拟网络，快速部署增值业务处理设备和网络设备等这些快速业务上线需求，需要NFV的软件网络设备（FW、vRouter）才能达成目的。</p><p><img src="https://i.loli.net/2019/04/19/5cb92dbeda976.jpg" alt></p><p>所以，<strong>SDN是面向网络的，SDN没有改变网络的功能，而是重构了网络的架构。NFV是面向设备的，NFV没有改变设备的功能，而是改变设备的形态。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;NFV技术的起源和概念&quot;&gt;&lt;a href=&quot;#NFV技术的起源和概念&quot; class=&quot;headerlink&quot; title=&quot;NFV技术的起源和概念&quot;&gt;&lt;/a&gt;NFV技术的起源和概念&lt;/h2&gt;&lt;p&gt;在移动互联网时代，运营商面临内外困局。就自身而言，采用的流量增长—网络扩容—收入增长的商业模型正在失效，庞大、僵化的电信基础网络，不能够满足用户的丰富需求；就竞争对手而言，互联网企业以天为计的业务迭代时间，能够很好地贴合用户需求，飞速发展的OTT业务，使运营商越来越趋向于管道工的角色。
    
    </summary>
    
      <category term="NFV基础" scheme="https://kkutysllb.cn/categories/NFV%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="电信云" scheme="https://kkutysllb.cn/tags/%E7%94%B5%E4%BF%A1%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>2019-04-16-Linux系统核心命令-第二篇《文件或目录操作命令》</title>
    <link href="https://kkutysllb.cn/2019/04/17/2019-04-16-Linux%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E5%91%BD%E4%BB%A4-%E7%AC%AC%E4%BA%8C%E7%AF%87%E3%80%8A%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%E3%80%8B/"/>
    <id>https://kkutysllb.cn/2019/04/17/2019-04-16-Linux系统核心命令-第二篇《文件或目录操作命令》/</id>
    <published>2019-04-17T06:37:44.000Z</published>
    <updated>2019-04-17T08:13:48.592Z</updated>
    
    <content type="html"><![CDATA[<h2 id="pwd：显示当前所在的位置"><a href="#pwd：显示当前所在的位置" class="headerlink" title="pwd：显示当前所在的位置"></a>pwd：显示当前所在的位置</h2><p>pwd命令是“print working directory”中每个单词的首字母缩写，其功能是显示当前工作目录的绝对路径。在实际工作中，我们在命令行操作命令时，经常会在各个目录路径之间进行切换，此时可使用pwd命令快速查看当前我们所在的目录路径。<a id="more"></a></p><p><strong>语法格式：pwd [option]</strong></p><p>通常情况下，执行pwd命令不需要带任何参数。</p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/04/17/5cb6cabd04ceb.jpg" alt></p><p><strong>【使用举例】</strong><br><strong>1）不带任何选项执行pwd命令。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ~]# pwd #显示当前目录为root用户的家目录</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6cbae4e9ca.jpg" alt></p><p><strong>2）对比使用-L和-P参数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ~]# ls -l /etc/rc0.d  # 显示/etc/目录下rc0.d的目录信息</span><br></pre></td></tr></table></figure><p>显示结果为/etc/rc0.d目录为/etc/rc.d/rc0.d目录的软链接</p><p><img src="https://i.loli.net/2019/04/17/5cb6cd0452e69.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ~]# cd /etc/rc0.d/ # 进入/etc/rc0.d目录</span><br></pre></td></tr></table></figure><p>在该目录下分别执行pwd -L和pwd -P，对比执行结果。</p><p><img src="https://i.loli.net/2019/04/17/5cb6cd1a1c579.jpg" alt></p><p>当前系统命令提示符的显示格式是系统默认的格式，受环境变量PS1限制，查看环境变量PS1的方法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ~]# echo $PS1</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6cd393b172.jpg" alt></p><p>如果要修改系统提示符的显示格式，可以根据下表自行调整<strong>/etc/profile</strong>文件中PS1环境变量的设置，修改完成保存退出，通过<strong>source /etc/profile</strong>加载新设置的环境变量使配置生效。</p><p><img src="https://i.loli.net/2019/04/17/5cb6ccd2849f1.jpg" alt></p><h2 id="cd：切换目录"><a href="#cd：切换目录" class="headerlink" title="cd：切换目录"></a>cd：切换目录</h2><p>cd命令是“change directory”中每个单词的首字母缩写，其功能是从当前工作目录切换到指定的工作目录。</p><p><strong>语法格式：cd [option] [dir]</strong></p><p>cd命令后面的选项和目录等参数都可以省略。默认情况下，单独执行cd命令，可切换到当前登录用户的家目录（由系统环境变量HOME定义）。cd是bash shell的内置命令，查看该命令对应的系统帮助需要使用help cd。在使用cd命令时，如果使用键盘上“Tab”键的自动补齐功能，可以提高输入速度和准确度。<strong>这个“Tab”键的自动补齐功能同样也适用于其他命令。</strong></p><p>要了解路径的概念，比如，相对路径是不从“/”（斜线）开始的路径，而是从当前目录或指定的目录开始，如：data/、mnt/oldboy；绝对路径是从“/”（斜线）根开始的路径，如：/root/mydata/、/mnt/VMware。</p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/04/17/5cb6cd94a3427.jpg" alt></p><p><strong>需熟练掌握带*选项的用法：</strong>当需要切换到当前用户上一次所在的目录时，请使用“cd -”（注意空格）；当需要切换到当前用户的家目录时，请使用“cd～”（注意空格）；当需要切换到当前目录的上一级目录所在的路径时，请使用“cd ..”（注意空格）。</p><p><strong>【使用举例】</strong></p><p><strong>1）进入系统/etc目录</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ~]# cd /etc/</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6cddce0489.jpg" alt></p><p><strong>2）切换到/usr/local目录下</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 etc]# cd /usr/local/</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6ce0c59a2f.jpg" alt></p><p><strong>3）切换到当前目录的上一级目录</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 local]# cd ..  # ..表示当前目录的父目录，.表示当前目录</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6ce331f148.jpg" alt></p><p><strong>4）进入当前目录的父目录的父目录</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 local]# cd ../..  # 当前目录为/usr/local，其父目录就是/usr，其爷爷目录就是根目录/</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6ce707e8ae.jpg" alt></p><p><strong><em>只要目录有足够多的层次，可以一直这样继续下去“cd../../../..”，直到退到“/”为止。</em></strong></p><p><strong>5）返回当前用户上一次所在的目录</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 /]# cd - # -就是表示返回到进入当前目录前的那个目录</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6ce9626bfe.jpg" alt></p><p><strong>6）进入当前用户的家目录</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 local]# cd ~</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6cece68e54.jpg" alt></p><h2 id="tree：以树形结构显示目录下的内容"><a href="#tree：以树形结构显示目录下的内容" class="headerlink" title="tree：以树形结构显示目录下的内容"></a>tree：以树形结构显示目录下的内容</h2><p>tree命令的中文意思为“树”，功能是以树形结构列出指定目录下的所有内容，包括所有文件、子目录及子目录里的目录和文件。</p><p><strong>语法格式：tree [option] [directory]</strong></p><p>tree命令后若不接选项和目录就会默认显示当前所在路径目录的目录结构。tree命令可能需要单独安装，首先检查系统是否安装了tree命令，如果采用的是最小化安装Linux系统的方式，那么tree命令有可能没有安装，此时可用yum命令安装tree命令。</p><p>1、检查系统是否安装tree命令，如果没有输出，就表示没有安装，此时通过第二步命令进行安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ~]# rpm -aq tree</span><br></pre></td></tr></table></figure><p>2、安装tree命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ~]# yum install -y tree</span><br></pre></td></tr></table></figure><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/04/17/5cb6cf7d01b3c.jpg" alt></p><p><strong>【使用示例】</strong></p><p><strong>1）不带任何参数执行tree命令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ~]# tree</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6cf9f42455.jpg" alt></p><p><strong>2）以树形结构显示目录下的所有内容（-a的功能）</strong></p><p><strong><em>在Linux系统中，以“.”点号开头的文件为隐藏文件，默认不显示。</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 bin]# tree -a  # 在/usr/bin目录下执行</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6cfc512808.jpg" alt></p><p><strong>3）只列出根目录下第一层目录的结构（-L功能）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 /]# tree -L 1  # -L参数后接数字，表示查看目录的层数，不带-L选项默认显示所有层</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6cfeebf4ef.jpg" alt></p><p><strong>4）只显示所有的目录（但不显示文件）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ~]# tree -d</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6d01cf3f93.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ~]# tree -dL 1 # -d参数只显示目录，-L参数显示层数，组合起来就是只显示当前目录下第一层目录。</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6d04405fd3.jpg" alt></p><p><strong>5） -f选项和-i选项的使用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ~]# tree -L 1 -f /boot  # 只显示/boot目录下第一层的所有文件的全路径</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6d086a4306.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ~]# tree -L 1 -fi /boot  # 加上-i选项，显示结果不带树枝，便于复制粘贴</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6d0b10992f.jpg" alt></p><p><strong>6）使用tree命令区分目录和文件的方法（常用）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ~]# tree -L 1 -F /boot # 使用-F参数会在目录后面添加“/”，方便区分目录。</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6d169c177e.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ~]# tree -L 1 -F /etc/ | grep /$  # 结合管道符|和grep，可以方便将目录过滤出来</span><br><span class="line">#/$是Linux的通配符，表示以/结尾的字符</span><br><span class="line">#管道符的作用在于指令拼接，上面指令的意思就是将tree指令的执行结果交给grep指令处理。</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6d1c8bbdd2.jpg" alt></p><p><strong>小练习：通过tree指令将/usr/local/下的第一级文件全部过滤出来，结果只能包含文件，不能包含目录（答案贴在本文的讨论区）</strong></p><h2 id="mkdir：创建目录"><a href="#mkdir：创建目录" class="headerlink" title="mkdir：创建目录"></a>mkdir：创建目录</h2><p>mkdir命令是“make directories”中每个单词的粗体字母组合而成，其功能是创建目录，默认情况下，如果要创建的目录已存在，则会提示此文件已存在；而不会继续创建目录。</p><p><strong>语法格式：mkdir [option] [directory]</strong></p><p>mkdir命令可以同时创建多个目录，格式为mkdir dir1 dir2…，也可以使用{}来完成指定序列的批量目录创建。<strong>使用mkdir创建多级目录时，建议直接使用-p参数，可以避免出现“No such file or directory”这样没有文件或目录的报错了，且不会影响已存在的目录。</strong></p><p><strong>重要选项参数：</strong></p><p><img src="https://i.loli.net/2019/04/17/5cb6d2005568f.jpg" alt></p><p><strong>【使用示例】</strong></p><p><strong>1）不使用任何命令参数创建目录用法示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]# mkdir mytest</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6d22e5623b.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]# mkdir mytest # 当再次创建时，会提示目标目录已存在</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6d252844fa.jpg" alt></p><p><strong>2）使用-p参数递归创建目</strong></p><p>当我们创建多级目录时，如果第一级目录（data）不存在，那么创建结果会报错，导致无法创建成功，操作如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]# mkdir data/stu01</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6d27fbe29e.jpg" alt></p><p>此时，可以指定-p参数递归创建多级目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]# mkdir -p data/stu01</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6d3aba1b7d.jpg" alt></p><p><strong>3）加-v参数显示创建目录的过程</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在data目录下同时创建2个子目录stu02和stu03，并且同时在两个子目录下再分别创建四个子目录test01-test04 </span><br><span class="line">[root@C7-Server01 kkutysllb]# mkdir -pv data/stu&#123;02,03&#125;/test&#123;01..04&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6d3e3f3e7e.jpg" alt></p><p><strong>其实这个-v没有什么实际用途，它只是用来显示创建目录的过程。</strong></p><p>大括号（{}）的特殊用法，见如下图示：</p><p><img src="https://i.loli.net/2019/04/17/5cb6d405d31ad.jpg" alt></p><p><strong>4）创建目录时可使用-m参数设置目录的默认权限</strong></p><p>如果创建目录是不设置目录的权限，所创建目录的默认权限是755，如下所示：（目录的权限问题在讲解ls指令会讲到）</p><p><img src="https://i.loli.net/2019/04/17/5cb6d429da11e.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]# mkdir -m 333 dir01</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6d44f22fef.jpg" alt></p><p>这个指令在创建特殊安全要求的目录时会用到，平时一般不用。因为，目录的权限还决定了目录中子目录及其文件的权限，所以在创建目录时要综合考虑。</p><h2 id="touch：创建空文件或改变文件的时间戳属性"><a href="#touch：创建空文件或改变文件的时间戳属性" class="headerlink" title="touch：创建空文件或改变文件的时间戳属性"></a>touch：创建空文件或改变文件的时间戳属性</h2><p>touch命令有两个功能：一是创建新的空文件；二是改变已有文件的时间戳属性。</p><p><strong>语法格式：touch [option] [file]</strong></p><p>注意区分touch和mkdir命令的功能，mkdir命令是创建空目录，而touch是创建空文件。在Linux中，一切皆文件。虽然touch命令不能创建目录，但是可以修改目录的时间戳。</p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/04/17/5cb6d481054b1.jpg" alt></p><p><strong>【使用示例】</strong></p><p><strong>1）创建文件示例（文件事先不存在的情况）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]# touch image001</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6d4a0b9ac4.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#可以使用&#123;&#125;同时创建多个文件</span><br><span class="line">[root@C7-Server01 kkutysllb]# touch image&#123;002..009&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6d4ca543f8.jpg" alt></p><p><strong>2）更改文件的时间戳属性</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查看文件时间戳属性，可以使用stat指令</span><br><span class="line">[root@C7-Server01 kkutysllb]# stat image001</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6d4fa74423.jpg" alt></p><p><strong><em>文件的时间戳属性分为访问时间、修改时间、状态改变时间。</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]# touch -a image001 # -a选项更改文件的访问时间为当前时间</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6d51e2a4da.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]# touch -m image001 # -m选项更改文件的修改时间为当前时间</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6d5407398c.jpg" alt></p><p><strong>无论是-a选项修改文件的访问时间，还是-m选项修改文件的修改时间，文件的状态改变时间ctime也同步进行改变。</strong></p><p><strong>3）指定时间属性创建/修改文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 将文件image001的访问时间和修改时间统一修改为2020年10月21日 </span><br><span class="line">[root@C7-Server01 kkutysllb]# touch -d 20201021 image001</span><br></pre></td></tr></table></figure><p><strong><em>这个功能经常用于黑客入侵后的操作。</em></strong></p><p><img src="https://i.loli.net/2019/04/17/5cb6d573298fe.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#使用image002文件的时间戳为模板改为image001文件的时间戳</span><br><span class="line">[root@C7-Server01 kkutysllb]# touch -r image002 image001</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6d591ec7a9.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#还可以利用-t选项将image001的时间修改为202012312234.55的格式</span><br><span class="line">[root@C7-Server01 kkutysllb]# touch -t 202012312234.55 image001</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6d5bc68557.jpg" alt></p><p><strong>知识扩展：</strong></p><p>这里扩展一点有关时间戳属性的知识。GNU/Linux的文件有3种类型的时间戳：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Access：2015-07-30 17:48:20.502156890 +0800 #&lt;==最后访问文件的时间。 </span><br><span class="line"></span><br><span class="line">Modify：2015-07-30 17:48:45.006106223 +0800 #&lt;==最后修改文件的时间。 </span><br><span class="line"></span><br><span class="line">Change：2015-07-30 17:48:45.006106223 +0800 #&lt;==最后改变文件状态的时间。</span><br></pre></td></tr></table></figure><hr><h2 id="ls：显示目录下的内容及相关属性信息"><a href="#ls：显示目录下的内容及相关属性信息" class="headerlink" title="ls：显示目录下的内容及相关属性信息"></a>ls：显示目录下的内容及相关属性信息</h2><p>ls命令可以理解为英文单词list的缩写，其功能是列出目录的内容及其内容属性信息（list directorycontents）。该命令有点类似于DOS系统下的dir命令，有趣的是，Linux下其实也有dir命令，但我们更习惯于使用ls。</p><p><strong>语法格式：ls [option] [file]</strong></p><p>ls命令后面的选项和目录文件可以省略，表示查看当前路径的文件信息。</p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/04/17/5cb6d61ccab40.jpg" alt></p><p><img src="https://i.loli.net/2019/04/17/5cb6d62f8d270.jpg" alt></p><p><strong>【使用示例】</strong></p><p><strong>1）直接执行ls命令，不带任何参数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 列出/home/kkutysllb目录下的文件信息 </span><br><span class="line">[root@C7-Server01 kkutysllb]# ls</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6d657e2a0e.jpg" alt></p><p><strong>2）使用-a参数显示所有文件，特别是隐藏文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 加了-a参数，就会把以“.”（点号）开头的内容显示出来了。这里显示的第一个点号，表示当前目录，即/home/kkutysllb/目录本身，而两个点号则表示当前目录的上级目录，此处就代表/home/目录了 </span><br><span class="line">[root@C7-Server01 kkutysllb]# ls -a</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6d6884f12d.jpg" alt></p><p><strong>3）使用-l参数显示详细信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]# ls -l</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6d6a82a331.jpg" alt></p><p><strong>4）显示完整时间属性的参数 –time-style=long-iso</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]# ls -l --time-style=long-iso</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6d6c7cb6f8.jpg" alt></p><p><strong>小练习：关于–time-style=long-iso的其它参数大家自行练习，将答案贴在本文的讨论区。</strong></p><p><strong>5）执行ls命令，带显示内容的访问时间属性的参数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 首先通过stat指令查看image001文件的访问时间信息 </span><br><span class="line">[root@C7-Server01 kkutysllb]# stat image001</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6d74a4236a.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 通过选项--time=atime显示文件的访问时间</span><br><span class="line">[root@C7-Server01 kkutysllb]# ls -l --time-style=long-iso --time=atime image001</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6d710c3d7e.jpg" alt></p><p>同理，通过选项–time=mtime可以查看文件的修改时间，选项–time=ctime可以查看文件状态的改变时间，大家可以自行练习。（国际惯例，答案贴在本文的讨论区）</p><p><strong>6）执行ls命令，带-F参数（这一点与tree命令的-F很类似）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#加了-F,我们可以清晰地看到所有目录的结尾都被加上了斜线/</span><br><span class="line">[root@C7-Server01 kkutysllb]# ls -lF</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6d77c553cb.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 过滤出当前目录下所有子目录</span><br><span class="line">[root@C7-Server01 kkutysllb]# ls -lF | grep /$</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6d7a27b7a8.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 过滤出当前目录下所有普通文件</span><br><span class="line"># grep命令的-v选项是反向过滤的意思</span><br><span class="line">[root@C7-Server01 kkutysllb]# ls -lF | grep -v /$</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6d7de930c3.jpg" alt></p><p><strong>7）使用-d参数只显示目录本身的信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 有时候我们想查看目录本身的信息，但是若使用“ls目录”命令，就会显示目录里面的内容，比如： </span><br><span class="line">[root@C7-Server01 kkutysllb]# ls -l data/</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6d89b645bc.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 通过-d选项可以查看目录的详细信息</span><br><span class="line">[root@C7-Server01 kkutysllb]# ls -ld data/</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6d8e0bcccc.jpg" alt></p><p><strong>8）使用-R参数递归查看目录</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># tree指令没有递归方式查看多级目录下详细信息的选项，但是ls指令就有，通过-R选项实现 </span><br><span class="line">[root@C7-Server01 kkutysllb]# ls -lR data/</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6d93c96532.jpg" alt></p><p><strong><em>小练习：通过ls命令迅速查找/boot目录下最近更新过的文件（不知文件名的情况下）</em></strong></p><p><strong><em>提示：</em></strong> </p><p><strong><em>1、利用-t选项对目录下文件按照修改时间排序。</em></strong></p><p><strong><em>2、利用-r选项对时间排序后的文件进行倒序排序。</em></strong></p><p><strong>9）ls命令列出文件的属性解读</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 利用-h和-i选项可以列出某个目录下所有文件和子目录的详细信息</span><br><span class="line"># -h选项是将文件的大小通过人类可读的方式显示出来，不加-h选项系统默认是字节单位</span><br><span class="line"># -i选项是文件的inode值，在linux系统中一个文件分为inode和block两部分，无论哪一部分占用满，都会显示磁盘空间不足的提示。</span><br><span class="line"># 因此，有时你会发现磁盘还有很大空间，但是提示磁盘占用满，这就是因为inode占用满的缘故。</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# ls -lhi /boot</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6d98047834.jpg" alt></p><blockquote><p>第一列：inode索引节点编号。<br>第二列：文件类型及权限（第一个字符为类型，后9个字符为文件权限符号）。<br>第三列：硬链接个数（详细请参看ln命令的讲解）。<br>第四列：文件或目录所属的用户（属主）。<br>第五列：文件或目录所属的组。<br>第六列：文件或目录的大小。<br>第七、八、九列：文件或目录的修改时间。<br>第十列：实际的文件名或目录名。</p></blockquote><p><img src="https://i.loli.net/2019/04/17/5cb6da0872dc3.jpg" alt></p><h2 id="cp：复制文件或目录"><a href="#cp：复制文件或目录" class="headerlink" title="cp：复制文件或目录"></a>cp：复制文件或目录</h2><p>cp命令可以理解为英文单词copy的缩写，其功能为复制文件或目录。</p><p><strong>语法格式：cp [option] [source] [dest]</strong></p><p><strong>重要参数选项</strong></p><p><img src="https://i.loli.net/2019/04/17/5cb6da317d93f.jpg" alt></p><p><strong>【使用示例】</strong></p><p><strong>1）无参数和带参数-a的比较</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看当前目录下的文件信息 </span><br><span class="line">[root@C7-Server01 kkutysllb]# ls -l</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6da5b16fb6.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 通过cp指令复制image001文件为image010文件</span><br><span class="line">[root@C7-Server01 kkutysllb]# cp image001 image010</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6da84c5ad7.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 使用-a选项复制image001文件为image011</span><br><span class="line">[root@C7-Server01 kkutysllb]# cp -a image001 image011</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6daa6bb917.jpg" alt></p><p><strong>2）-i参数的例子</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 使用-i选项覆盖已存在文件时，会有提示确认 </span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# cp -i image001 image011</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6dad6d8377.jpg" alt></p><p><strong>请大家思考下：为什么不使用-i选项覆盖已存在文件时，也会有提示确认？（提示：利用Google搜索下Linux系统的别名功能）</strong></p><p><strong>3）使用-r参数复制目录</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 如果要复制一个目录，可以用-r参数递归复制**</span><br><span class="line"></span><br><span class="line"># 在linux系统中，没有单独复制目录的命令 </span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# cp -r data/ data_tmp/</span><br></pre></td></tr></table></figure><p>通过diff指令或vimdiff指令对比复制后的两个文件（diff和vimdiff指令后面会讲）</p><p><img src="https://i.loli.net/2019/04/17/5cb6db0422b74.jpg" alt></p><h2 id="mv：移动或重命名文件"><a href="#mv：移动或重命名文件" class="headerlink" title="mv：移动或重命名文件"></a>mv：移动或重命名文件</h2><p>mv命令可以理解为英文单词move的缩写，其功能是移动或重命名文件（move/rename files）。</p><p><strong>语法格式：mv [option] [source] [dest]</strong></p><p><strong>重要参数选项</strong></p><p><img src="https://i.loli.net/2019/04/17/5cb6db252ed95.jpg" alt></p><p><strong>【使用示例】</strong></p><p><strong>1）给文件改名的例子</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># 将image001文件修改为image_t001</span><br><span class="line"></span><br><span class="line"> [root@C7-Server01 kkutysllb]# ls -l </span><br><span class="line"></span><br><span class="line">total 0 </span><br><span class="line"></span><br><span class="line">-rw-r--r-- 1 root root  0 Apr 16 18:35 202012312234.55 </span><br><span class="line"></span><br><span class="line">drwxr-xr-x 5 root root 45 Apr 17 11:59 data </span><br><span class="line"></span><br><span class="line">drwxr-xr-x 5 root root 45 Apr 17 11:59 data_tmp </span><br><span class="line"></span><br><span class="line">d-wx-wx-wx 2 root root  6 Apr 16 15:09 dir01 </span><br><span class="line"></span><br><span class="line">-rw-r--r-- 1 root root  0 Dec 31  2020 image001 </span><br><span class="line"></span><br><span class="line">-rw-r--r-- 1 root root  0 Apr 16 17:56 image002 </span><br><span class="line"></span><br><span class="line">-rw-r--r-- 1 root root  0 Apr 16 17:56 image003 </span><br><span class="line"></span><br><span class="line">-rw-r--r-- 1 root root  0 Apr 16 17:56 image004 </span><br><span class="line"></span><br><span class="line">-rw-r--r-- 1 root root  0 Apr 16 17:56 image005 </span><br><span class="line"></span><br><span class="line">-rw-r--r-- 1 root root  0 Apr 16 17:56 image006 </span><br><span class="line"></span><br><span class="line">-rw-r--r-- 1 root root  0 Apr 16 17:56 image007 </span><br><span class="line"></span><br><span class="line">-rw-r--r-- 1 root root  0 Apr 16 17:56 image008 </span><br><span class="line"></span><br><span class="line">-rw-r--r-- 1 root root  0 Apr 16 17:56 image009 </span><br><span class="line"></span><br><span class="line">-rw-r--r-- 1 root root  0 Apr 17 11:46 image010 </span><br><span class="line"></span><br><span class="line">-rw-r--r-- 1 root root  0 Dec 31  2020 image011 </span><br><span class="line"></span><br><span class="line">drwxr-xr-x 2 root root  6 Apr 16 14:30 mytest </span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# mv image001 image_t001 </span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# ls -l</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6db915f171.jpg" alt></p><p><strong>2）移动文件的例子</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 将image_t001文件移动到dir01目录下 </span><br><span class="line"></span><br><span class="line"># 源目录下已不存在刚移动过的文件 </span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# mv image_t001 dir01/</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6dbbb5fe3b.jpg" alt></p><p>在dir01目录下存在刚移动进来的文件image_t001</p><p><img src="https://i.loli.net/2019/04/17/5cb6dbd61ce62.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 移动多个文件</span><br><span class="line"></span><br><span class="line"># 第一种方式，源文件在前，目标目录在后</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# mv image002 image003 image004 dir01/</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6dbf7c5092.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 第二种方式，使用-t选项，目标目录在前，源文件在后</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# mv -t dir01/ image005 image006</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6dc17e5898.jpg" alt></p><p><strong>3）关于mv命令的使用小结</strong></p><p><img src="https://i.loli.net/2019/04/17/5cb6dc2f35a8d.jpg" alt></p><h2 id="rm：删除文件或目录"><a href="#rm：删除文件或目录" class="headerlink" title="rm：删除文件或目录"></a>rm：删除文件或目录</h2><p>rm命令可以理解为英文单词remove的缩写，其功能是删除一个或多个文件或目录（remove files or directories）。这是Linux系统里最危险的命令之一，请慎重使用。</p><p><strong>语法格式：rm [option] [file]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/04/17/5cb6dc522ca59.jpg" alt></p><p><strong>【使用示例】</strong></p><p><strong>1）不带参数删除例子实践</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#删除/home/kkutysllb/image011这个文件 </span><br><span class="line"></span><br><span class="line">#不带参数时，删除前默认要求确认，原因与cp命令一致 </span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# rm image011 </span><br><span class="line"></span><br><span class="line">rm: remove regular empty file ‘image011’? y  # 回复y删除，回复n不删除</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6dc7d078a4.jpg" alt></p><p><img src="https://i.loli.net/2019/04/17/5cb6dc8d04a52.jpg" alt></p><p><strong>2）强制删除例子实践</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 使用-f选项强制删除image007文件 </span><br><span class="line"></span><br><span class="line"># 直接删除，不提示确认 </span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# rm -f image007 </span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]#</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6dcc2db2df.jpg" alt></p><p><strong>3） 使用-r选项递归删除目录</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 使用-r选项可以递归删除目录，原理是先删除目录中文件和子目录，然后再删除目录本身 </span><br><span class="line"></span><br><span class="line"># 不带-f参数时，每删除一个文件都需要确认 </span><br><span class="line"></span><br><span class="line"># linux还有个删除目录的命令rmdir，但是只能删除空目录 </span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# rm -r dir01/ </span><br><span class="line"></span><br><span class="line">rm: descend into directory ‘dir01/’? y </span><br><span class="line"></span><br><span class="line">rm: remove regular empty file ‘dir01/image_t001’? y </span><br><span class="line"></span><br><span class="line">rm: remove regular empty file ‘dir01/image002’? y</span><br><span class="line"></span><br><span class="line">rm: remove regular empty file ‘dir01/image003’? y </span><br><span class="line"></span><br><span class="line">rm: remove regular empty file ‘dir01/image004’? y        </span><br><span class="line"></span><br><span class="line">rm: remove regular empty file ‘dir01/image005’? y </span><br><span class="line"></span><br><span class="line">rm: remove regular empty file ‘dir01/image006’? y </span><br><span class="line"></span><br><span class="line">rm: remove directory ‘dir01/’? y</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6dd1a3bc85.jpg" alt></p><p><strong>4）关于删除的实践经验</strong></p><p>常在河边走，哪有不湿鞋！但是如果能遵守下面的要领就可以少湿鞋甚至不湿鞋！</p><p>1）用mv替代rm，不要急着删除，而是先移动到回收站/tmp。</p><p>2）删除前务必备份，最好是异机备份，若出现问题随时可以还原。</p><p>3）如果非要删除，那么请用find完成要删除文件查找，然后通过管道符接rm指令进行精准删除，最大限度避免误删除，包括通过系统定时任务等清理文件方法。比如下面的指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ．-type f -name &quot;*.txt&quot; -mtime +7|xargs rm –f</span><br></pre></td></tr></table></figure><p>上面指令的意思是查找当前目录下7天以前的所有以.txt结尾的文件（注意，linux没有文件扩展名的概念，在linux中一切皆是文件），然后将结果通过管道符“|”传递给xargs rm -f指令组合进行删除（xargs是一个标准输入指令，其后面接rm指令就是模拟用户在终端侧直接输入rm指令的用法）</p><h2 id="ln：硬链接与软链接"><a href="#ln：硬链接与软链接" class="headerlink" title="ln：硬链接与软链接"></a>ln：硬链接与软链接</h2><p>ln命令可以理解为英文单词link的缩写，其功能是创建文件间的链接（make links between files），链接类型包括硬链接（hard link）和软链接（符号链接，symbolic link）。</p><blockquote><p>硬链接（Hard Link）：创建语法为“ln源文件目标文件”，硬链接生成的是普通文件（-字符）。</p><p>软链接或符号链接（Symbolic Link or Soft Link）：创建语法为“ln-s源文件目标文件（目标文件不能事先存在）”，软链接生成的是符号链接文件（l类型）。</p></blockquote><p>硬链接是指通过索引节点（Inode）来进行链接。在Linux（ext2、ext3、ext4）文件系统中，所有文件都有一个独有的inode编号。在Linux文件系统中，多个文件名指向同一个索引节点（inode）是正常且允许的。这种情况下的文件就称为硬链接。硬链接文件相当于文件的另外一个入口。它的作用之一就是允许一个文件拥有多个有效路径名（多个入口），这样用户就可以建立硬链接到重要文件，以防止误删源数据，只有删除了源文件以及源文件所有对应的硬链接文件，文件实体才会被删除。</p><p>软链接或符号链接（Symbolic Link or Soft Link）有点像Windows里的快捷方式。软链接类似于一个文本文件，里面存放的是源文件的路径，指向源文件实体。即使删除了源文件，软链接文件也还是依然存在，但是无法访问指向的源文件路径内容了。软链接和源文件是不同类型的文件，也是不同的文件，inode号也不相同。</p><p><strong>语法格式：ln [option] [source] [target]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/04/17/5cb6dd63b2644.jpg" alt></p><p><strong>【使用示例】</strong><br><strong>1）创建一个硬链接文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]# ln /etc/hosts hard_link</span><br><span class="line"></span><br><span class="line"># 通过ls -i查看源文件和硬链接文件的inode值</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# ls -li /etc/hosts hard_link </span><br><span class="line">33583813 -rw-r--r--. 2 root root 158 Jun  7  2013 /etc/hosts</span><br><span class="line">33583813 -rw-r--r--. 2 root root 158 Jun  7  2013 hard_link</span><br><span class="line"></span><br><span class="line"># 可以看见硬链接文件与原文件inode值一样</span><br><span class="line"></span><br><span class="line"># 删除源文件/etc/hosts</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# rm -f /etc/hosts</span><br><span class="line">[root@C7-Server01 kkutysllb]# cat /etc/hosts</span><br><span class="line">cat: /etc/hosts: No such file or directory  # 提示文件不存在</span><br><span class="line"></span><br><span class="line"># 可以通过刚才的硬链接文件进行误删除文件的找回，即在做一个硬链接</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# ln hard_link /etc/hosts</span><br><span class="line">[root@C7-Server01 kkutysllb]# cat /etc/hosts</span><br><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line">[root@C7-Server01 kkutysllb]# ls -li hard_link /etc/hosts</span><br><span class="line">33583813 -rw-r--r--. 2 root root 158 Jun  7  2013 /etc/hosts</span><br><span class="line">33583813 -rw-r--r--. 2 root root 158 Jun  7  2013 hard_link</span><br><span class="line">#找回后的文件inode值与删除前一致，就好像误删除从没发生过。</span><br></pre></td></tr></table></figure><p><strong>2）创建一个软连接文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#使用-s选项创建一个软连接文件</span><br><span class="line">[root@C7-Server01 kkutysllb]# ln -s /etc/hosts soft_link</span><br><span class="line"></span><br><span class="line"># 通过ls -li指令可以看出软连接文件和源文件的inode值不一致，说明这是两个不同的文件</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# ls -li /etc/hosts soft_link </span><br><span class="line">33583813 -rw-r--r--. 2 root root 158 Jun  7  2013 /etc/hosts</span><br><span class="line">1231043 lrwxrwxrwx  1 root root  10 Apr 17 14:04 soft_link -&gt; /etc/hosts</span><br><span class="line">#查看软连接文件的内容就是查看原文件的内容</span><br><span class="line">[root@C7-Server01 kkutysllb]# cat soft_link </span><br><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line">#通过readlink命令可以查看软链接中的存放的具体信息（非原文件内容）</span><br><span class="line">[root@C7-Server01 kkutysllb]# readlink soft_link </span><br><span class="line">/etc/hosts</span><br><span class="line">#可以看出软链接中存放的就是源文件的绝对路径</span><br></pre></td></tr></table></figure><p><strong><em>软链接和源文件的关系图示：</em></strong></p><p><img src="https://i.loli.net/2019/04/17/5cb6de6e04fc8.jpg" alt></p><p><strong>*注意一点：<em>**</em></strong>目录不可以创建硬链接，但是可以创建软链接。因为，前面讲过Linux系统的磁盘需要挂载到一个目录才可以使用，但是多个磁盘可能对应分区格式和文件系统不一样，因此如果两个目录之间如果是硬链接关系，但是对应的磁盘分区格式又不一致就会出现问题。***</p><h2 id="find：查找目录下的文件"><a href="#find：查找目录下的文件" class="headerlink" title="find：查找目录下的文件"></a>find：查找目录下的文件</h2><p>find命令用于查找目录下的文件，同时也可以调用其他命令执行相应的操作。</p><p><strong>语法格式：find [-H] [-L] [-P] [-D debugopts] [-Olevel] [pathname] [expression]</strong></p><p>注意子模块的先后顺序。</p><p>find命令用法的使用说明：</p><p><img src="https://i.loli.net/2019/04/17/5cb6de9f28d60.jpg" alt></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/04/17/5cb6dec2a8b4c.jpg" alt></p><p><img src="https://i.loli.net/2019/04/17/5cb6dedbd7064.jpg" alt></p><p><strong>【使用示例】</strong></p><p><strong>1）查找指定时间内修改过的文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 查找当前目录下2天内访问过的文件 </span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# find . -atime -2</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6df093502b.jpg" alt></p><p><strong>2）用-name指定关键字查找</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#查找/var/log下5天以前修改过的以.log结尾的所有文件 </span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# find /var/log -mtime +5 -name &quot;*.log&quot;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6df3f5933a.jpg" alt></p><p><strong>3）利用“！”反向查找</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#查找当前目录下非目录文件 </span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# find . ! -type d</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/17/5cb6df79f104e.jpg" alt></p><p><strong>小练习：</strong></p><p><strong>1、按照文件大小来查找文件</strong></p><p><strong>2、按照文件或目录的权限来查找文件</strong></p><p><strong>3、查找文件时希望忽略一个或多个目录的方法</strong></p><p><strong>4、按照文件的更新时间来差找文件</strong></p><p><strong>5、按照文件或目录的归属用户和用户组来查找文件</strong></p><p>至此，Linux系统文件和目录的操作命令部分已经写完了。但是，这并不是所有命令（Linux系统核心命令使用频率较高的越有150条），而是和运维工作息息相关的最最最常用的几个命令，作为初学者必须首先掌握上述这些命令，再结合实际工作中的需要去掌握其它命令。其它命令章节也是遵循此原则来写，后续不再赘述。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;pwd：显示当前所在的位置&quot;&gt;&lt;a href=&quot;#pwd：显示当前所在的位置&quot; class=&quot;headerlink&quot; title=&quot;pwd：显示当前所在的位置&quot;&gt;&lt;/a&gt;pwd：显示当前所在的位置&lt;/h2&gt;&lt;p&gt;pwd命令是“print working directory”中每个单词的首字母缩写，其功能是显示当前工作目录的绝对路径。在实际工作中，我们在命令行操作命令时，经常会在各个目录路径之间进行切换，此时可使用pwd命令快速查看当前我们所在的目录路径。
    
    </summary>
    
      <category term="核心命令" scheme="https://kkutysllb.cn/categories/%E6%A0%B8%E5%BF%83%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Linux" scheme="https://kkutysllb.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>2019-04-10-Linux系统核心命令-第一篇《关机、重启命令》</title>
    <link href="https://kkutysllb.cn/2019/04/15/2019-04-10-Linux%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E5%91%BD%E4%BB%A4-%E7%AC%AC%E4%B8%80%E7%AF%87%E3%80%8A%E5%85%B3%E6%9C%BA%E3%80%81%E9%87%8D%E5%90%AF%E5%91%BD%E4%BB%A4%E3%80%8B/"/>
    <id>https://kkutysllb.cn/2019/04/15/2019-04-10-Linux系统核心命令-第一篇《关机、重启命令》/</id>
    <published>2019-04-15T14:52:14.000Z</published>
    <updated>2019-04-19T02:49:06.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux命令行的概述"><a href="#Linux命令行的概述" class="headerlink" title="Linux命令行的概述"></a><strong><em>Linux命令行的概述</em></strong></h2><p>众所周知，Linux是一个主要通过命令行来进行管理的操作系统，即通过键盘输入指令来管理系统的相关操作，包括但不限于编辑文件、启动停止服务等。这和初学者曾经使用的Windows系统使用鼠标点击的可视化管理大不相同。<a id="more"></a></p><p>使用鼠标可视化管理的优势是简单、容易上手，但缺点是不便于快速、批量、自动化管理系统，而且感觉系统很臃肿，这个时候Linux系统的命令行管理优势就凸显了。使用Linux命令行管理，不但可以批量、自动化管理，而且还可以实现智能化、可视化管理；当然，后者需要开发人员配合开发管理界面来完成。但是无论如何，Linux系统的优势基因还是快速、批量、自动化、智能化管理系统及处理业务。</p><h2 id="Linux命令行介绍"><a href="#Linux命令行介绍" class="headerlink" title="Linux命令行介绍"></a><strong><em>Linux命令行介绍</em></strong></h2><p>安装Linux系统时，无论是使用文本模式（命令行）安装，还是使用图形模式安装，最终管理系统的任务都会落到命令行之上。</p><p>大多数互联网企业在安装系统时甚至不会安装图形管理软件包，而是直接使用文本模式安装，因此登录后直接面对的就是命令行的界面，如下图所示：</p><p><img src="https://i.loli.net/2019/04/16/5cb4c4260d92b.jpg" alt></p><p>Linux命令行结尾的提示符有<strong>“#”</strong>和<strong>“$”</strong>两种不同的符号，代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ～]#  # 这是超级管理员root用户对应的命令行。</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/16/5cb4c3878bc00.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[kkutysllb@C7-Server01 ～]$  # 这是普通用户kkutysllb对应的命令行。</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/16/5cb4c3aad0cdb.jpg" alt></p><p>Linux命令提示符由PS1环境变量控制。示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ~]# set | grep PS1</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/16/5cb4c3e227c5d.jpg" alt></p><p>这里的PS1=[\u@\h\W]\$，可以通过全局配置文件/etc/bashrc或/etc/profile进行按需配置和调整。</p><h2 id="Linux命令行常用快捷键"><a href="#Linux命令行常用快捷键" class="headerlink" title="Linux命令行常用快捷键"></a><strong><em>Linux命令行常用快捷键</em></strong></h2><p>这里需要特别说明一下的是，在企业工作中，管理Linux时一般不会直接采用键盘、显示器登录系统，而是会通过网络在远程进行管理，因此，需要通过远程连接工具连接到Linux系统中。目前最常用的Linux远程连接工具为：<code>SecureCRT</code>和<code>Xshell</code>客户端软件，因此，本节涉及的常用命令快捷键也是基于这两款客户端软件的，其他软件的快捷键使用情况与此基本类似。提高Linux运维效率的30个命令行常用快捷键如下：</p><p><img src="https://i.loli.net/2019/04/15/5cb49d0c62a4e.jpg" alt></p><p><img src="https://i.loli.net/2019/04/15/5cb49d461dd57.jpg" alt></p><h2 id="Linux重启、关机、注销命令"><a href="#Linux重启、关机、注销命令" class="headerlink" title="Linux重启、关机、注销命令"></a><strong><em>Linux重启、关机、注销命令</em></strong></h2><h3 id="1、shutdown-命令常用操作"><a href="#1、shutdown-命令常用操作" class="headerlink" title="1、shutdown 命令常用操作"></a><strong>1、shutdown 命令常用操作</strong></h3><p>shutdown是一个用来安全关闭或重启Linux系统的命令，系统在关闭之前会通知所有的登录用户，系统即将关闭，此时所有的新用户都不可以登录，与shutdown类似功能的命令还有init、halt、poweroff、reboot。</p><p><strong>语法格式为：shutdown [OPTION]…… TIME [MESSAGE]</strong></p><p>通常情况下，我们执行的shutdown命令为shutdown-h now或shutdown-r now</p><p><strong>shutdown命令常用的参数选项如下：</strong></p><p><img src="https://i.loli.net/2019/04/15/5cb49d79c2444.jpg" alt></p><p><strong>【使用举例】</strong></p><p><strong>1）10分钟后关闭或重启系统</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#关机</span><br><span class="line">[root@C7-Server01 ~]# shutdown -h +10</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/16/5cb4c568e1f86.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#重启</span><br><span class="line">[root@C7-Server01 ~]# shutdown -r +10</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/16/5cb4c59a4bcbc.jpg" alt></p><p><strong>2）11点整定时关闭或重启系统</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#11点整重启 </span><br><span class="line">[root@C7-Server01 ~]# shutdown -r 11:00</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/16/5cb4c5fe79361.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#11点整关闭</span><br><span class="line">[root@C7-Server01 ~]# shutdown -h 11:00</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/16/5cb4c5d27a5df.jpg" alt></p><p><strong>3）立即关闭或重启Linux系统的命令如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#立即关机 </span><br><span class="line">[root@C7-Server01 ~]# shutdown -h now</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/16/5cb4c63c49b34.jpg" alt><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#立即重启</span><br><span class="line">[root@C7-Server01 ~]# shutdown -r now</span><br></pre></td></tr></table></figure></p><p><img src="https://i.loli.net/2019/04/16/5cb4c6c24e7bc.jpg" alt></p><h3 id="2、halt-poweroff-reboot命令的常用操作"><a href="#2、halt-poweroff-reboot命令的常用操作" class="headerlink" title="2、halt/poweroff/reboot命令的常用操作"></a><strong>2、halt/poweroff/reboot命令的常用操作</strong></h3><p>从RedHat或CentOS 6开始，你会发现halt、poweroff、reboot这三个命令对应的都是同一个man帮助文档。在CentOS 6时代，而halt、poweroff是reboot命令的链接文件，而在CentOS 7时代，这三个命令都是systemctl的连接文件。</p><p><strong>语法格式为：halt/poweroff/reboot [OPTIONS]</strong></p><p>通常情况下，我们执行这三个命令时都不带任何参数。因此，这三个命令的选项参数也就没什么好研究的。</p><p><strong>【使用举例】</strong></p><p><strong>1）使用halt命令完成关机</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ~]# halt</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/16/5cb4c6e8bfd29.jpg" alt></p><p><strong>2）使用poweroff命令完成关机</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ~]# poweroff</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/16/5cb4c76403883.jpg" alt></p><p><strong>3）使用reboot命令重启系统</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ~]# reboot</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/16/5cb4c7ff91951.jpg" alt></p><p>除此之外，还可以使用init指令完成关机或重启指令，执行init 0为关机，执行init 6为重启，这是因为0和6是系统的两个运行级别，分别对应关机和重启。你们可以在自己的实验环境尝试执行看看。。。</p><h3 id="3、常见不常见关机、重启和注销的命令列表"><a href="#3、常见不常见关机、重启和注销的命令列表" class="headerlink" title="3、常见不常见关机、重启和注销的命令列表"></a><strong>3、常见不常见关机、重启和注销的命令列表</strong></h3><p><img src="https://i.loli.net/2019/04/15/5cb4a00a3ba22.jpg" alt></p><p>Linux命令正是组成Linux系统最核心、重要的基础之一，因此，大家只要牢牢掌握基础命令，在日后linux运维、shell编程、云计算/大数据、甚至Python自动化运维都能如鱼得水。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Linux命令行的概述&quot;&gt;&lt;a href=&quot;#Linux命令行的概述&quot; class=&quot;headerlink&quot; title=&quot;Linux命令行的概述&quot;&gt;&lt;/a&gt;&lt;strong&gt;&lt;em&gt;Linux命令行的概述&lt;/em&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;众所周知，Linux是一个主要通过命令行来进行管理的操作系统，即通过键盘输入指令来管理系统的相关操作，包括但不限于编辑文件、启动停止服务等。这和初学者曾经使用的Windows系统使用鼠标点击的可视化管理大不相同。
    
    </summary>
    
      <category term="核心命令" scheme="https://kkutysllb.cn/categories/%E6%A0%B8%E5%BF%83%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Linux" scheme="https://kkutysllb.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>2019-04-05-CentOS操作系统6.x版本与7.x版本的区别</title>
    <link href="https://kkutysllb.cn/2019/04/15/2019-04-05-CentOS%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F6-x%E7%89%88%E6%9C%AC%E4%B8%8E7-x%E7%89%88%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://kkutysllb.cn/2019/04/15/2019-04-05-CentOS操作系统6-x版本与7-x版本的区别/</id>
    <published>2019-04-15T08:01:49.000Z</published>
    <updated>2019-04-15T17:11:58.206Z</updated>
    
    <content type="html"><![CDATA[<p>Centos7与6之间最大的差别就是初始化技术的不同，7采用的初始化技术是Systemd,并行的运行方式，除了这一点之外，服务启动、开机启动文件、网络命令方面等等也存在不同。<a id="more"></a></p><hr><h2 id="1-系统初始化技术"><a href="#1-系统初始化技术" class="headerlink" title="1.系统初始化技术"></a><strong><em>1.系统初始化技术</em></strong></h2><p>在Linux系统常用系统初始化技术主要有三种：Sysvinit技术、Upstart技术和Systemd技术。在CentOS 6时代，主要使用sysvinit技术完成系统的初始化，其实现原理通过调用各种服务的shell脚本完成初始化工作。而在CentOS 7时代，开始采用Systemd技术来完成系统的初始化工作，其最大的特点的各类服务可以并发完成。同时，在CentOS 7时代也保留Sysvinit技术。三种不同的初始化技术的优缺点如下：</p><hr><h3 id="Sysvinit技术"><a href="#Sysvinit技术" class="headerlink" title="Sysvinit技术"></a><strong>Sysvinit技术</strong></h3><p><strong>特点：</strong></p><p>1.系统第1个进程为init;</p><p>2.init进程是所有进程的父进程，不可kill；</p><p>3.大多数Linux发行版的init系统是和SystemV相兼容的，被称为sysvinti</p><p>4.代表系统：CentOS5 CentOS6</p><p><strong>优点：</strong></p><p>sysvinit运行非常良好，概念简单清晰，它主要依赖于shell脚。所以，如果大家开始学习shell编程时，建议安装一个CentOS6系统。</p><p><strong>缺点：</strong></p><p>1.按照一定顺序执行——&gt;启动太慢。</p><p>2.很容易hang住，fstab与nfs挂载问题</p><hr><h3 id="Upstart技术"><a href="#Upstart技术" class="headerlink" title="Upstart技术"></a><strong>Upstart技术</strong></h3><p>CentOS6采用了upstart技术代替sysVinit进行引导，Upstart对rc.sysinit脚本做了大量的优化，缩短了系统初始化的启动时间。但是CentOS6为了简便管理员的操作，upstart的很多特性并没有凸显或直接不支持。代表系统：CentOS6, Ubuntu14, 从CentOS7, Ubuntu15开始使用systemd。</p><hr><h3 id="Systemd技术"><a href="#Systemd技术" class="headerlink" title="Systemd技术"></a><strong>Systemd技术</strong></h3><p>新系统都会采用的技术（RedHat7,CentOS7,Ubuntu15等），设计目标是克服sysvinit固有的缺点，提高系统的启动速度。和Sysvinit兼容，降低迁移成本，最主要优点：并行启动，Pid为1的进程。</p><h2 id="2-在yum源上的优化"><a href="#2-在yum源上的优化" class="headerlink" title="2.在yum源上的优化"></a><strong><em>2.在yum源上的优化</em></strong></h2><p>在centos6的时候，默认是从官方源下载rpm包的，由于是国外的yum源很慢不能用，CentOS7在这里做了优化，当我们使用yum安装软件的时候，默认不会再从官方下载，而是自动寻找离自己地理位置最近的yum源开始下载。</p><h3 id="3-网络命令"><a href="#3-网络命令" class="headerlink" title="3.网络命令"></a><strong><em>3.网络命令</em></strong></h3><p>如果在安装系统的时候选择minimal，会比之前6的时候以更小的包来安装，比如：vim、ifconfig、route、setup、netstat等等都不会安装。因此，使用CentOS7通过最小化安装后，还需挂在ISO完成上述常用工具的安装。如果采用脚本自动化安装，可以将上述的工具的安装命令写入到安装到脚本中。</p><p><strong><em>4.字符集修改</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/etc/locale.conf  #字符集配置文件</span><br><span class="line"></span><br><span class="line"> localectl set-locale LANG=zh_CN.UTF-8  # 命令行一步到位 </span><br><span class="line"></span><br><span class="line"> [root@CentOS7 ~]# localectl set-locale LANG=zh_CN.UTF-8 </span><br><span class="line"></span><br><span class="line">[root@CentOS7 ~]# localectl status   </span><br><span class="line"></span><br><span class="line">System Locale: LANG=zh_CN.UTF-8   </span><br><span class="line"></span><br><span class="line">VC Keymap: us   X11 Layout: us</span><br></pre></td></tr></table></figure><h2 id="5-开机启动管理"><a href="#5-开机启动管理" class="headerlink" title="5.开机启动管理"></a><strong><em>5.开机启动管理</em></strong></h2><p>/etc/rc.local 这个文件还是存在，不过如果我们还想继续使用这种方式需要给它加执行权限chmod +x /etc/rc.d/rc.local</p><p><strong><em>system一统天下 snapshot(支持快照)</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">systemctl status cron.service #查看定时任务状态</span><br><span class="line">systemctl stop cron.service#关闭定时任务</span><br><span class="line">systemctl status cron.service#查看操作情况</span><br><span class="line">systemctl list-unit-files|grep enable  #查看当前正在运行的服务</span><br><span class="line">systemctl disable postfix.service #关闭邮件服务</span><br><span class="line">systemctl list-unit-files|grep postfix #查看邮件服务是否开启</span><br><span class="line">systemctl stop firewalld.service #关闭防火墙</span><br><span class="line">systemctl is-enable #开启的服务 systemctl disable#关闭的服务</span><br></pre></td></tr></table></figure><h2 id="6-运行级别runlevel"><a href="#6-运行级别runlevel" class="headerlink" title="6.运行级别runlevel"></a><strong><em>6.运行级别runlevel</em></strong></h2><p><strong><em>/etc/inittab 是无效的，由system target 替代。</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#永久生效下次登录生效 </span><br><span class="line"></span><br><span class="line">systemctl get-default graphical.target  # 切换到5 </span><br><span class="line"></span><br><span class="line">systemctl get-default multi-user.target # 切换到3 </span><br><span class="line"></span><br><span class="line">##临时生效的话  </span><br><span class="line"></span><br><span class="line">init3</span><br></pre></td></tr></table></figure></p><p><strong><em>七种种运行级别如下</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 ~]# ls -lh /usr/lib/systemd/system/runlevel*.target</span><br></pre></td></tr></table></figure></p><p><img src="https://i.loli.net/2019/04/15/5cb444f1555c0.jpg" alt></p><h2 id="7-网卡名称"><a href="#7-网卡名称" class="headerlink" title="7.网卡名称"></a><strong><em>7.网卡名称</em></strong></h2><p>CentOS7的网卡名称太长，这不符合我们的使用习惯，增加了管理难度，最简单粗暴的方法是在安装系统的时候就把网卡名改了。当然，安装好的系统也是可以修改的。下面分别介绍两种方法。</p><h3 id="方法一：-推荐）"><a href="#方法一：-推荐）" class="headerlink" title="方法一：(推荐）"></a><strong>方法一：(推荐）</strong></h3><p>在进入安装界面的时候把光标移动到Install CentOS7,按下tab键，在后面输入“net ifnames=0 biosdevname=0”回车即可。</p><p><img src="https://i.loli.net/2019/04/15/5cb43e1e5f150.jpg" alt></p><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a><strong>方法二：</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#进入网卡配置文件目录</span><br><span class="line"></span><br><span class="line">[root@centos7 ~]# cd /etc/sysconfig/network-scripts/</span><br><span class="line"></span><br><span class="line">#重命名网卡</span><br><span class="line"></span><br><span class="line">[root@centos7 network-scripts]# mv ifcfg-eno16777736 ifcfg-eth0</span><br><span class="line"></span><br><span class="line">#修改配置文件NAME、DEVICE</span><br><span class="line"></span><br><span class="line">[root@centos7 network-scripts]# vim ifcfg-eth0TYPE=Ethernet</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">PEERDNS=yes</span><br><span class="line">PEERROUTES=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">NAME=eth0UUID=552c01f7-fd9d-4f19-913e-379a2bf5a467</span><br><span class="line">DEVICE=eth0</span><br><span class="line">ONBOOT=yes</span><br><span class="line">IPADDR=10.0.0.111</span><br><span class="line">&quot;ifcfg-eth0&quot; 14L, 239C written</span><br><span class="line"></span><br><span class="line">#修改grub</span><br><span class="line"></span><br><span class="line">sed -i.bak &apos;s#crashkernel=auto rhgb quiet#crashkernel=auto rhgb net.ifnames=0 biosdevname=0 quiet#g&apos; /etc/sysconfig/grub</span><br><span class="line">[root@centos7 network-scripts]# vim /etc/sysconfig/grub GRUB_TIMEOUT=5</span><br><span class="line">GRUB_DISTRIBUTOR=&quot;$(sed &apos;s, release .*$,,g&apos; /etc/system-release)&quot;</span><br><span class="line">GRUB_DEFAULT=saved</span><br><span class="line">GRUB_DISABLE_SUBMENU=true</span><br><span class="line">GRUB_TERMINAL_OUTPUT=&quot;console&quot;</span><br><span class="line">GRUB_CMDLINE_LINUX=&quot;crashkernel=auto rhgb net.ifnames=0 biosdevname=0 quiet&quot;</span><br><span class="line">&quot;/etc/sysconfig/grub&quot; 7L, 263C written</span><br><span class="line"></span><br><span class="line">#生成启动菜单</span><br><span class="line"></span><br><span class="line">[root@centos7 network-scripts]# grub2-mkconfig -o /boot/grub2/grub.cfg </span><br><span class="line">Generating grub configuration file ...</span><br><span class="line">Found linux image: /boot/vmlinuz-3.10.0-327.el7.x86_64</span><br><span class="line">Found initrd image: /boot/initramfs-3.10.0-327.el7.x86_64.img</span><br><span class="line">Found linux image: /boot/vmlinuz-0-rescue-7ed5d4eebe4c43e3aadbda68cd0ef311</span><br><span class="line">Found initrd image: /boot/initramfs-0-rescue-7ed5d4eebe4c43e3aadbda68cd0ef311.imgdone</span><br><span class="line">#重启系统生效</span><br><span class="line">[root@centos7 network-scripts]# reboot</span><br></pre></td></tr></table></figure><h2 id="8-桌面系统"><a href="#8-桌面系统" class="headerlink" title="8.桌面系统"></a><strong><em>8.桌面系统</em></strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[CentOS6] </span><br><span class="line"></span><br><span class="line">GNOME 2.x</span><br><span class="line"></span><br><span class="line">[CentOS7] </span><br><span class="line"></span><br><span class="line">GNOME 3.x（GNOME Shell）</span><br></pre></td></tr></table></figure><h2 id="9-文件系统"><a href="#9-文件系统" class="headerlink" title="9.文件系统"></a><strong><em>9.文件系统</em></strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[CentOS6] </span><br><span class="line"></span><br><span class="line">ext4 </span><br><span class="line"></span><br><span class="line">[CentOS7] </span><br><span class="line"></span><br><span class="line">xfs</span><br></pre></td></tr></table></figure><h2 id="10-内核版本"><a href="#10-内核版本" class="headerlink" title="10.内核版本"></a><strong><em>10.内核版本</em></strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[CentOS6] </span><br><span class="line"></span><br><span class="line">2.6.x-x </span><br><span class="line"></span><br><span class="line">[CentOS7] </span><br><span class="line"></span><br><span class="line">3.10.x-x</span><br></pre></td></tr></table></figure><h2 id="11-启动加载器"><a href="#11-启动加载器" class="headerlink" title="11.启动加载器"></a><strong><em>11.启动加载器</em></strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[CentOS6] </span><br><span class="line"></span><br><span class="line">GRUB Legacy (+efibootmgr)</span><br><span class="line"></span><br><span class="line">[CentOS7] </span><br><span class="line"></span><br><span class="line">GRUB2</span><br></pre></td></tr></table></figure><h2 id="12-防火墙"><a href="#12-防火墙" class="headerlink" title="12.防火墙"></a><strong><em>12.防火墙</em></strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[CentOS6] </span><br><span class="line"></span><br><span class="line">iptables</span><br><span class="line"></span><br><span class="line">[CentOS7] </span><br><span class="line"></span><br><span class="line">firewalld</span><br></pre></td></tr></table></figure><h2 id="13-默认数据库"><a href="#13-默认数据库" class="headerlink" title="13.默认数据库"></a><strong><em>13.默认数据库</em></strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[CentOS6] </span><br><span class="line"></span><br><span class="line">MySQL </span><br><span class="line"></span><br><span class="line">[CentOS7] </span><br><span class="line"></span><br><span class="line">MariaDB</span><br></pre></td></tr></table></figure><h2 id="14-文件结构"><a href="#14-文件结构" class="headerlink" title="14.文件结构"></a><strong><em>14.文件结构</em></strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[CentOS6] </span><br><span class="line"></span><br><span class="line">/bin, /sbin, /lib, and /lib64在/下 </span><br><span class="line"></span><br><span class="line">[CentOS7] </span><br><span class="line"></span><br><span class="line">/bin, /sbin, /lib, and /lib64移到/usr下</span><br></pre></td></tr></table></figure><h2 id="15-主机名"><a href="#15-主机名" class="headerlink" title="15.主机名"></a><strong><em>15.主机名</em></strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[CentOS7] </span><br><span class="line"></span><br><span class="line">/etc/hostname</span><br></pre></td></tr></table></figure><h2 id="16-时间同步"><a href="#16-时间同步" class="headerlink" title="16.时间同步"></a><strong><em>16.时间同步</em></strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[CentOS6] </span><br><span class="line"></span><br><span class="line">$ ntp </span><br><span class="line"></span><br><span class="line">$ ntpq -p </span><br><span class="line"></span><br><span class="line">[CentOS7] </span><br><span class="line"></span><br><span class="line">$ chrony </span><br><span class="line"></span><br><span class="line">$ chronyc sources</span><br></pre></td></tr></table></figure><h2 id="17-修改时间"><a href="#17-修改时间" class="headerlink" title="17.修改时间"></a><strong><em>17.修改时间</em></strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[CentOS6] </span><br><span class="line"></span><br><span class="line">$ vim /etc/sysconfig/clock    ZONE=&quot;Asia/Shanghai&quot;    UTC=fales </span><br><span class="line"></span><br><span class="line">$ sudo ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime </span><br><span class="line"></span><br><span class="line">[CentOS7] </span><br><span class="line"></span><br><span class="line">$ timedatectl set-timezone Asia/Shanghai </span><br><span class="line"></span><br><span class="line">$ timedatectl status</span><br></pre></td></tr></table></figure><h2 id="18-修改地区"><a href="#18-修改地区" class="headerlink" title="18.修改地区"></a><strong><em>18.修改地区</em></strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[CentOS6] </span><br><span class="line"></span><br><span class="line">$ vim /etc/sysconfig/i18n    LANG=&quot;zh_CN.utf8&quot; </span><br><span class="line"></span><br><span class="line">$ /etc/sysconfig/i18n $ locale </span><br><span class="line"></span><br><span class="line">[CentOS7] </span><br><span class="line"></span><br><span class="line">$ localectl set-locale LANG=zh_CN.utf8 </span><br><span class="line"></span><br><span class="line">$ localectl status</span><br></pre></td></tr></table></figure><h2 id="19-服务相关"><a href="#19-服务相关" class="headerlink" title="19.服务相关"></a><strong><em>19.服务相关</em></strong></h2><h3 id="1）启动停止"><a href="#1）启动停止" class="headerlink" title="1）启动停止"></a><strong>1）启动停止</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[CentOS6] </span><br><span class="line"></span><br><span class="line">$ service service_name start </span><br><span class="line"></span><br><span class="line">$ service service_name stop </span><br><span class="line"></span><br><span class="line">$ service sshd restart/status/reload </span><br><span class="line"></span><br><span class="line">[CentOS7] </span><br><span class="line"></span><br><span class="line">$ systemctl start service_name </span><br><span class="line"></span><br><span class="line">$ systemctl stop service_name </span><br><span class="line"></span><br><span class="line">$ systemctl restart/status/reload sshd</span><br></pre></td></tr></table></figure><h3 id="2-自启动"><a href="#2-自启动" class="headerlink" title="2) 自启动"></a><strong>2) 自启动</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[CentOS6] </span><br><span class="line"></span><br><span class="line">$ chkconfig service_name on/off </span><br><span class="line"></span><br><span class="line">[CentOS7] </span><br><span class="line"></span><br><span class="line">$ systemctl enable service_name </span><br><span class="line"></span><br><span class="line">$ systemctl disable service_name</span><br></pre></td></tr></table></figure><h3 id="3-服务一览"><a href="#3-服务一览" class="headerlink" title="3) 服务一览"></a><strong>3) 服务一览</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[CentOS6] </span><br><span class="line"></span><br><span class="line">$ chkconfig --list </span><br><span class="line"></span><br><span class="line">[CentOS7] </span><br><span class="line"></span><br><span class="line">$ systemctl list-unit-files </span><br><span class="line"></span><br><span class="line">$ systemctl --type service</span><br></pre></td></tr></table></figure><h3 id="4-强制停止"><a href="#4-强制停止" class="headerlink" title="4) 强制停止"></a><strong>4) 强制停止</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[CentOS6] </span><br><span class="line"></span><br><span class="line">$ kill -9 &lt;PID&gt; </span><br><span class="line"></span><br><span class="line">[CentOS7] </span><br><span class="line"></span><br><span class="line">$ systemctl kill --signal=9 sshd</span><br></pre></td></tr></table></figure><h2 id="20-网络"><a href="#20-网络" class="headerlink" title="20.网络"></a><strong><em>20.网络</em></strong></h2><h3 id="1）网络信息"><a href="#1）网络信息" class="headerlink" title="1）网络信息"></a><strong>1）网络信息</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[CentOS6] </span><br><span class="line"></span><br><span class="line">$ netstat </span><br><span class="line"></span><br><span class="line">$ netstat -I </span><br><span class="line"></span><br><span class="line">$ netstat -n </span><br><span class="line"></span><br><span class="line">[CentOS7] </span><br><span class="line"></span><br><span class="line">$ ip n </span><br><span class="line"></span><br><span class="line">$ ip -s l </span><br><span class="line"></span><br><span class="line">$ ss</span><br></pre></td></tr></table></figure><h3 id="2）IP地址MAC地址"><a href="#2）IP地址MAC地址" class="headerlink" title="2）IP地址MAC地址"></a><strong>2）IP地址MAC地址</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[CentOS6] </span><br><span class="line"></span><br><span class="line">$ ifconfig -a </span><br><span class="line"></span><br><span class="line">[CentOS7] </span><br><span class="line"></span><br><span class="line">$ ip address show</span><br></pre></td></tr></table></figure><h3 id="3）路由"><a href="#3）路由" class="headerlink" title="3）路由"></a><strong>3）路由</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[CentOS6] </span><br><span class="line"></span><br><span class="line">$ route -n </span><br><span class="line"></span><br><span class="line">$ route -A inet6 -n </span><br><span class="line"></span><br><span class="line">[CentOS7] </span><br><span class="line"></span><br><span class="line">$ ip route show </span><br><span class="line"></span><br><span class="line">$ ip -6 route show</span><br></pre></td></tr></table></figure><h2 id="21-重启关闭"><a href="#21-重启关闭" class="headerlink" title="21.重启关闭"></a><strong><em>21.重启关闭</em></strong></h2><h3 id="1）关闭"><a href="#1）关闭" class="headerlink" title="1）关闭"></a><strong><em>1）关闭</em></strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[CentOS6] </span><br><span class="line"></span><br><span class="line">$ shutdown -h now  </span><br><span class="line"></span><br><span class="line">[CentOS7] </span><br><span class="line"></span><br><span class="line">$ poweroff </span><br><span class="line"></span><br><span class="line">$ systemctl poweroff</span><br></pre></td></tr></table></figure><h3 id="2）重启"><a href="#2）重启" class="headerlink" title="2）重启"></a><strong><em>2）重启</em></strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[CentOS6] </span><br><span class="line"></span><br><span class="line">$ reboot </span><br><span class="line"></span><br><span class="line">$ shutdown -r now </span><br><span class="line"></span><br><span class="line">[CentOS7] </span><br><span class="line"></span><br><span class="line">$ reboot </span><br><span class="line"></span><br><span class="line">$ systemctl reboot</span><br></pre></td></tr></table></figure><h3 id="3）单用户模式"><a href="#3）单用户模式" class="headerlink" title="3）单用户模式"></a><strong><em>3）单用户模式</em></strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[CentOS6] </span><br><span class="line"></span><br><span class="line">$ init S </span><br><span class="line"></span><br><span class="line">[CentOS7] </span><br><span class="line"></span><br><span class="line">$ systemctl rescue</span><br></pre></td></tr></table></figure><h3 id="4）启动模式"><a href="#4）启动模式" class="headerlink" title="4）启动模式"></a><strong><em>4）启动模式</em></strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[CentOS6] </span><br><span class="line"></span><br><span class="line">$ vim /etc/inittab   id:3:initdefault: </span><br><span class="line"></span><br><span class="line">$ startx </span><br><span class="line"></span><br><span class="line">[CentOS7] </span><br><span class="line"></span><br><span class="line">$ systemctl isolate multi-user.target </span><br><span class="line"></span><br><span class="line">$systemctl isolate graphical.target </span><br><span class="line"></span><br><span class="line">#默认 </span><br><span class="line"></span><br><span class="line">$ systemctl set-default graphical.target </span><br><span class="line"></span><br><span class="line">$ systemctl set-default multi-user.target </span><br><span class="line"></span><br><span class="line">#当前 </span><br><span class="line"></span><br><span class="line">$ systemctl get-default</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Centos7与6之间最大的差别就是初始化技术的不同，7采用的初始化技术是Systemd,并行的运行方式，除了这一点之外，服务启动、开机启动文件、网络命令方面等等也存在不同。
    
    </summary>
    
      <category term="Linux" scheme="https://kkutysllb.cn/categories/Linux/"/>
    
    
      <category term="基础概念" scheme="https://kkutysllb.cn/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>2019-03-30-Linux的文件系统</title>
    <link href="https://kkutysllb.cn/2019/04/15/2019-03-30-Linux%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>https://kkutysllb.cn/2019/04/15/2019-03-30-Linux的文件系统/</id>
    <published>2019-04-15T07:41:27.000Z</published>
    <updated>2019-04-15T17:29:35.992Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux目录结构的特点"><a href="#Linux目录结构的特点" class="headerlink" title="Linux目录结构的特点"></a>Linux目录结构的特点</h2><p>Windows系统目录和磁盘是强对应的关系，联系很紧密，例如c盘下的目录和文件不可能和D盘的目录有关联或交集。而Linux系统目录与之不同，Linux系统的目录和磁盘等设备是不直接关联的，每个目录都可以关联（官称：挂载）在不同的设备（例如磁盘）上，例如：看似有包含关系的几个目录/、/etc、/boot、/var很可能是在不同的分区或磁盘上。</p><a id="more"></a><hr><p>在Linux中，一切皆是文件。Linux是以文件的方式来管理系统中各个组件，所有的文件存储都以根（”/“）开始，整个文件系统结构就像一颗倒挂的”树“。Linux文件系统的目录结构如图所示：</p><p><img src="https://i.loli.net/2019/04/15/5cb4a1d58e2a6.jpg" alt></p><p>在Linux中，一切从“根”开始，“/”是所有目录的起点（顶点），Linux根下面的目录是一个有层次的树状结构。我们熟悉的Windows系统，目录和磁盘是强对应的关系，联系很紧密，例如c盘下的目录和文件不可能和D盘的目录有关联或交集。而Linux系统目录与之不同，Linux系统的目录和磁盘等设备是不直接关联的，每个目录都可以关联（官称：挂载）在不同的设备（例如磁盘）上，例如：看似有包含关系的几个目录/、/etc、/boot、/var很可能是在不同的分区或磁盘上。</p><p>在逻辑上，所有的目录（包括目录下的子目录）都在最高级别的目录“/”下，根（“/”）目录是所有目录的起始点（顶点），而实际上访问目录/、/etc、/boot、/var时，可能是在访问完全不同的分区和磁盘。</p><p>Linux下面的设备（磁盘），如果不挂载是看不到入口的，就像没窗没门的房间，是不能被正常使用的。如果要访问设备，就必须为设备开一个入口，这个入口就是挂载点。挂载点实质就是一个目录，开入口的过程就是将挂载点和磁盘设备关联，即挂载。</p><p><strong>Linux的根目录特点</strong></p><p><strong>1、根目录“/“是所有目录的顶点</strong>。</p><p><strong>2、目录结构像一颗倒挂的“树”</strong>。</p><p><strong>3、目录和分区没有关联，因此不同目录可以映射不同的分区。</strong></p><p><strong>4、分区或设备要想访问，必须将其与目录挂载，此时挂载的目录相当于分区的入口。</strong></p><p><strong>5、挂载目录的指令为mount</strong>。</p><p><strong>6、系统开机自动挂载的配置文件为/etc/fstab</strong>。</p><h2 id="Linux目录的层次标准FHS"><a href="#Linux目录的层次标准FHS" class="headerlink" title="Linux目录的层次标准FHS"></a>Linux目录的层次标准FHS</h2><p>FHS全称为Filesystem Hierarchy Standard，中文意思是目录层次标准，是Linux的目录规范标准。详细见<a href="http://www.pathname.com/fhs/。FHS定义了两层规范：" target="_blank" rel="noopener">http://www.pathname.com/fhs/。FHS定义了两层规范：</a></p><ul><li>第一层是“/”目录下的各个目录应该放什么文件数据。</li><li>第二层是针对<strong>/usr</strong>（Unix software resource）和<strong>/var</strong>(Variable data)这两个目录的子目录在定义的。</li></ul><p><strong>参考资料：</strong></p><ul><li><a href="http://www.pathname.com/fhs/" target="_blank" rel="noopener">http://www.pathname.com/fhs/</a></li><li><a href="http://www.ibm.com/developerworks/linux/library/l-proc/index.html" target="_blank" rel="noopener">http://www.ibm.com/developerworks/linux/library/l-proc/index.html</a></li></ul><p>所有目录的命名和结构是有规范，在Linux的目录结构遵照FHS规范。常用目录和子目录的作用如下：</p><p><strong>/bin ：</strong>存放普通用户或管理员使用所有二进制命令文件。</p><p><strong>/sbin：</strong>存放管理员使用的所有二进制命令文件。</p><p><strong>/boot :</strong> 存放Linux系统启动引导的安装文件存放目录。</p><p><strong>/dev ：</strong> 存放特殊存储文件或设备文件存放的目录，比如：cpu、内存、硬盘、光驱、鼠标、键盘等。</p><p>/<strong>etc ：</strong> 存放应用程序配置文件，比如：yum或rpm安装软件的配置文件存放路径，很多服务的启动程序存放的路径。</p><p><strong>/home ：</strong>非关键性目录，是可选目录，是普通用户的家目录。一般每个用户的家目录，默认为此目录下与用户名同名的目录。</p><p><strong>/lib：</strong>存放基本的共享库文件或Linux内核模块文件,为系统启动或根文件系统上的应用程序（/bin,/sbin等）提供共享库，以及为内核提供内核模块。</p><p>​    <strong><em>libc.so.</em>：*</strong>动态链接的C库，在64位系统下，有可能位于/lib64目录下。</p><p>​     <strong><em>ld</em>：*</strong>运行时链接器/加载器，在64位系统下，有可能位于/lib64目录下。</p><p>​     <strong><em>modules：</em></strong>用于存储内核模块的目录，在64系统下，也位于/lib目录下。</p><p><strong>/lib64：</strong>存放64位操作系统基本的共享库文件或Linux内核模块文件。</p><p><strong>/media：</strong>便携式设备挂载点。比如：U盘，光盘，移动硬盘等。</p><p><strong>/mnt：</strong>其他文件系统的临时挂载点。</p><p><strong>/opt：</strong>附件应用程序的安装位置，比如第三方应用程序devstack。</p><p><strong>/root ：</strong>管理员root用户的家目录，也是可选目录，并非必选。因为，管理员root在生产环境下一班不允许登录。</p><p><strong>/srv：</strong>存放此系统专门提供给运行此系统应用程序上的数据。</p><p><strong>/tmp：</strong>为那些会产生临时文件的程序用于存储临时文件的目录，可供所有用户执行写入操作，有有特殊权限。</p><p><strong>/usr：</strong>是一个层级结构目录，存放全局共享只读数据。</p><p>​     <strong><em>/usr/bin：</em></strong>普通用户命令。</p><p>​    <strong><em>/usr/sbin：</em></strong>管理员命令，并非系统必须，用于扩展系统功能的命令。</p><p>​     <strong><em>/usr/lib64：</em></strong>存放系统的扩展共享库文件。</p><p>​     <strong><em>/usr/include：</em></strong>存放c程序的头文件位置。</p><p>​    <strong><em>/usr/share：</em></strong>命令手册页和自带文档等架构特有的文件存放位置。</p><p>​     <strong><em>/usr/local：</em></strong>又一个层级目录，让系统管理员安装本地应用程序或者第三方的应用程序。</p><p>​     <strong><em>/usr/X11R6：</em></strong>存放X window的程序文件。</p><p>​     <strong><em>/usr/src：</em></strong>程序源码文件的存位置。</p><p><strong>/var：</strong>层级目录，存储常发生变化的数据的目录。</p><p>​     <strong><em>/var/cache：</em></strong>应用程序缓存数据。</p><p>​    <strong><em>/var/lib：</em></strong>应用程序的状态信息。</p><p>​    <strong><em>/var/local：</em></strong>为/usr/local提供经常变化的数据。</p><p>​    <strong><em>/var/lock：</em></strong>锁文件存放位置。</p><p>​    <strong><em>/var/log：</em></strong>应用程序的日志文件。</p><p>​    <strong><em>/var/opt：</em></strong>为/opt目录下应用程序提供变化的数据。</p><p>​    <strong><em>/var/run：</em></strong>为运行中的进程提供相关数据。</p><p>​    <strong><em>/var/spool：</em></strong>为应用程序提供的管道数据。</p><p>​    <strong><em>/var/tmp：</em></strong>系统重启后依然需要留存的数据。</p><p><strong>/proc：</strong>存放内核和进程的基于内存的虚拟文件系统。说白了，就是为内核和进程存储运行的相关数据，多为内核参数。例如：net.ipv4.ip_forward，虚拟化为net/ipv4/ip_forward，存储于/proc/sys/下，因此其完整路径为/proc/sys/net/ipv4/ip_foward</p><p><strong>/sys：</strong>挂载sysfs虚拟文件系统的挂载点，比proc更为理想的访问内核数据的途径，也是一个基于内存的虚拟文件系统。为管理LInux设备提供一种统一文件系统。在Linux内核2.6版本开始才出现此目录，以前并没有。</p><h2 id="Linux系统的文件类型："><a href="#Linux系统的文件类型：" class="headerlink" title="Linux系统的文件类型："></a>Linux系统的文件类型：</h2><ul><li><p>-：表示普通文件，在其他命令中用f表示普通文件</p></li><li><p>d：表示目录文件，完成路径映射，与windows功能不同。</p></li><li><p>b：表示块设备文件，完成块设备映射的文件，支持以block为单位随机访问设备</p></li><li><p>c：表示字符设备文件，完成字符设备映射的文件，支持以字符为单位线性访问设备</p><p>​    <strong><em>major number：</em></strong>主设备号，用于表示设备类型，进而确定要加载的驱动程序</p><p>​    <strong><em>minor number：</em></strong>次设备号，用于表示同一种类型设备下不同的设备，进而确定要驱动的嗯对象</p></li><li><p>l：表示符号链接文件，类似windows上快捷方式，也成为软链接文件。</p></li><li><p>p：表示管道文件</p></li><li><p>s：表示套接字文件，用于两个进程之间进行通信时套接的数据。</p></li></ul><h2 id="Linux系统重要的配置文件"><a href="#Linux系统重要的配置文件" class="headerlink" title="Linux系统重要的配置文件"></a>Linux系统重要的配置文件</h2><p><strong><em>/etc/sysconfig/network-scripts/ifcfg-eth  :</em></strong>  网卡配置文件</p><p><strong><em>/etc/resolv.conf :</em></strong> DNS配置文件</p><p><strong><em>/etc/hosts  :</em></strong> 主机名与IP的映射关系配置文件</p><p><strong><em>/etc/sysconfig/network  :</em></strong> 配置主机名的目录</p><p><strong><em>/etc/fstab :</em></strong> 实现开机要挂载的文件系统的一个文件</p><p><strong><em>/etc/rc.local :</em></strong> 实现开机启动的配置或软件</p><p><strong><em>/etc/inittab :</em></strong> 实现开机后系统运行的级别，加载相关的启动文件</p><p><strong><em>/etc/issue :</em></strong> 用户登录时的系统提示</p><p><strong><em>/etc/motd :</em></strong> 用户登录后的系统提示</p><p><strong><em>/etc/redhat-release：</em></strong>系统发行版本信息</p><p><strong><em>/usr/local :</em></strong> 通过源码编译的文件</p><p><strong><em>/var/log/message：</em></strong>系统日志文件</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Linux目录结构的特点&quot;&gt;&lt;a href=&quot;#Linux目录结构的特点&quot; class=&quot;headerlink&quot; title=&quot;Linux目录结构的特点&quot;&gt;&lt;/a&gt;Linux目录结构的特点&lt;/h2&gt;&lt;p&gt;Windows系统目录和磁盘是强对应的关系，联系很紧密，例如c盘下的目录和文件不可能和D盘的目录有关联或交集。而Linux系统目录与之不同，Linux系统的目录和磁盘等设备是不直接关联的，每个目录都可以关联（官称：挂载）在不同的设备（例如磁盘）上，例如：看似有包含关系的几个目录/、/etc、/boot、/var很可能是在不同的分区或磁盘上。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://kkutysllb.cn/categories/Linux/"/>
    
    
      <category term="基础概念" scheme="https://kkutysllb.cn/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>2019-03-18-Linux系统的内存管理</title>
    <link href="https://kkutysllb.cn/2019/04/15/2019-03-18-Linux%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://kkutysllb.cn/2019/04/15/2019-03-18-Linux系统的内存管理/</id>
    <published>2019-04-15T07:21:59.000Z</published>
    <updated>2019-04-15T17:44:54.253Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理中的基本概念"><a href="#内存管理中的基本概念" class="headerlink" title="内存管理中的基本概念"></a>内存管理中的基本概念</h2><p>内存管理一向是所有操作系统书籍不惜笔墨重点讨论的内容，无论市面上或是网上都充斥着大量涉及内存管理的教材和资料。因此，我们这里所要写的Linux内存管理采取避重就轻的策略，从理论层面就不去班门弄斧，贻笑大方了。</p><p>遵循“理论来源于实践”的“教条”，我们先不必一下子就钻入内核里去看系统内存到底是如何管理，那样往往会让你陷入似懂非懂的窘境（我当年就犯了这个错误！）。所以最好的方式是先从外部（用户编程范畴）来观察进程如何使用内存，等到大家对内存的使用有了较直观的认识后，再深入到内核中去学习内存如何被管理等理论知识。<a id="more"></a></p><hr><p>每个程序在操作系统中都对应一个进程（例如：QQ，微信等），所有进程都必须占用一定数量的内存，它或是用来存放从磁盘载入的程序代码，或是存放取自用户输入的数据等等。不过进程对这些内存的管理方式因内存用途不一而不尽相同，有些内存是事先静态分配和统一回收的，而有些却是按需要动态分配和回收的。</p><p>对任何一个普通进程来讲，它都会涉及到5种不同的数据段。稍有编程知识的朋友都能想到这几个数据段中包含有“程序代码段”、“程序数据段”、“程序堆栈段”等。不错，这几种数据段都在其中，但除了以上几种数据段之外，进程还另外包含两种数据段。下面我们来简单归纳一下进程对应的内存空间中所包含的5种不同的数据区。</p><p><strong>代码段：</strong>代码段是用来存放可执行文件的操作指令，也就是说它是可执行程序在内存中的镜像。代码段需要防止在运行时被非法修改，所以只准许读取操作，而不允许写入（修改）操作——它是不可写的。</p><p><strong>数据段：</strong>数据段用来存放可执行文件中已初始化全局变量，换句话说就是存放程序静态分配的变量和全局变量。</p><p><strong>BSS段：</strong>BSS段包含了程序中未初始化的全局变量，在内存中 bss段全部置零。</p><p><strong>堆（heap）：</strong>堆是用于存放进程运行中被动态分配的内存段，每一个程序当开始执行，就会在内存中划出一片空间作为程序运行时代码和数据存放地方。它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。</p><p><strong>栈：</strong>栈是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。</p><p>机器语言指令中出现的内存地址，都是逻辑地址，需要转换成线性地址，再经过MMU(CPU中的内存管理单元)转换成物理地址才能够被访问到。我们写个最简单的hello world程序，用gccs编译，再反编译后会看到以下指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov    0x8747ab0, %eax</span><br></pre></td></tr></table></figure><p>这里的内存地址0x8747ab0 就是一个逻辑地址，必须加上隐含的DS 数据段的基地址，才能构成线性地址。也就是说 0x8747ab0 是当前任务的DS数据段内的偏移量offset。</p><p>在x86保护模式下，段的信息（段基线性地址、长度、权限等）即<strong>段描述符</strong>占8个字节，段信息无法直接存放在段寄存器中（段寄存器只有2字节）。Intel的设计是段描述符集中存放在GDT或LDT中，而段寄存器存放的是段描述符在GDT或LDT内的索引值(index)。</p><h2 id="Linux系统逻辑地址-线性地址"><a href="#Linux系统逻辑地址-线性地址" class="headerlink" title="Linux系统逻辑地址=线性地址"></a>Linux系统逻辑地址=线性地址</h2><p>为什么这么说呢？因为Linux所有的段（用户代码段、用户数据段、内核代码段、内核数据段）的线性地址都是从 0x00000000 开始，长度4G，这样，线性地址=逻辑地址+ 0x00000000，也就是说逻辑地址等于线性地址了。</p><p>这种情况下Linux只用到了GDT，不论是用户任务还是内核任务，都没有用到LDT。GDT的第12和13项段描述符是 <strong>KERNEL_CS 和</strong>KERNEL_DS，第14和15项段描述符是 <strong>USER_CS 和</strong>USER_DS。内核任务使用<strong>KERNEL_CS 和</strong>KERNEL_DS，所有的用户任务共用<strong>USER_CS 和</strong>USER_DS，也就是说不需要给每个任务再单独分配段描述符。内核段描述符和用户段描述符虽然起始线性地址和长度都一样，但DPL(描述符特权级)是不一样的。<strong>KERNEL_CS 和</strong>KERNEL_DS 的DPL值为0（最高特权），<strong>USER_CS 和</strong>USER_DS的DPL值为3。</p><p>用gdb调试程序的时候，用info reg 显示当前寄存器的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cs             0x73     115</span><br><span class="line">ss             0x7b     123</span><br><span class="line">ds             0x7b     123</span><br><span class="line">es             0x7b     123</span><br></pre></td></tr></table></figure><p>可以看到ds值为0x7b, 转换成二进制为 00000000 01111011，TI字段值为0,表示使用GDT，GDT索引值为 01111，即十进制15，对应的就是GDT内的__USER_DATA 用户数据段描述符。</p><p>从上面可以看到，Linux在x86的分段机制上运行，却通过一个巧妙的方式绕开了分段。</p><p>Linux主要以分页的方式实现内存管理。如下图所示：</p><p><img src="https://i.loli.net/2019/04/15/5cb4323465760.jpg" alt></p><p>前面说了Linux中逻辑地址等于线性地址，那么线性地址怎么对应到物理地址呢？这个大家都知道，那就是通过分页机制，具体的说，就是通过页表查找来对应物理地址。</p><p>准确的说分页是CPU提供的一种机制，Linux只是根据这种机制的规则，利用它实现了内存管理。</p><p>在保护模式下，控制寄存器CR0的最高位PG位控制着分页管理机制是否生效，如果PG=1，分页机制生效，需通过页表查找才能把线性地址转换物理地址。如果PG=0，则分页机制无效，线性地址就直接做为物理地址。</p><p>分页的基本原理是把内存划分成大小固定的若干单元，每个单元称为一页（page），每页包含4k字节的地址空间（为简化分析，我们不考虑扩展分页的情况）。这样每一页的起始地址都是4k字节对齐的。为了能转换成物理地址，我们需要给CPU提供<strong>当前任务的</strong>线性地址转物理地址的查找表，即页表(page table)。注意，<strong>为了实现每个任务的平坦的虚拟内存，每个任务都有自己的页目录表和页表</strong>。</p><p>为了节约页表占用的内存空间，x86将线性地址通过页目录表和页表两级查找转换成物理地址。32位的线性地址被分成3个部分：<strong>最高10位 Directory 页目录表偏移量，中间10位 Table是页表偏移量，最低12位Offset是物理页内的字节偏移量。</strong></p><p>页目录表的大小为4k（刚好是一个页的大小），包含1024项，每个项4字节（32位），项目里存储的内容就是<strong>页表的物理地址</strong>。如果页目录表中的页表尚未分配，则物理地址填0。页表的大小也是4k，同样包含1024项，每个项4字节，内容为最终物理页的物理内存起始地址。</p><p><strong>每个活动的任务，必须要先分配给它一个页目录表，并把页目录表的物理地址存入cr3寄存器。页表可以提前分配好，也可以在用到的时候再分配</strong>。</p><p>还是以<strong>mov 0x8747ab0, %eax</strong>中的地址为例分析一下线性地址转物理地址的过程。</p><p>前面说到Linux中逻辑地址等于线性地址，那么我们要转换的线性地址就是 0x8747ab0。转换的过程是由CPU自动完成的，Linux所要做的就是准备好转换所需的页目录表和页表（假设已经准备好，给页目录表和页表分配物理内存的过程很复杂，这里不做展开讨论，喜欢内核优化的可自行研究）。</p><p>线性地址 0x8747ab0 转换成二进制后是 1000 0111 0100 0111 1010 1011 0000 0000，最高10位1000 0111 01的十进制是541，CPU查看页目录表第541项，里面存放的是页表的物理地址。线性地址中间10位00 0111 1010 的十进制是122，页表的第122项存储的是最终物理页的物理起始地址。物理页基地址加上线性地址中最低12位的偏移量，CPU就找到了线性地址最终对应的物理内存单元。</p><p>我们知道Linux中用户进程线性地址能寻址的范围是0 － 3G，那么是不是需要提前先把这3G虚拟内存的页表都建立好呢？一般情况下，32位机器的物理内存是小于3G的，加上同时有很多进程都在运行，根本无法给每个进程提前建立3G的线性地址页表。Linux利用CPU的一个缺页机制解决了这个问题。进程创建后我们可以给页目录表的表项值都填0，CPU在查找页表时，如果表项的内容为0,则会引发一个缺页异常，进程暂停执行，Linux内核这时候可以通过一系列复杂的算法给分配一个物理页，并把物理页的地址填入表项中，进程再恢复执行。当然进程在这个过程中是被蒙蔽的，它自己的感觉还是正常访问到了物理内存。</p><p><img src="https://i.loli.net/2019/04/15/5cb432bc7e467.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存管理中的基本概念&quot;&gt;&lt;a href=&quot;#内存管理中的基本概念&quot; class=&quot;headerlink&quot; title=&quot;内存管理中的基本概念&quot;&gt;&lt;/a&gt;内存管理中的基本概念&lt;/h2&gt;&lt;p&gt;内存管理一向是所有操作系统书籍不惜笔墨重点讨论的内容，无论市面上或是网上都充斥着大量涉及内存管理的教材和资料。因此，我们这里所要写的Linux内存管理采取避重就轻的策略，从理论层面就不去班门弄斧，贻笑大方了。&lt;/p&gt;
&lt;p&gt;遵循“理论来源于实践”的“教条”，我们先不必一下子就钻入内核里去看系统内存到底是如何管理，那样往往会让你陷入似懂非懂的窘境（我当年就犯了这个错误！）。所以最好的方式是先从外部（用户编程范畴）来观察进程如何使用内存，等到大家对内存的使用有了较直观的认识后，再深入到内核中去学习内存如何被管理等理论知识。
    
    </summary>
    
      <category term="Linux" scheme="https://kkutysllb.cn/categories/Linux/"/>
    
    
      <category term="基础概念" scheme="https://kkutysllb.cn/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>2019-03-02-Linux系统基础介绍</title>
    <link href="https://kkutysllb.cn/2019/04/15/2019-03-02-Linux%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/"/>
    <id>https://kkutysllb.cn/2019/04/15/2019-03-02-Linux系统基础介绍/</id>
    <published>2019-04-15T06:53:05.000Z</published>
    <updated>2019-04-15T17:25:17.844Z</updated>
    
    <content type="html"><![CDATA[<p>本文作为Linux操作系统开篇文章，主要介绍一些操作系统的基础概念和原理，然后简要介绍Linux的发展历史，以及市面上常见的Linux系统版本。<a id="more"></a></p><hr><h2 id="操作系统基本概念和原理"><a href="#操作系统基本概念和原理" class="headerlink" title="操作系统基本概念和原理"></a><strong>操作系统基本概念和原理</strong></h2><p>操作系统可以说是目前所有现代人都了解的一个名词，大家平时的日常工作和生活都离不开操作系统。目前，世界上主要流行的操作系统有三类：Linux、Windows和Mac OS。其中，后两个操作系统是大家熟悉的，大家的日常工作和生活大部分都会跟这两种操作系统打交道，对于Linux操作系统可能普通只是处在听说过的阶段，很少有人去详细了解和使用。</p><p>那么如果有人问你什么是操作系统？虽然大家平时都在用，但是估计很多人都会一脸懵逼。其实，操作系统就是处在计算机硬件和人之间的一个重要的中间部件，它存在意义有2个：一是通过在其上部署应用软件，满足人们操作计算机硬件的需求。二是将上层应用软件与底层硬件进行解耦，满足人们随时随地、随心所欲的操作计算机硬件的要求。</p><p>作系统的官方定义是：英文名Operating System，简称OS。是计算机系统中必不可少的基础系统软件，它是应用程序运行以及用户操作必备的基础环境支撑，是计算机系统的核心。**从官方定义不难看出，操作系统（后统称为OS）首先是一个软件，是一个支撑软件，支撑应用软件和人们的操作。所以，它是一种特殊软件，主要由内核+库两部分实现（如下图所示）。</p><p><img src="https://i.loli.net/2019/04/15/5cb42b8be3291.jpg" alt></p><p>内核存在的目的就是将底层的硬件进行软件化封装，方便上层调用来操作硬件。而库的作用就是将内核的软件封装再构造成一个个标准函数，供上层应用去调用从而避免应用直接操作内核的风险。其次，它还是计算机系统的核心。我们现在讲的计算机系统都是冯诺依曼架构（如下图所示），由控制器、运算器、存储设备和输入输出设备四部分构成，OS就是这些部件协调运作赖以支撑的基础，所以它也是计算机系统的核心。</p><p><img src="https://i.loli.net/2019/04/15/5cb42bc5252e1.jpg" alt></p><p>综上，用一句话概括操作系统的概念就是：<strong>操作系统就是位于用户与计算机系统硬件之间用于传递信息系统程序软件。</strong></p><h2 id="什么是Linux"><a href="#什么是Linux" class="headerlink" title="什么是Linux"></a><strong>什么是Linux</strong></h2><p><img src="https://i.loli.net/2019/04/15/5cb42c1824c56.jpg" alt></p><p><strong><em>Linux系统组成如上图</em></strong></p><ul><li><strong>内核：</strong>是系统的心脏，是运行程序和管理像磁盘和打印机等硬件设备的核心程序。</li><li><strong>Shell：</strong>是系统的用户界面，提供了用户和内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行，是一个命令解释器。但它不仅是命令解释器，而且还是高级编程语言，shell编程。</li><li><strong>文件系统</strong>：文件系统是文件存放在磁盘等存储设备上的组织方法，Linux支持多种文件系统，如ext3,ext2,NFS,SMB,iso9660等。</li><li><strong>应用程序：</strong>标准的Linux操作系统都会有一套应用程序例如X-Window,Open Office等。</li></ul><p>和windows一样，Linux也是一种操作系统。与windows的商业不同的是，Linux是一套完全开源的操作系统，其实现代码全部呈现给使用者。就像你亲自下厨做饭一样，所有的原材料和工序你都清楚，因此做出饭菜自然比外卖要安全可靠。所以，国内一些企业自研操作系统均是由Linux源码封装改造而来，其宣称”自主可控“，也无可厚非。</p><p>Linux在设计之初，是基于Intel x86 PC架构的，是一套多任务、多用户并支持多线程和多CPU的操作系统。其设计的本意就是打破商业软件版权的限制（因为当初unix系统被AT&amp;T回收版权，禁止向学生群体开放源码，从而引起版权纠纷），全世界都能使用的类unix系统兼容产品。从其1991年诞生到现在约30年的时间，Linux操作系统主要用于服务器领域、嵌入式开发，其在个人PC桌面领域应用较少，这也是其不被大众熟悉的原因。（目前，在个人PC桌面领域做的较好由国外的ubuntu、fedora，国内的深度deepin，中兴的新起点等操作系统）。其实，现在windows在个人桌面操作系统的优势除了软件生态以外，也不再剩下什么。如果Linux的软件生态得到广大发展，那么可以预期个人桌面系统将发生颠覆性的变化。这也是微软为什么在即将发布的windows 10的1903版本推出同时兼容读写Linux系统文件的原因，微软现在已经很着急啦：）。</p><p>全球超算99.9%都是使用Linux，全球和国内排名前1000的互联网公司90%的服务器也使用的是Linux，就是因为Linux系统优越性使其在服务器领域一举奠定了霸主地位，无论是windows还是mac os都无法与其竞争。Linux的优越性主要都继承自unix系统，主要由以下几点：</p><ul><li><p>具备开放源代码的程序软件，可自由修改。</p></li><li><p>Unix系统兼容，具备几乎所有Unix系统的优点。</p></li><li>可自由传播，无任何商业化版权制约。</li><li>适合Intel x86CPU系列架构的计算机。</li></ul><p>严格来说，Linux这个词本身只表示Linux内核，但是人们已经习惯用Linux来形容整个基于Linux内核的操作系统，并且是一种使用GNU通用公共许可证（GUN general public，GPL）工程的，包括各种工具和数据库的操作系统。</p><p>Linux内核除系统调用外，由五个主要的子系统组成：进程调度、内存管理、虚拟文件系统、网络和进程间通信(IPC)。</p><p>各个子系统的主要功能为： </p><p><strong>1、进程调度：</strong>它控制着进程对CPU的访问，当需要选择一个进程开始运行时，由调度程序选择最应该运行的进程；</p><p><strong>2、内存管理：</strong>它允许多个进程安全地共享主内存区域，支持虚拟内存；从逻辑上可以分为硬件无关的部分和硬件相关的部分；</p><p><strong>3、虚拟文件系统(VFS)：</strong>它隐藏了各种不同硬件的具体细节，为所有设备提供统一的接口，支持多达数十种不同的文件系统，分为逻辑文件系统和设备驱动程序；</p><p><strong>4、网络：</strong>它提供了对各种网络标准协议的存取和各种网络硬件的支持，分为网络协议和网络驱动程序两部分；</p><p><strong>5、进程间通信：</strong>支持进程间各种通信机制，包括共享内存、消息队列和管道等。</p><p>GNU的全称为GNU’s not Unix，意思是“GNU不是Unix”，GNU计划，又称革奴计划，是由Richard Stallman在1984年公开发起的，是FSF（自由软件基金会）的主要项目，这个项目成立的本意就是建立一套完全自由的可移植的类unix操作系统。在Linux内核发布的时候，GUN项目已经完成了除系统内核之外的各种必备软件的开发。在Linus Torvalds和其他开发人员的努力下，GNU项目的部分组件又运行到了Linux内核之上，例如：GNU项目里的Emacs、gcc、bash、gawk等，至今都是Linux系统中很重要的基础软件。因此，如今我们说的Linux操作系统实际上是GNU/Linux操作系统。</p><p>而GPL是一个最著名的开源许可协议，其核心是<strong>保证任何人有共享和修改自由软件的自由，任何人有权取得、修改和重新发布自由软件的源代码权利，但都必须同时给出具体更改的源代码。</strong>正是因为该协议的存在，才使得开源软件有如今如火如荼的发展局面。</p><h2 id="Linux系统启动顺序和基本概念"><a href="#Linux系统启动顺序和基本概念" class="headerlink" title="Linux系统启动顺序和基本概念"></a><strong>Linux系统启动顺序和基本概念</strong></h2><p>开机自检（BIOS)—&gt;MBR引导（512字节，其中前446字节是Grub菜单，后64字节是分区表）—&gt;GRUB菜单（选择启动系统）—-&gt;加载内核Kernel—&gt;运行INIT进程。其中，INIT进程在Linux系统的用PID编号为1来表示，意思为所有进程的“大佬”。</p><p><strong>BIOS：</strong>基本输入输出系统（basic input output system，BIOS），是一组固话到计算机主板ROM上的程序，保存着计算计算最重要的基本输入输出程序、系统设置信息、开机自检程序和系统自启动程序，为计算机提供最底层的、最直接的硬件设置和控制。</p><p><strong>MBR：</strong>一种硬盘分区格式。目前，硬盘分区格式主要有两种，分别是MBR和GTP。MBR，即主引导记录扇区（master boot record），位于整块硬盘的0磁道0煮面1扇区，用于操作系统对硬盘读写时，判断分区的合法性以及分区引导信息的定位。总共512字节，前446字节用于主引导记录，后64字节用于存储硬盘分区表（DPT），每个分区表大小16字节，共4个分区表，所以采用MBR分区格式的硬盘最多只能分出4个分区（主分区+扩展分区），最后两个字节”55，AA“是分区的结束标志。MBR分区表的格式如下：</p><p><img src="https://i.loli.net/2019/04/15/5cb42d40966b7.jpg" alt></p><p><strong>GPT：</strong>全局唯一分区格式，正在逐渐取代MBR成为新标准。它和统一的可扩展固件接口（unified extensible firnware interface，UEFI）相辅相成。UEFI用于取代BIOS，而GPT用于取代MBR。在GPT硬盘中，分区表中的位置信息存储在GPT头中，第一个扇区同样有一个与MBR类似的标记，叫做受保护的主引导记录（protected main boot record，PMBR）。其作用是当使用不支持GPT的分区工具时，整个硬盘将显示为一个受保护的分区，防止数据被破坏，其中存储的内容与MBR一样，之后才是GPT头部信息。与MBR相比，支持2TB以上的磁盘，如果使用fdisk分区，最大只能建立2TB大小的分区，创建大于2TB的分区时，需使用parted工具，同时必须使用64位操作系统。以下是GPT分区表的数据格式：</p><p><img src="https://i.loli.net/2019/04/15/5cb42d6337913.jpg" alt></p><p><strong>GRUB：</strong>多操作系统启动程序（GRand unified bootloader）。支持多操作系统引导，当系统中装载多操作系统时，在系统启动时便于用户选择。GRUB还可用于选择操作系统分区上的不同内核，也可用于向这些内核传递启动参数。Linux常见的引导程序包括：LILO、GRUB、GRUB2。CentOS 6.x系统和Ubuntu系统默认采用GRUB引导程序，所以当我们有需要编译GRUB菜单时，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><p>CentOS 7.x系统默认采用GRUB2引导程序，所以当我们有需要编译GRUB菜单时，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub2-mkconfig -o /boot/grub2/grub.cfg</span><br></pre></td></tr></table></figure><p>GRUB加载引导程序的流程如下：</p><p><img src="https://i.loli.net/2019/04/15/5cb42e226d582.jpg" alt></p><p>GRUB2是基于GRUB开发的更加安全强大的多系统引导程序，同时采用模块化设计，使得GRUB2核心更加尽量，使用更加灵活，也不需要像GRUB那样分为stage1、stage1.5和stage2三个阶段。</p><p><strong>init：</strong>就是系统的不同运行级别对应加载的启动文件。在Linux跟目录下的/etc/目录下，有与系统运行级别对应的rc开头的目录，里面存在对应系统运行级别的脚本文件。Linux内核加载完成后，通过加载这些启动文件完成系统的初始化。</p><p><img src="https://i.loli.net/2019/04/15/5cb42e68b6ed6.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文作为Linux操作系统开篇文章，主要介绍一些操作系统的基础概念和原理，然后简要介绍Linux的发展历史，以及市面上常见的Linux系统版本。
    
    </summary>
    
      <category term="Linux" scheme="https://kkutysllb.cn/categories/Linux/"/>
    
    
      <category term="基础概念" scheme="https://kkutysllb.cn/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>2018-10-10-云计算的技术架构</title>
    <link href="https://kkutysllb.cn/2018/10/10/2018-10-10-%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9A%84%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"/>
    <id>https://kkutysllb.cn/2018/10/10/2018-10-10-云计算的技术架构/</id>
    <published>2018-10-09T16:09:45.000Z</published>
    <updated>2019-02-18T00:49:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="云计算总体技术架构"><a href="#云计算总体技术架构" class="headerlink" title="云计算总体技术架构"></a>云计算总体技术架构</h2><p>下图是一张从云计算上下文参考架构引申出的云计算总体技术架构图。其实，当我们面临一个复杂系统的认知学习，首先需要从全局对其做鸟瞰式概览，将其关键部分抽象为几个关键模块。然后，分析每个关键模块之间的关联，也就是上下文对接关系。最后，再由上下文参考架构拓展出具体关键流程和服务模块。做到上述“收放自如”，才算真正入门，才具备继续深钻的基础条件。：）<a id="more"></a></p><p><img src="https://i.loli.net/2019/02/19/5c6ad92c230a4.jpg" alt></p><p>上图左边是云计算的参考架构，主要由4个关键子模块和1个关键服务组成。4个关键子模块包括：CloudDevice（云设备）、User（用户&amp;开发者）、ServiceCenter（运营服务中心）和OperatorCenter（运维中心）。而将4个关键子模块进行衔接的关键服务就是我们常说的IaaS、PaaS和SaaS三层平台的逻辑抽象，由IaaS层的CloudOS统一完成纳管和呈现。</p><p>对上下文架构参考图进一步拓展，就是右边的云计算解决方案的整体技术架构图。这张整体技术架构图向上可以支撑公有云、私有云、电信云和混合云的各种方案部署。虽然，其涉及的技术方案很多，但其本质上还是底层四个关键技术领域。即，计算、网络、存储和安全。说白了，云计算要想彻底精通，必须同时精通<strong>计算、网络、存储和安全</strong>四个领域。</p><h2 id="云计算的核心技术识别"><a href="#云计算的核心技术识别" class="headerlink" title="云计算的核心技术识别"></a>云计算的核心技术识别</h2><p><img src="https://i.loli.net/2019/02/19/5c6ad96529c75.jpg" alt></p><p><strong>虚拟化及资源调度平台</strong></p><ul><li><p>虚拟化软件：高性能、高可靠性、智能调度算法</p></li><li><p>数据中心的一体化自动管控</p></li><li><p>分布式计算/存储框架</p></li><li><p>虚拟化的硬件加速</p></li></ul><p><strong>计算与存储平台</strong></p><ul><li><p>定制化的服务器与存储：讲话涉及大内存，高网络/存储IOPS</p></li><li><p>数据中心安全性：可信赖、完整性、可用性</p></li></ul><p><strong>网络平台</strong></p><ul><li><p>高密度、低成本的10GE互联</p></li><li><p>网络的集群与虚拟化</p></li></ul><p><strong>基础设施平台</strong></p><ul><li><p>E2E的集成交付能力</p></li><li><p>绿色节能的工程设计</p></li></ul><p><strong>从物理设备（服务器、存储和网络设备）、虚拟化软件平台、分布式计算和存储资源调度、一体化自动化管控软件、虚拟化数据中心的安全和E2E的集成交付能力，都是构建高效绿色云数据中心的关键技术。</strong></p><ul><li><p>简化设计的大内存、高网络和存储IOPS的服务器，可以为云数据中心提供强大的计算能力。</p></li><li><p>高IOPS，支持链接克隆、精简置备、快照等功能的存储设备，可以为数据中心提供强大的存储能力。</p></li><li><p>高密度、低成本，支持大二层网络技术的交换设备为数据在二层网络流动提供交换能力。</p></li><li><p>虚拟化软件平台，可以抽象物理资源为资源池，给云用户配置不同规格虚拟机提供底层支撑。</p></li><li><p>灵活、高效的分布式计算或存储框架，为云计算的资源调度和调整提供支撑。</p></li><li><p>从门禁监控、网络接入、虚拟化平台软件安全、经过安全加固的OS和DB到用户的分权分域管理，保证数据中心的放心使用。</p></li><li><p>一体化自动化的管控软件，提升维护人员的效率，降低企业成本。</p></li></ul><h2 id="云计算的关键技术"><a href="#云计算的关键技术" class="headerlink" title="云计算的关键技术"></a>云计算的关键技术</h2><p>云计算的单点技术都是“老”技术，组合起来却有无与伦比的的价值。马云有句话说的好，从技术层面来讲，云计算的就是新瓶装旧酒。</p><p><img src="https://i.loli.net/2019/02/19/5c6ada3096095.jpg" alt></p><p><strong>计算架构：</strong>支持scale out模式，整体性能最优，基于软件可靠性和可扩展性。</p><p><strong>云计算硬件</strong></p><ul><li><p>服务器：高可靠性、高性能</p></li><li><p>网络：高密度以太网交换机</p></li><li><p>存储：低成本、多备份</p></li></ul><p><strong>云计算软件</strong></p><ul><li><p>并行计算技术</p></li><li><p>分布式存储</p></li><li><p>分布式文件管理</p></li><li><p>虚拟化技术</p></li><li><p>智能化云计算系统管理技术</p></li></ul><p>通过对多项核心技术进行归类汇总，可归结为三个方面：<strong>整体的计算架构、承载的硬件设备和软件系统。</strong></p><ul><li><p>整体的计算架构：需要涵盖高性能、高可靠和可扩展。</p></li><li><p>云计算硬件包括：高可靠和高性能的计算服务器提供计算资源；低成本、数据安全的存储设备提供数据存储空间；支持大二层网络的高密度交换机进行数据的通信和交流。</p></li><li><p>云计算软件包括：用于大数据的并行分析计算技术；整合存储资源提供动态可伸缩资源池的分布式存储技术；用于数据管理的分布式文件管理；计算、存储等资源池化的虚拟化技术；简化运维人员工作，方便高效智能运维的系统管理技术。</p></li></ul><h2 id="云计算的硬件技术：计算架构"><a href="#云计算的硬件技术：计算架构" class="headerlink" title="云计算的硬件技术：计算架构"></a>云计算的硬件技术：计算架构</h2><p><img src="https://i.loli.net/2019/02/19/5c6adab8e0aba.jpg" alt></p><p>早起许多IT系统开始很简单，但当需要进行系统扩展时就会变得复杂。升级系统最常见的原因是需要更多的容量，以支持更多的用户、文件、应用程序或连接的服务器。常见的系统扩展方式有Scale up和Scale out两种。</p><ul><li><p>Scale up 纵向扩展架构主要是利用现有的系统，通过不断增加存储容量来满足数据增长的需求。但是这种方式只增加了容量，而带宽和计算能力并没有相应的增加。所以，整个系统很快就会达到性能瓶颈，需要继续扩展。</p></li><li><p>Scale out 横向扩展架构的升级通常是以节点为单位，每个节点往往将包含容量、处理能力和I/O带宽。一个节点被添加到系统，系统中的三种资源将同时升级。而且，Scale out架构的系统在扩展之后，从用户的视角看起来仍然是一个单一的系统。所以Scale out方式使得系统升级工作大大简化，用户能够真正实现按需购买，降低TCO。</p></li></ul><p><strong>云计算的设计思想是以最低成本构建出整体的性能最优，与传统电信设备和IT设备（服务器、大型机、企业存储等）追求设备可靠性和性能的思路完全不同。</strong></p><h2 id="云计算的硬件技术：存储系统"><a href="#云计算的硬件技术：存储系统" class="headerlink" title="云计算的硬件技术：存储系统"></a>云计算的硬件技术：存储系统</h2><p><img src="https://i.loli.net/2019/02/19/5c6adb2242e07.jpg" alt></p><p>企业存储一般采用专用的存储设备，成本高。</p><p>分布式存储系统把使用便宜IDE/SATA硬盘的服务器本地存储构建存储资源池，既降低了服务器的成本，也降低了存储成本，构建最低成本的计算和存储。</p><p>通过“分布式存储和多副本备份”来解决海量信息的存储和系统可靠性，数据存储可以配置多份副本，保证数据的安全性。</p><h2 id="云计算的硬件技术：数据中心的联网"><a href="#云计算的硬件技术：数据中心的联网" class="headerlink" title="云计算的硬件技术：数据中心的联网"></a>云计算的硬件技术：数据中心的联网</h2><p><img src="https://i.loli.net/2019/02/19/5c6adb4da82c4.jpg" alt></p><p><strong>东西向流量增长</strong></p><ul><li><p>并行计算业务(如：搜索)需要服务器集群协同运算，产生大量横向交互流量</p></li><li><p>虚拟机的自由部署和动态迁移，虚机间需要实时同步大量的数据</p></li></ul><p>随着云计算的发展，越来越多业务承载在数据中心的虚拟机上，业务数据的流动从南北向转变为东西向，对数据中心网络的需求和冲击提出了很大挑战。</p><p>数据中心内部虚拟机的迁移促进了大二层网络虚拟交换技术的发展，支持大容量数据的通信和超高的端口密度，可以连接更多的服务器提升数据中心的处理能力。</p><h2 id="云计算的软件技术：集群管理"><a href="#云计算的软件技术：集群管理" class="headerlink" title="云计算的软件技术：集群管理"></a>云计算的软件技术：集群管理</h2><p><img src="https://i.loli.net/2019/02/19/5c6adb8e7b9d7.jpg" alt></p><p>云计算虚拟化平台软件，支持分布式的集群管理。可以针对业务模型，对物理服务器创建不同的业务集群，并在集群内实现资源调度和负载均衡，在业务负载均衡的基础上实现资源的动态调度，弹性调整。</p><p>云计算虚拟化平台需要支持各种不同的存储设备，包括本地存储、SAN存储、NAS存储和分布式本地存储，保证业务的广适配性。</p><p>同时，提供链接克隆、资源复用、精简置备和快照功能，降低企业成本并提供高效率、高可靠性的资源池。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>截止目前，云计算基础入门部分已更新完毕，此部分主要是针对打算入坑的新人，给其一个总体上概括认知。后续本打算重写虚拟化技术。但是，考虑到OpenStack以及Docker容器涉及很多Linux基础知识，故临时调整更新内容为重写Linux部分。主要涉及：Linux系统组成、常用命令总结（这部分是我自己总结，大家可下载留存参考）、三剑客基本使用教程和shell编程基础。</p><p>完成Linux部分更新后，再继续重写虚拟化技术入门，涉及计算、存储和网络虚拟化三部分。以上与目前更新云计算基础统一构成基础概念部分。所谓“基础不牢，地动山摇”，因此这部分虽然是入门，其实还是很重要的部分。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;云计算总体技术架构&quot;&gt;&lt;a href=&quot;#云计算总体技术架构&quot; class=&quot;headerlink&quot; title=&quot;云计算总体技术架构&quot;&gt;&lt;/a&gt;云计算总体技术架构&lt;/h2&gt;&lt;p&gt;下图是一张从云计算上下文参考架构引申出的云计算总体技术架构图。其实，当我们面临一个复杂系统的认知学习，首先需要从全局对其做鸟瞰式概览，将其关键部分抽象为几个关键模块。然后，分析每个关键模块之间的关联，也就是上下文对接关系。最后，再由上下文参考架构拓展出具体关键流程和服务模块。做到上述“收放自如”，才算真正入门，才具备继续深钻的基础条件。：）
    
    </summary>
    
      <category term="云计算" scheme="https://kkutysllb.cn/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
      <category term="基础概念" scheme="https://kkutysllb.cn/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>2018-09-25-云计算带来哪些变化</title>
    <link href="https://kkutysllb.cn/2018/09/25/2018-09-25-%E4%BA%91%E8%AE%A1%E7%AE%97%E5%B8%A6%E6%9D%A5%E5%93%AA%E4%BA%9B%E5%8F%98%E5%8C%96%EF%BC%9F/"/>
    <id>https://kkutysllb.cn/2018/09/25/2018-09-25-云计算带来哪些变化？/</id>
    <published>2018-09-25T01:00:00.000Z</published>
    <updated>2019-02-18T00:49:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="传统的IT架构与云计算架构投资决策的差异"><a href="#传统的IT架构与云计算架构投资决策的差异" class="headerlink" title="传统的IT架构与云计算架构投资决策的差异"></a>传统的IT架构与云计算架构投资决策的差异</h2><blockquote><p>传统的IT架构俗称三层架构，即，表示层、业务逻辑层和数据访问层。虽然三层架构将系统在逻辑上分层了三层，但它并不是物理意义上的分层。也就是说对于不同层的代码而言，经历编译、打包、部署之后，所有的代码最终还是运行在同一个进程之中。<a id="more"></a></p></blockquote><p><img src="https://i.loli.net/2019/02/18/5c6a7e5c1f294.jpg" alt></p><p>对于这种功能集中、代码中心化、一个发布包、部署后运行在同一个进程中应用程序，我们称之为单块架构应用。企业采用这种架构开发某个业务时，对计算、网络、存储、服务器资源的需求都是独占的，不同业务之间是一种烟囱式的条块化分割。随着业务的增加，需求功能的迭代，单块架构只能通过增加自己独占资源组内的资源来实现，即使其他应用资源占用很低，也无法共享其它应用的空闲资源。因此，这种架构模式已经很难满足业务快速变化的需要。</p><blockquote><p>一方面，代码的可维护、扩展性、灵活性在降低；</p><p>另一方面，系统的修改成本、构建以及维护成本在增加，因此单块架构的改造与重构势在必行。</p></blockquote><p>随着云计算的出现，在技术上面其实有四点最关键的技术：</p><p>第一个技术就是<strong>服务器虚拟化</strong>，前面讲到了，就是把一台物理的服务器，当成很多逻辑的服务器来用，这种分割的目的就是那提升资源共享利用率，达到业务可以快速的部署，代码重构维护简单的目的。</p><p>第二个技术就是<strong>分布式的存储</strong>，就是把一些原来的专用大存储服务器，比如存储9000那种大的设备大的柜子。把它里面设计成一台一台小的服务器，通过软件方式融合在一起进行管理，当成是一个“存储池”来管理这个资源，这种就是分布式的存储。分布式的存储的好处是可以提高存储的速度，同时以按照客户的需要去扩容。比如：可以像虚拟CPU和虚拟内存那样，实现存储资源的弹性部署。同时，随着Server SAN概念的提出，分布式存储的硬件基于x86通用服务器，远比专用存储服务器的硬件成本低。</p><p>第三个技术就是<strong>软件定义的网络</strong>，也就是现在炒的火热的SDN。我们都知道网络这一块管理起来很复杂，需要提前做好规划，提前分配IP地址。那么，如何通过软件来实现呢？就是通过云计算实现的云资源池，利用里面基础虚拟网络资源，分析这类资源的随时变化，通过编程的方式将这种变化通过协议流去控制实现，通过软件去管理，自动化完成。这就是软件定义网络概念的本质。</p><p>第四个技术就是<strong>REST</strong>，它本质上是一个协议，一种资源状态转移协议。前面说过传统IT的三层架构，主要分为表示层、业务逻辑层和数据访问层。由于在云计算架构里，它的资源是池化的，资源之间是共享的（隔离的本质其实是最大的共享！详见后面OpenStack Neutron部分论述），交互很快，用传统的三层架构软件去实现这种调度根本不现实。因此，就出现了REST协议，它其实是将传统三层架构的功能做了整合，通过它应用可以直面底下的虚拟资源池。这相当于是一个资源调度程序，由应用程序调用，直接去使用这种云的资源。当这种弹性的资源调度模式与上层应用关联起来之后，应用不够或者坏掉了，都没关系，直接再起一个新应用，让应用扩展起来，底层的虚拟机资源也随之增加。这里面有几个特点，第一个就是这种协议是一种API接口协议，所有做开发的人都必须遵循的一种接口协议，为分布式开发和CI/CD(持续集成，持续交付）创造了条件。第二个是云计算采用轻量级的云OS，其主要职责是纳管，并不是具体实现。其上应用恢复与扩展的速度比传统的三层架构更快，为敏捷开发创造了条件。但是，它唯一的遗憾还是未能有一个组织出来进行标准化定义，因此兼容性方面还有缺陷。直到现在容器技术的兴起，才使上述两个场景（CI/CD和敏捷开发）真正落地。</p><h2 id="云时代商业模式的变化：从自建变为租用"><a href="#云时代商业模式的变化：从自建变为租用" class="headerlink" title="云时代商业模式的变化：从自建变为租用"></a>云时代商业模式的变化：从自建变为租用</h2><blockquote><p>企业由纯粹的自建IT系统逐步转向混合云的模式。</p></blockquote><blockquote><p>部分核心应用私有云，一般应用租用公有云服务。</p></blockquote><blockquote><p>云服务又分为：IaaS、PaaS、SaaS三种方式。</p></blockquote><p><img src="https://i.loli.net/2019/02/18/5c6aa4d732ab6.jpg" alt></p><p>以前，IT企业提供业务需要自己建设机房，买了一堆服务器、交换机部署一个数据中心，然后在上面再部署自己的软件来提供服务。往往这都是一笔不小的花费，从而导致好多创业公司的启动经费过高。</p><p>随着IDC机房的出现，云计算技术的普及，这种模式发生了变换。好多公司完全可以通过租借云DC的方式来部署自己的业务软件。所谓的云DC，其实就是通过云计算技术将IDC机房中基础设施通过虚拟化资源的方式来统一提供，租用的费用远远比自建少得多，同时可以节省一笔维护开销，从而导致创业的门槛大大降低。</p><p>往往这些企业只需要购买很少一部分服务器和交换机来部署自己的核心业务，存储自己的核心数据，同样也使用云计算来提高资源利用率，降低成本，这部分往往我们称为企业私有云。非核心的企业业务软件和数据，往往通过公有云提供商提供云DC/云主机部署，这部分往往我们称为公有云。两者的结合，就诞生了混合云的概念。因此，混合云是从企业业务的全局部署角度提出的，并不是云计算的新技术分支，现在IT企业提供业务大部分都是通过混合云的方式提供。与混合云类似的还有行业云，两者之间的区别非常小，可以合并为一种。</p><p>那么租用云DC到底租用的是什么？这个从需求者不同需求角度来说，分为IaaS（基础设施即服务），PaaS（平台即服务），SaaS（软件即服务）。有些企业，软件开发能力很强，具备平台级的开发能力，但是缺少运行软件平台的服务器、存储和交换机。为了节省成本，他们往往都是向云服务提供租用云主机，将自己的软件部署在云主机上，这种租用的就是IaaS。另一些企业，具备应用层软件的开发能力，但不具备数据之间逻辑处理的能力（即，算法），同时为了节省成本，他们往往都是云服务提供上租用开发平台（如大数据处理），也连带底层基础设施（云主机）一起租用，这种租用的就是IaaS+PaaS。目前还没有哪家企业只租用PaaS，自建IaaS的方式来部署自己的业务。至于SaaS的租用，目前只涉及个人办公（如web版office）或开发领域（如Mob等应用），很少有面向企业的服务应用。</p><h2 id="云时代建设模式的变化：从烟囱变为水平"><a href="#云时代建设模式的变化：从烟囱变为水平" class="headerlink" title="云时代建设模式的变化：从烟囱变为水平"></a>云时代建设模式的变化：从烟囱变为水平</h2><blockquote><p>芯片、新介质取得突破，以及CPU、硬盘、网络性能大幅提升为IT架构的水平化演进提供了技术支撑。云计算经历了从虚拟化—云资源池—平台&amp;应用的逐步发展阶段。</p></blockquote><p><img src="https://i.loli.net/2019/02/18/5c6aceca9b79b.jpg" alt></p><p>云服务提供商为了提供各种云服务，必然要建设相应的数据中心，这种建设是去IOE化的。去IOE化的概念，最早是阿里巴巴提出的，其本意是，在阿里巴巴的IT架构中，去掉IBM的小型机、Oracle数据库、EMC存储设备，代之以自己在开源软件基础上开发的系统。说白了就是结合开源软件技术，将IOE的各层级功能通过通用硬件平台，分布式架构，软硬件解耦和软件定义存储的方式实现，通过Cloud OS进行纳管，并统一对外提供服务。</p><p><img src="https://i.loli.net/2019/02/18/5c6ad1d8b4db7.jpg" alt></p><p>前面也提到了，云计算的出现不是突然出现的，详见博文 <a href="https://kkutysllb.cn/2018/09/12/2018-09-12-%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/#more">云计算的前世今生</a>。随着软硬件技术的发展，他主要经历了三个发展阶段。第一个阶段就是虚拟化阶段，代表技术就是VMware和Xen，主要通过虚拟化技术来提升企业资源利用率，从而降低成本。第二个阶段是云DC阶段，代表技术就是OpenStack，但是OpenStack最成熟的部分还是其IaaS服务提供，这个阶段主要通过提供云主机和云DC来降低企业运营成本。第三个阶段就是现在火热的容器化应用阶段，其实容器也是一种虚拟化技术，属于轻量级操作系统级别的虚拟化。它是以软件进程的方式来封装各个应用模块，通过共享底层操作系统内核，来提供各种平台服务和应用服务（PaaS+SaaS）。通过这种技术，使得前几年DevOps概念完美落地并真正意义上实现敏捷开发，这是一种企业应用现有管理模式的变革。</p><h2 id="云计算给企业带来哪些变化"><a href="#云计算给企业带来哪些变化" class="headerlink" title="云计算给企业带来哪些变化"></a>云计算给企业带来哪些变化</h2><blockquote><p>要说云计算技术给企业带来了哪些变化，最明显的还要数银行。</p></blockquote><p><img src="https://i.loli.net/2019/02/18/5c6ad4f68aa43.jpg" alt></p><p>银行采用基于云计算的新架构以后，它的第一个变换就是IT资源池化了，即使有一些资源损坏了，它还可以继续工作，并不影响它的业务。所以这样提高了就是业务的质量，减少了业务中断，保证这个业务的连续性，全年的业务停机时间就大大减少。</p><p>第二个变化就是业务提供的速度，当业务需要很多IT资源时，可以通过资源弹性扩缩容的方式，来满足业务需求。不像以前，一个业务办理的好慢好烦，甚至死机，影响客户的体验，客户就可能去选择其他家更快业务。所以通过把资源管理好，也让IT人员有更多的创新机会，可以开发包括手机端的应用，让更多的人通过手机随时随地去办理业务。不知你注意到没有，国内这么多银行，招商银行在这方面一直走在其他银行前面。</p><p>还有更重要的一点对于企业来说，它的业务成本的降低。银行对散户，对个人的业务，实际上都是亏钱的，个人取钱的交易或者是存钱的交易，银行都要投入人力和场地等费用，而现今，通过手机银行和互联网银行，可以把这个散户交易成本降下来，通过云计算等互联网技术，免除了场地网点的费用而且业务处理速度非常的快，用户体验也提升了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;传统的IT架构与云计算架构投资决策的差异&quot;&gt;&lt;a href=&quot;#传统的IT架构与云计算架构投资决策的差异&quot; class=&quot;headerlink&quot; title=&quot;传统的IT架构与云计算架构投资决策的差异&quot;&gt;&lt;/a&gt;传统的IT架构与云计算架构投资决策的差异&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;传统的IT架构俗称三层架构，即，表示层、业务逻辑层和数据访问层。虽然三层架构将系统在逻辑上分层了三层，但它并不是物理意义上的分层。也就是说对于不同层的代码而言，经历编译、打包、部署之后，所有的代码最终还是运行在同一个进程之中。
    
    </summary>
    
      <category term="云计算" scheme="https://kkutysllb.cn/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
      <category term="基础概念" scheme="https://kkutysllb.cn/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>2018-09-12-云计算的前世今生</title>
    <link href="https://kkutysllb.cn/2018/09/12/2018-09-12-%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
    <id>https://kkutysllb.cn/2018/09/12/2018-09-12-云计算的前世今生/</id>
    <published>2018-09-12T00:00:00.000Z</published>
    <updated>2019-02-18T00:49:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="云计算的发展历程"><a href="#云计算的发展历程" class="headerlink" title="云计算的发展历程"></a>云计算的发展历程</h2><blockquote><p>云计算的历史也是蛮好玩的…</p></blockquote><p>一开始就是在2003年之前，大家都在在提升CPU的计算能力，提升存储的空间，使得CPU性能越来越高、存储变得更大。<a id="more"></a><br><img src="https://i.loli.net/2019/02/18/5c6a5fd1765ca.jpg" alt></p><p>到了2003年以后呢，企业的数据中心里面发现资源已经很空闲，因为架构设计的原因，让这些服务器很多时间都处在平均不到5%的使用率，大部分99%都是空闲的。相当云投资一千块，其实只用了五块钱，实际上产生了很大的浪费。同时，机房空间、动力等基础设施资源被占用过多，导致数据中心内部无法放置更多机柜、机架和服务器，需要买地建设新的机房（按照国内的地价/房价，这基本是不可能的）。因此，在2003年VMware这个厂商提供了服务器虚拟化的技术，就是把一台服务器一台设备，切成很多虚拟的小块服务器，也就是俗称的“虚拟机”。而让业务应用在虚拟机上面去工作，这就叫服务器虚拟化。</p><p>这个技术解决了数据中心里面机房空间和动力资源不够的问题，原来需要十台服务器的，现在在一台高级的服务器里面切了十份，分别给10个业务应用使用，即使这样也就才用了40%的CPU，电力节省了接近9/10，而且一个机房里面容量就可以做二十倍数的的提升。原来部署一百台物理的服务器，现在可以部署两千台虚拟服务器，大大的提升了资源的利用率。而虚拟化的另一个好处就是还大幅提升了客户业务的创新的积极性，因为以前他们服务器都摆不下，好多东西不能做，现在摆下了，所以他要做什么东西都可以试试。但是这个虚拟化技术只解决了资源的共享问题，还没解决运营效率问题。</p><p>到了2006年的时候，亚马逊提出了公有云的服务，那时还不叫云计算，叫Amazon Web Service, 简称AWS（现在亚马逊的云计算项目还是沿用这个叫法）。亚马逊大家都知道，它原本是一个做超市的，超市的概念就是你需要你去拿，拿了就到门口结帐，结帐你就拿走。然后亚马逊它把这个计算资源也当成一种，把服务器也当成资源去卖，但是它卖的不是物理的，不是让你搬一台服务器走。而是建好一个数据中心，当你用的时候，你要多少台我们就给你多少台，你只要刷信用卡在网上做支付，你就可以使用这些逻辑上提供给你的资源，这也是虚拟化资源第一次被当成商品出售的案例。随后，Amazon在此基础上提出了云计算的概念，并开发出了公有云业务。亚马逊的这种公有云的这种服务对企业而言，想做的时候，只要付钱就可以做了。而且一般企业业务部门都很有钱，所以业务部门的愿意投钱去做这个事情。</p><p>到了2010年的时候，出现了另外一种云计算架构，叫OpenStack。它是NASA就是美国太空总署那个NASA和RackSpace联合做的。RackSpace也是做公有云服务的运营商，就像我们的阿里云一样，它也是想学习亚马逊。但是它的人没有亚马逊的团队这么大，所以它把这个架构给开源出来，形成一个OpenStack开源社区，大家都在OpenStack上面去开发完善，然后让这个框架变得更好，目前OpenStack会聚了全球的研发力量，并吸引了几乎全球所有主流IT厂商的支持，帮它完善这个架构，形成了云计算领域一个全新的强大生态系统。OpenStack社区把这个架构公开出来以后，各个企业都看到了一个新的技术，可以运用到他们自己企业里面，所以很多企业都开始基于OpenStack做自己的私有云，让自己家的IT，变得效率更高，资源更有效。</p><p>然后，到了2014年以后，很多企业经过这么多年的建设以后，基本都走在了公有云和私有云这两条路上，私有云就是在家里，自建自用，不对外。公有云就是公开对外出售虚拟资源（如服务器、负载均衡器、防火墙等）在亚马逊、阿里或者华为都有这类服务，只要花钱买就可以。很多企业，尤其是中小企业，无力承担基础设施建设费用，就是通过购买EC2（云计算服务中资源服务器）来部署它的业务。还有一些企业，将一部分业务部署在公有云上，另一部分私密性业务部署在私有云上，这样就合成了一个混合云的状态。</p><h2 id="云计算技术的演进历程"><a href="#云计算技术的演进历程" class="headerlink" title="云计算技术的演进历程"></a>云计算技术的演进历程</h2><blockquote><p>随着云计算技术走向成熟，在混合云时代，企业对于云计算的相关技术成熟度的问题已经不太关注了。企业新的追求是，让IT的人员怎么在一个团队的模式下面，对公有云和私有云的混合云资源进行统一的管理。这是一个管理的概念，也是混合云构建的核心。</p></blockquote><p>云计算（Cloud Computing）是分布式计算（Distributed Computing）、并行计算（Parallel Computing）和网格计算（Grid Computing）的发展或者说是这些计算机科学概念的商业实现。</p><p><img src="https://i.loli.net/2019/02/18/5c6a661e66cb1.jpg" alt></p><p><strong>并行计算（Paralled Computing）：</strong>同时使用多种计算资源解决计算问题的过程，主要目的是快速解决大型且复杂的问题。</p><ul><li>特点：把计算任务分派给系统内多个计算单元。</li></ul><p><strong>分布式计算（Distributed Computing）：</strong>把一个需要巨大计算能力才能解决的问题分成多个小部分，把这些小部分分配给多个计算进行处理，最后综合这些计算结果得到最终的结果。</p><ul><li>特点：分配计算任务到网络中多台独立的机器。</li></ul><p><strong>网格计算（Grid Computing）：</strong>利用互联网把地理上广泛分布的各种资源连成一个逻辑的整体，就像一台超级计算机。</p><ul><li>特点：分布式计算的一种，为用户提供一体化的信息和应用服务。</li></ul><h2 id="云计算的部署模式"><a href="#云计算的部署模式" class="headerlink" title="云计算的部署模式"></a>云计算的部署模式</h2><blockquote><ul><li>私有云（Private Cloud）： 企业利用自有或租用的基础设施资源自建的云。</li></ul></blockquote><blockquote><ul><li>社区云/行业云（Community cloud）：为特定社区或行业所构建的共享基础设施的云。</li></ul></blockquote><blockquote><ul><li>公有云（Public cloud）：出租给公众的大型的基础设施的云。</li></ul></blockquote><blockquote><ul><li>混合云（Hybrid cloud）：由两种或两种以上部署模式组成的云。</li></ul></blockquote><p><img src="https://i.loli.net/2019/02/18/5c6a674bb56ce.jpg" alt></p><p>从部署模式上看，云计算又分为私有云、社区云也就是行业云、公有云、和混合云，这几种形态，这里也给出了具体的定义。简单理解：</p><ul><li><p>私有云就是企业建在自家院子里的，只给自己用的云，有些公司特别是公有云厂商喜欢把“私有云”称作“专有云”，名字不同，但含义基本相同，虽然这些厂商不愿意承认。</p></li><li><p>社区云既行业云，应用范围要比私有云广泛，更像是由家庭和家族的关系，往往应用在某个特定的区域或特定行业，主要给特殊血缘关系的行业或社区家族成员使用。</p></li><li><p>公有云的使用范围则更加宽泛，基本上只要给钱谁都可以用，因此公有云的规模往往也更大。</p></li></ul><p>但公有云的用户鱼龙混杂，像火车站一样，而且目标明显，不仅使用的好人多，惦记着甚至使用的坏人也不少，所以经常成为黑客及非法集团的攻击或信息偷窃目标。但瑕不掩瑜，人们不能因为火车上有小偷，就不坐火车了。但贵重的东西，比如大额现金最好就别随身带了，放家里由家人看着最保险，也就是在使用公有云的同时还使用私有云。而且希望公有云与私有云能很好的协同。这就是混合云了。</p><h2 id="云计算当前的商业模式"><a href="#云计算当前的商业模式" class="headerlink" title="云计算当前的商业模式"></a>云计算当前的商业模式</h2><blockquote><ul><li>云基础设施即服务（IaaS）— 出租处理能力、存储空间、网络容量等基本计算资源。</li></ul></blockquote><blockquote><ul><li>云平台即服务（PaaS）— 为客户开发的应用程序提供可部署的云环境。</li></ul></blockquote><blockquote><ul><li>云软件即服务（SaaS）— 在网络上提供可直接使的应用程序。</li></ul></blockquote><p>现在不止这几种，还有存储即服务，桌面即服务，数据中心即服务等等。</p><p>在服务模式上，云计算分为三种，包括：IaaS 基础设施即服务、PaaS 开发平台即服务、SaaS 软件即服务这三种模式。</p><ul><li><p><strong>IaaS</strong>，就是以前买IBM、HP、DELL、华为服务器存储跑企业业务（比如：生产管理业务、财务、市场客户管理、邮箱等），现在企业把业务放到Amazon的网站或华为企业云服务（公有云）网站就全搞定了。简单讲就是由“买”变“租”。大型企业的IT部门也可以以IaaS服务的形式，对内部业务部门提供服务，然后进行内部结算。</p></li><li><p><strong>PaaS</strong>，就是以前企业需要业务软件的时候，软件开发商在自己公司开发完在卖给企业客户，还要派人去安装软件。现在开发、安装都在企业客户那里全做了。当然给的钱也不再是软件费而是人头费了。</p></li><li><p><strong>SaaS</strong>，就是以前写汇报胶片用微软PPT软件，现在登录<a href="www.prezi.com">www.prezi.com</a>，在那个网站上就可以写胶片了，很酷。</p></li></ul><h2 id="云计算的8个通用特点"><a href="#云计算的8个通用特点" class="headerlink" title="云计算的8个通用特点"></a>云计算的8个通用特点</h2><blockquote><ul><li>大规模（Massive scale）</li></ul></blockquote><blockquote><ul><li>同质化（Homogeneity）</li></ul></blockquote><blockquote><ul><li>虚拟化（Virtualization）</li></ul></blockquote><blockquote><ul><li>弹性计算（Resilient computing）</li></ul></blockquote><blockquote><ul><li>低成本软件（Low cost software）</li></ul></blockquote><blockquote><ul><li>地理分布（Geographic distribution）</li></ul></blockquote><blockquote><ul><li>服务定位（Service orientation）</li></ul></blockquote><blockquote><ul><li>先进安全技术（Advanced security technologies）</li></ul></blockquote><p>这是美国国家标准与技术研究院给云计算列出的8个通用特点：</p><p><strong>大规模（Massive scale）</strong>，因为云计算服务把IT的资源供应集中化了，自然规模很大。也正因为如此，量变导致质变，使得云计算与传统IT有了众多的区别。</p><p><strong>同质化（Homogeneity）</strong>，也可以理解成标准化，这点倒是和用电很类似，大家要保持相同电压、插座接口，这样人们的电器和各种设备才能被广泛使用。</p><p><strong>虚拟化（Virtualization）</strong>，有两层含义，一个是计算单元的精细化，一块蛋糕太大，一个人吃不了，那最好切成小块，大家分着吃，也就是让每个计算单元更小，这样可以充分利用IT资源；另外一层含义是软硬件的分离，虚拟化之前软件和指定硬件是绑在一起的，虚拟化之后软件在所有硬件上可以自由的迁移，这跟人们由买房变成租房是一样的，既然北上广深的房价太高，很多人便租房住了，拎个箱子想住哪就住哪。</p><p><strong>弹性计算（Resilient computing）</strong>，在前面已经说过，指的是IT资源供给可弹性伸缩。</p><p><strong>低成本软件（Low cost software）</strong>，是从竞争与市场需求发展的角度说的。云计算降低了人们使用IT的门槛，不仅仅在个人技术能力上，而且在资金能力上，很多小微的初创企业，本身就没啥钱，希望能够用最少的钱使用最多的IT服务，要想打开这部分市场，自然需要低成本的软件，通过薄利多销的形式赚到更多的钱。</p><p><strong>地理分布（Geographic distribution）</strong>：前文我们提到了泛在接入，也就是能够在任意时间任意地点提供IT服务。从使用者的角度看，就是地理分散的，由于各地网络带宽的优劣差异，那么IT提供者，也就是云计算数据中心的部署，自然也是呈现出地理分布式特征的。大的公有云厂商都有几十个甚至数百个数据中心或服务节点，面向全球提供云计算服务。</p><p><strong>服务定位（Service orientation）</strong>：因为云计算是一种服务模式，它的整个体系的设计也就是面向服务的。</p><p><strong>先进安全技术（Advanced security technologies）</strong>，林子大了，什么鸟都有，公有云大了，什么用户也都有，包括好的坏的，自然先进的安全技术保障是一个云计算必须的条件了。</p><p>到此为止，对云计算的总结就是：4部署-3服务-5特性-8个通用点，简称<strong>4358</strong>。<br><img src="https://i.loli.net/2019/02/18/5c6a69805e25b.jpg" alt></p><h2 id="云计算的流派"><a href="#云计算的流派" class="headerlink" title="云计算的流派"></a>云计算的流派</h2><blockquote><p>从实现方式来看，云计算有两个典型的流派：<strong>大分小模式</strong>和<strong>小聚大模式</strong>。（现在这个概念已经很少有人提了，因为从资源的使用看，两种流派的本质是相同的）</p></blockquote><p><img src="https://i.loli.net/2019/02/18/5c6a69dc3017e.jpg" alt></p><p><strong>大分小模式</strong>：也称为Amazon流派，不同的应用在使用资源时，通过时分复用算法来调用。</p><blockquote><p>关键技术点包括：计算、存储和网络虚拟化以及虚拟机监控、调度和迁移。</p></blockquote><blockquote><p>典型代表：Amazon，alibaba，华为的EC2等。</p></blockquote><p><strong>小聚大模式</strong>：也称为Google流派，资源在多个应用间贡献，通过将应用划分多个子任务，结合调度算法来实现某个子引用在资源上的独占。</p><blockquote><p>关键技术点包括任务分解、调度、分布式通信总线和全局一致性。</p></blockquote><blockquote><p>典型代表：Google，我国的天河2号等</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;云计算的发展历程&quot;&gt;&lt;a href=&quot;#云计算的发展历程&quot; class=&quot;headerlink&quot; title=&quot;云计算的发展历程&quot;&gt;&lt;/a&gt;云计算的发展历程&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;云计算的历史也是蛮好玩的…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一开始就是在2003年之前，大家都在在提升CPU的计算能力，提升存储的空间，使得CPU性能越来越高、存储变得更大。
    
    </summary>
    
      <category term="云计算" scheme="https://kkutysllb.cn/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
      <category term="基础概念" scheme="https://kkutysllb.cn/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>2018-09-03-什么是云计算?</title>
    <link href="https://kkutysllb.cn/2018/09/03/2018-09-03-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    <id>https://kkutysllb.cn/2018/09/03/2018-09-03-什么是云计算/</id>
    <published>2018-09-02T18:25:25.000Z</published>
    <updated>2019-02-18T00:49:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="云计算概念的定义"><a href="#云计算概念的定义" class="headerlink" title="云计算概念的定义"></a>云计算概念的定义</h2><blockquote><p>云计算基础知识入门</p></blockquote><p>云计算是一种按使用量付费的模式，这种模式提供可用的、便捷的、按需的网络服务（即随时随地接入可接入），进入可配置的计算资源共享池（包括：网络、服务器、存储、应用软件、服务），这些资源能够被快速提供，只需投入很少的管理工作，或与服务供应商进行很少的交互。（美国国家标准与技术研究院）</p><p>云计算是一种基于互联网的计算方式，通过这种方式，共享软硬件资源和信息可以按需求提供给计算机和其他设备。云计算依赖资源的共享以达成规模经济，类似基础设施。（维基百科）<a id="more"></a></p><p>云计算概念诞生之初，市场上对其概念有很多种理解，经过一段时间的争论，现在大家一般来说都认可的就是美国标准与技术研究院的它给出的一个最标准的定义。它把云计算定义为一种模式，而不是一种技术。这种模式既可以是商业模式，也可以是服务模式。</p><h2 id="云计算的关键特征"><a href="#云计算的关键特征" class="headerlink" title="云计算的关键特征"></a>云计算的关键特征</h2><blockquote><p>按需自助服务（On-demand Self-service）</p></blockquote><blockquote><p>无处不在的网络接入（Broad Network Access）</p></blockquote><blockquote><p>与位置无关的资源池（Locations independent resources pooling）</p></blockquote><blockquote><p>快速弹性（Rapid Elastic）</p></blockquote><blockquote><p>按使用付费（Pay per User）</p></blockquote><p>我们从云计算的基本特质上进一步理解一下云计算的<strong>概念</strong>和<strong>内涵</strong>。</p><ul><li>从管理层面上说，云计算实现了IT资源的按需自助服务。“按需”是从量的角度来说，这是一种“量体裁衣”的资源使用方式，避免粗放管理带来成本损耗。“自助”是从人的角度来说，减少了资源使用者与资源管理者之间的频繁交互，进一步减少人工成本的损耗。同时，从历史上看，IT的使用难度每降低一个层次，IT产业就会获得一次质飞跃，因为客户数量会因此有指数级的提升。而“自助”这种简单化操作意味着更多的人都可以使用IT产品和服务。</li><li>云计算实现了广泛网络接入。这意味着用户可以在全球各地7x24小时的使用IT服务，也就是随时、随地、随心、随意的使用。这极大的提升了用户工作的灵活性和经营工作效率。</li><li>云计算实现了资源池化。“池化”就意味着资源的同质化、归一化。无论是网络、服务器、存储、应用还是服务，都是这些同质化、归一化资源的组合、协同实现。使用者和管理者只需考虑需求的资源“量”，无需考虑资源提供商之间的差异性。</li><li>云计算资源弹性伸缩。是指资源能够快速的供应和释放，就是说当你要的时候，我能快速的很快就给你，不是说你申请了以后，十天半个月我才给你资源，而是你要我马上就给你，当你不用的时候，我马上就回收，资源释放。</li><li>从经营层面上说，云计算实现了可计量的服务。“技术免费、服务收费”是开源社区的一个宗旨。前面也提到云计算的本质就是一种服务，为了实现这类服务收费，就必须要求服务可计量，而计量的依据就是资源使用的可计量。比如：按使用小时为时间单位，以服务器CPU个数、占用存储的空间、网络的带宽等综合计费，当然也可以包时、包天、包月那种套餐模式进行计量。而且，计量的越精细，运营效率越高。</li></ul><p>以上，就是美国标准与技术研究院给云计算标准的定义时所诠释的特质。</p><p>从技术视角来看：云计算=计算/存储的网络<br><img src="https://i.loli.net/2019/02/15/5c65b42eab5ed.jpg" alt="云计算技术视角"></p><p>商业视角：云计算=信息电厂<br><strong>计算和存储：</strong>由PC时代的局域网向云时代的互联网迁移。<br><strong>软件：</strong>由PC时代的终端向云端迁移。<br><img src="https://i.loli.net/2019/02/15/5c65d713ea4c2.jpg" alt="云计算商业视角"></p><p><strong>用户消费模式变化</strong></p><ul><li><p>通过互联网提供软硬件与服务；</p></li><li><p>用户通过浏览器或轻量级终端获取、使用服务。</p></li></ul><p><strong>商业模式发生变化</strong></p><ul><li>从“购买软硬件产品”向“购买信息服务”转变，如同100年前用电的转变。</li></ul><h2 id="云计算产生的背景"><a href="#云计算产生的背景" class="headerlink" title="云计算产生的背景"></a>云计算产生的背景</h2><blockquote><p>云计算=需求推动+技术进步+商业模式转变</p></blockquote><p><img src="https://i.loli.net/2019/02/15/5c65d7cbc65b6.jpg" alt><br>云计算的产生是需求推动、技术进步、商业模式转变共同促进的结果。</p><p><strong>需求推动：</strong></p><ul><li><p>政企客户低成本且高性能的信息化需求。</p></li><li><p>个人用户的互联网、移动互联网应用需求强烈，追求更好用户体验。</p></li></ul><p><strong>技术进步</strong></p><ul><li><p>虚拟化技术、分布与并行计算、互联网技术的发展与成熟，使得基于互联网提供包括IT基础设施、开发平台、软件应用成为可能。</p></li><li><p>宽带技术及用户发展，使得基于互联网的服务使用模式逐渐成为主流。</p></li></ul><p><strong>商业模式转变</strong></p><ul><li><p>少数云计算的先行者（例如Amazon的IaaS、PaaS)的云计算服务已开始运营。</p></li><li><p>市场对云计算商业模式已认可，越来越多的用户接受并使用云计算服务。</p></li><li><p>生态系统正在形成，产业链开始发展和整合。</p></li></ul><p>几年之内，云计算已从新兴技术发展成为当今的热点技术。从Google公开发布的核心文件到Amazon EC2（亚马逊弹性计算云）的商业化应用，再到美国电信巨头AT&amp;T（美国电话电报公司）推出的Synaptic Hosting（动态托管）服务，云计算从节约成本的工具到盈利的推动器，从ISP（网络服务提供商）到电信企业，已然成功地从内置的IT系统演变成公共的服务。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;云计算概念的定义&quot;&gt;&lt;a href=&quot;#云计算概念的定义&quot; class=&quot;headerlink&quot; title=&quot;云计算概念的定义&quot;&gt;&lt;/a&gt;云计算概念的定义&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;云计算基础知识入门&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;云计算是一种按使用量付费的模式，这种模式提供可用的、便捷的、按需的网络服务（即随时随地接入可接入），进入可配置的计算资源共享池（包括：网络、服务器、存储、应用软件、服务），这些资源能够被快速提供，只需投入很少的管理工作，或与服务供应商进行很少的交互。（美国国家标准与技术研究院）&lt;/p&gt;
&lt;p&gt;云计算是一种基于互联网的计算方式，通过这种方式，共享软硬件资源和信息可以按需求提供给计算机和其他设备。云计算依赖资源的共享以达成规模经济，类似基础设施。（维基百科）
    
    </summary>
    
      <category term="云计算" scheme="https://kkutysllb.cn/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
      <category term="基本概念" scheme="https://kkutysllb.cn/tags/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>2018-08-31-为什么开始写博客？</title>
    <link href="https://kkutysllb.cn/2018/08/31/2018-08-31-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%80%E5%A7%8B%E5%86%99%E5%8D%9A%E5%AE%A2%EF%BC%9F/"/>
    <id>https://kkutysllb.cn/2018/08/31/2018-08-31-为什么开始写博客？/</id>
    <published>2018-08-31T11:36:28.000Z</published>
    <updated>2019-02-18T00:49:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2018年3月—7月期间，有幸在外培训，时间相对宽松。当时，主要一直在自学SDN部分知识，鉴于同班同学一直询问询问云计算怎么学习？为此，我特意开通微信公众号，主要讲述一点儿OpenStack的基础知识。（如下）<a id="more"></a></p><p><img src="https://i.loli.net/2019/02/15/5c66ab29282da.jpg" alt></p><p>当时，还特意列出一个大纲，从最基础的Linux开始，一直到后续高级服务和应用。比如：Tacker、Workflow、批量热迁移等。</p><p>但是，微信公众号的排版实在是太浪费时间，再加上后续回到工作岗位，个人时间实在有限，因此公众号的内容一直处在长期停更，偶尔写写的状态。实在有愧大家的期待-_-!!!<br><img src="https://i.loli.net/2019/02/15/5c66abfd17423.jpg" alt></p><p>在2018年7月期间，一个偶然的机会让我接触到hexo和markdown两个小伙伴，让我燃起了写技术博客的动力。hexo主要用来生成静态页面，而markdown是一种极简的文本编写工具，其语法格式只有十来种，对编写网页博客有很大助力：-）利用这两个工具，可以提升网文的写作效率。至于怎么使用，网上的教程很多，大家可以自信搜索。</p><p>言归正传，后续公众号中已完成的内容我会逐渐搬到个人博客中来，并对前期挖的坑做个填补-_-!!!。新增的内容主要在个人博客中完成，微信公众号只能有空闲时间后，再进行补充，还请大家以后多关注博客内容。<br><img src="https://i.loli.net/2019/02/15/5c66abb56e42b.jpg" alt></p><p>另外，大家有什么疑惑，以后都可以在博客的留言区进行留言。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;2018年3月—7月期间，有幸在外培训，时间相对宽松。当时，主要一直在自学SDN部分知识，鉴于同班同学一直询问询问云计算怎么学习？为此，我特意开通微信公众号，主要讲述一点儿OpenStack的基础知识。（如下）
    
    </summary>
    
      <category term="随笔杂感" scheme="https://kkutysllb.cn/categories/%E9%9A%8F%E7%AC%94%E6%9D%82%E6%84%9F/"/>
    
    
      <category term="篇首语" scheme="https://kkutysllb.cn/tags/%E7%AF%87%E9%A6%96%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>2018-08-31-写在前面的话</title>
    <link href="https://kkutysllb.cn/2018/08/31/2018-08-31-%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2%E7%9A%84%E8%AF%9D/"/>
    <id>https://kkutysllb.cn/2018/08/31/2018-08-31-写在前面的话/</id>
    <published>2018-08-30T18:23:41.000Z</published>
    <updated>2019-02-18T00:49:06.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习大纲</p></blockquote><p>鉴于好多人询问云计算怎么学习？我的建议是实践和理论相结合！IT不像CT那么多理论和流程，IT诞生和发展的源动力就是提升工作效率。因此，IT的理论并没有CT那么难，但是要想用好，用巧必须具备相当丰富的实操经验。对于新手，最好的学习方式就是边实践边消化相关理论流程。<a id="more"></a><br><img src="https://i.loli.net/2019/02/15/5c66ad06d409f.jpg" alt></p><p>OpenStack是目前最成熟并且符合生产部署的一套开源云操作系统，全球各大IT，CT厂商，甚至运营商都为此投入了大量的人力、物力和精力。由于其开源的特性，全世界的云计算爱好者也为此贡献了很多。从openstack的特点来看，它是由python语音开发，是一个提供多种服务，相当灵活和稳定的云操作系统。以前的定义主要集中IaaS层（基础设施层），但是现在随着docker的出现，IaaS和PaaS（平台层）的界限已经非常模糊，同时随着K8s的兴起，甚至与SaaS的界限也不再清晰。从操作系统的组成来看，openstack+docker+k8s的组合更像一个更广泛的云化操作系统，openstack是内核，dokcer是用户空间，K8s是调用各项基础进程的API。</p><p>转入正题，由于openstack非常灵活，同时也就引入另一个问题，学习起来非常困难。因此，在学习openstack的同时，如果自己手头有一套实验环境那是相当的完美。我当初学习openstack是从devstack开始学起（openstack开发者版本），同时我也建议初学者从devstack开始学起。接下来我们就开始学习OpenStack的第一步，基础准备工作。</p><h2 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h2><blockquote><p>学习云计算的硬件和软件条件</p></blockquote><p>1、一台不少于16G内存，2CPU+内核笔记本或二手服务器，且硬件要开启支持虚拟化功能。BIOS中的开启方法如下图所示：<br><img src="https://i.loli.net/2019/02/15/5c66ad4779667.jpg" alt></p><p>2、下载CentOS 7的光盘安装镜像。下载地址在CentOS官网链接，下载DVD版本即可。<a href="https://www.centos.org/download/" target="_blank" rel="noopener">https://www.centos.org/download/</a><br><img src="https://i.loli.net/2019/02/15/5c66ad8ee916c.jpg" alt></p><p>3、去VMWare官网下载VMWare虚拟机软件，需要新注册个账号。下载链接如下：（注意：如果你你的宿主机是win10系统，不要下载VirtualBox，因为win10的无线网络在VirtualBox中设置桥接网络有BUG）<a href="https://www.vmware.com/cn/support/workstation.html" target="_blank" rel="noopener">https://www.vmware.com/cn/support/workstation.html</a><br><img src="https://i.loli.net/2019/02/15/5c66adbf75048.jpg" alt></p><p>以上工具就是我们环境搭建需要的基本工具。还有一些辅助工具如：XShell、XFTP可自行百度下载（个人版在官网申请是免费，记得千万不要升级）</p><p>下载地址如下：</p><p><a href="http://www.netsarang.com/products/xsh_overview.html" target="_blank" rel="noopener">http://www.netsarang.com/products/xsh_overview.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;学习大纲&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;鉴于好多人询问云计算怎么学习？我的建议是实践和理论相结合！IT不像CT那么多理论和流程，IT诞生和发展的源动力就是提升工作效率。因此，IT的理论并没有CT那么难，但是要想用好，用巧必须具备相当丰富的实操经验。对于新手，最好的学习方式就是边实践边消化相关理论流程。
    
    </summary>
    
      <category term="云计算" scheme="https://kkutysllb.cn/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
      <category term="OpenStack" scheme="https://kkutysllb.cn/tags/OpenStack/"/>
    
      <category term="基础准备" scheme="https://kkutysllb.cn/tags/%E5%9F%BA%E7%A1%80%E5%87%86%E5%A4%87/"/>
    
  </entry>
  
</feed>
