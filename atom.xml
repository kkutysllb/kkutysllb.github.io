<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一花一菩提，一云一世界</title>
  
  <subtitle>佛系ICT人士技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kkutysllb.cn/"/>
  <updated>2019-05-27T02:03:13.178Z</updated>
  <id>https://kkutysllb.cn/</id>
  
  <author>
    <name>kkutysllb</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2019-05-27-存储虚拟化概述</title>
    <link href="https://kkutysllb.cn/2019/05/27/2019-05-27-%E5%AD%98%E5%82%A8%E8%99%9A%E6%8B%9F%E5%8C%96%E6%A6%82%E8%BF%B0/"/>
    <id>https://kkutysllb.cn/2019/05/27/2019-05-27-存储虚拟化概述/</id>
    <published>2019-05-27T01:50:25.000Z</published>
    <updated>2019-05-27T02:03:13.178Z</updated>
    
    <content type="html"><![CDATA[<h2 id="存储虚拟化概述"><a href="#存储虚拟化概述" class="headerlink" title="存储虚拟化概述"></a><strong>存储虚拟化概述</strong></h2><p>存储虚拟化（StorageVirtualization）最通俗的理解就是对<strong>存储硬件资源进行抽象化表现</strong>。这种虚拟化可以将用户与存储资源中大量的物理特性隔绝开来，就好像我们去仓库存放或者提取物品一样，只要跟仓库管理员打交道，而不必关心我们的物品究竟存放在仓库内的哪一个角落。对于用户来说，虚拟化的存储资源就像是一个巨大的“<strong>存储池</strong>”，用户不会看到具体的存储磁盘、磁带，也不必关心自己的数据经过哪一条路径通往哪一个具体的存储设备。<a id="more"></a></p><p><img src="https://i.loli.net/2019/05/27/5ceb42a15d14167158.jpg"></p><p>存储虚拟化减少了物理存储设备的配置和管理任务，同时还能够充分利用现有的存储资源。存储虚拟化的方式是将整个云系统的存储资源进行统一整合管理，为用户提供一个统一的存储空间。如下图所示：</p><p><img src="https://i.loli.net/2019/05/27/5ceb42c95607517538.jpg"></p><h2 id="传统存储面临的挑战"><a href="#传统存储面临的挑战" class="headerlink" title="传统存储面临的挑战"></a>传统存储面临的挑战</h2><p>传统的数据中心里，存储的类型大致可分为以下几种：<strong>服务器内置磁盘、直接附加存储、存储区域网络</strong>及<strong>网络附加存储。</strong></p><p><strong>服务器内置磁盘</strong>包括SCSI、SATA及IDE磁盘等，这些磁盘可能直接由操作系统管理，也可能通阵列卡等RAID管理器进行配置使用（常见的有RAID 1、RAID 10、RAID 5、RAID 6等）。内置磁盘作为最简单直接的存储方式，在目前数据中心里仍然到处可见。服务器磁盘RAID阵列数据组织模式如下：</p><p><img src="https://i.loli.net/2019/05/27/5ceb4313377ef19877.jpg"></p><p><strong>直接附加存储（Directed Attached Storage，DAS）</strong>作为一种最简单的外接存储方式，通过数据线接连接在各种服务器或客户端扩展接口上。它本身是硬件的堆叠，不带有任何存储操作系统，因而也不能独立于服务器对外提供存储服务。DAS常见的形式是外置磁盘阵列，通常的配置就是RAID控制器+一堆磁盘。DAS安装方便、成本较低的特性使其特别适合于对存储容量要求不高、服务器数量较少的中小型数据中心。如下图所示：</p><p><img src="https://i.loli.net/2019/05/27/5ceb4329ab8ae55789.jpg"></p><p><strong>存储区域网络（Storage Area Network，SAN）</strong>是一种高速的存储专用网络，通过专用的网络交换术连接数据中心里的所有存储设备和服务器。在这样的存储网络中，<strong>存储设备与服务器是多对多的服务关系</strong>：一台存储设备可以为多台服务器同时提供服务，一台服务器也可以同时使用来自多台存储设备的存储服务。不同于DAS，SAN中的存储设备通常配备智能管理系统，能够独立对外提供存储服务。SAN存储网络系统结构图如下：</p><p><img src="https://i.loli.net/2019/05/27/5ceb434b6c2f940368.jpg"></p><p>典型的 SAN利用光纤通道（Fiber Channel，FC）技术连接节点，并使用光纤通道交换机（FC Switch）提供网络交换。<strong>不同于通用的数据网络，存储区域网络中的数据传输基于FC协议栈。在FC协议栈之上运行的SCSI协议提供存储访问服务。</strong>与之相对的iSCSI存储协议，则提供了一种低成本的替代方式 即将SCSI协议运行于TCP/IP协议栈之上。为了区别这两种存储区域网络，前者通常称为FC SAN，后者称为IP SAN。由于SAN存储采用网络架构和光纤传输，使它具有易部署、扩展强、传输快等优势，传输速率可达8~16Gbps。数据中心常见的SAN交换机如下图所示：</p><p><img src="https://i.loli.net/2019/05/27/5ceb436dddc3837134.jpg"></p><p><strong>网络附加存储（Network Attached Storage，NAS）</strong>提供了另一种独立于服务器的存储设备访问方（相对于内置存储与DAS）。类似于SAN，NAS也是通过网络交换的方式连接不同的存储设备与服务器。同样，<strong>存储设备与服务器之间也一种多对多的服务关系</strong>。NAS服务器通常也具有智能管理系统，能够独立对外提供服务。与SAN不同的是，NAS基于现有的企业网络（即TCP/IP网络），不需要额外搭建昂贵的专用存储网络（FC）。此外<strong>NAS通过文件I/O的方式提供存储，这点也不同于SAN的块 I/O访问方式。</strong>NAS存储的架构示意图如下：</p><p><img src="https://i.loli.net/2019/05/27/5ceb43961ff6b63941.jpg"></p><p><strong>常见的NAS访问协议有NFS（Network File System）和CIFS（Common Internet File System）</strong>，因此允许多台服务器以共享的方式访问同一个数据存储单元LUN。而且，由于<strong>NAS内部嵌入了一个精简的专门用于存储的操作系统，集成了网络传输和I/O访问等协议</strong>，因此NAS存储独立于用户操作系统，可在线扩展，且部署容易，管理成本低（相对SAN存储）。实际中的常见的NAS产品，比如群晖NAS产品实物图如下：</p><p><img src="https://i.loli.net/2019/05/27/5ceb43aedb34851404.jpg"></p><p>随着云计算与软件定义数据中心的出现，对存储管理有了更高的要求，传统存储也面临着诸多前所未有的挑战：</p><p>对于服务器内置磁盘和DAS来说，单一磁盘或阵列的容量与性能都是有限的，而且也很难对其进行扩展。另外这两种存储方式也缺乏各种数据服务，例如数据保护、高可用性、数据去重等。最大的麻烦在于这样的存储使用方式<strong>导致了一个个的信息孤岛，这对于数据中心的统一管理来说无疑是一个噩梦。</strong></p><p>对于SAN和NAS来说，目前的解决方案首先存在一个<strong>厂商绑定的问题</strong>。与服务器的标准化趋势不同，存储产品的操作系统（或管理系统）仍然是封闭的。不仅不同厂商之间的系统互不兼容，而且一家厂商的不同产品系列之间也不具有互操作性，这必然导致高价和技术壁垒。此外，<strong>管理孤岛的问题依旧存在</strong>，相对于DAS来说只是岛大一点，数量少一点而已。最后，<strong>SAN与NAS的扩展性</strong>也仍然是个问题。</p><p>另外，一些全新的需求，比如：对多租户（Multi-Tenancy）模式一致性支持、云弹性（Cloud-Scale）的动态迁移服务支持、动态定制的数据服务（Data Service）以及直接服务虚拟网络的应用等。这些需求并不是通过对传统存储架构的简单修修补补就可以满足的。</p><h2 id="存储虚拟化的定义"><a href="#存储虚拟化的定义" class="headerlink" title="存储虚拟化的定义"></a>存储虚拟化的定义</h2><p>为了解决上述挑战，存储虚拟化和软件定义存储SDS的概念日趋火热，但是需要注意一点—<strong>存储虚拟化并不等于软件定义存储SDS，准确点讲存储虚拟化是软件定义存储的一个具体实现。</strong>存储虚拟化的本质是存储整合的一个重要组成部分，它能减少管理问题，而且能够提高存储利用率，这样可以降低新增存储的费用。权威机构SNIA（存储网络工业协会）给出的定义为：<strong>通过将存储系统/子系统的内部功能从应用程序、计算服务器、网络资源中进行抽象、隐藏或隔离，实现独立于应用程序、网络的存储与数据管理。</strong></p><p>总结起来就是：<strong>存储虚拟化技术将底层存储设备进行抽象化统一管理，向服务器层屏蔽存储设备硬件的特殊性，而只保留其统一的逻辑特性，从而实现了存储系统的集中、统一、方便的管理。</strong></p><p>与传统存储相比，虚拟化存储的优点主要体现在：</p><p><strong>磁盘利用率高，</strong>传统存储技术的磁盘利用率一般只有30－70%，而采用虚拟化技术后的磁盘利用率高达70－90%；</p><p><strong>存储灵活，</strong>可以适应不同厂商、不同类别的异构存储平台，为存储资源管理提供了更好的灵活性；</p><p><strong>管理方便，</strong>提供了一个大容量存储系统集中管理的手段，避免了由于存储设备扩充所带来的管理方面的麻烦；</p><p><strong>性能更好，</strong>虚拟化存储系统可以很好地进行负载均衡，把每一次数据访问所需的带宽合理地分配到各个存储模块上，提高了系统的整体访问带宽。</p><p>如下图所示为华为存储虚拟化的解决方案架构图。</p><p><img src="https://i.loli.net/2019/05/27/5ceb43dbee02512952.jpg"></p><p>在华为的存储虚拟化解决方案中，有三个概念，分别是：<strong>存储资源、存储设备</strong>和<strong>数据存储。</strong></p><p><strong>存储资源：</strong>表示物理存储设备，例如IPSAN、Advanced SAN、NAS等。</p><p><strong>存储设备：</strong>表示存储资源中的管理单元，类似LUN、 Advanced SAN存储池、NAS共享目录等。</p><p><strong>数据存储：</strong>表示虚拟化平台中可管理、操作的存储逻辑单元。</p><p>各类存储资源的特性对比如下，其中，<strong>存储卸载是指将部分存储操作（模板部署、删除清零等操作）下移到存储侧进行，这样做可以不浪费主机侧资源，同时也可以提升操作效率</strong></p><table><thead><tr><th><strong>存储资源类型</strong></th><th><strong>底层协议</strong></th><th><strong>存储设备类型</strong></th><th><strong>是否支持虚拟化</strong></th><th><strong>是否支持存储卸载</strong></th></tr></thead><tbody><tr><td><strong>IPSAN</strong></td><td>TCP/IP</td><td>LUN</td><td>是</td><td>否</td></tr><tr><td><strong>FCSAN</strong></td><td>光纤</td><td>LUN</td><td>是</td><td>否</td></tr><tr><td><strong>NAS</strong></td><td>TCP/IP</td><td>共享目录</td><td>是</td><td>否</td></tr><tr><td><strong>本地磁盘</strong></td><td>本地连接</td><td>本地磁盘</td><td>是</td><td>否</td></tr><tr><td><strong>AdvancedSAN</strong></td><td>TCP/IP</td><td>存储池</td><td>否</td><td>是</td></tr><tr><td><strong>FusionStorage</strong></td><td>TCP/IP</td><td>存储池</td><td>是</td><td>是</td></tr></tbody></table><p>华为的虚拟化存储栈全景图如下，可以将不同存储设备进行格式化，屏蔽存储设备的能力、接口协议等差异性，将各种存储资源转化为统一管理的数据存储资源，可以用来存储虚拟机磁盘、虚拟机配置信息、快照等信息，使得用户对存储的管理更加同质化。</p><p><img src="https://i.loli.net/2019/05/27/5ceb43ff15c3725844.jpg"></p><h2 id="存储虚拟化的技术实现分类"><a href="#存储虚拟化的技术实现分类" class="headerlink" title="存储虚拟化的技术实现分类"></a>存储虚拟化的技术实现分类</h2><p>虚拟化存储有多种分类方法，从大的方面可以分为：<strong>根据在I/O路径中实现虚拟化的位置不同进行分类和根据控制路径和数据路径的不同进行分类。</strong></p><p>根据在I/O路径中实现虚拟化的位置不同，虚拟化存储可以分为<strong>主机的虚拟存储、网络的虚拟存储、存储设备的虚拟存储。</strong>根据控制路径和数据路径的不同，虚拟化存储分为<strong>对称虚拟化</strong>与<strong>不对称虚拟化</strong>。</p><p><strong>1）基于主机的虚拟存储</strong></p><p>基于主机的虚拟存储完全依赖存储管理软件，无需任何附加硬件。基于主机的存储管理软件，在系统和应用级上，实现多机间的共享存储、存储资源管理（存储媒介、卷、文件管理）、数据复制和数据迁移、远程备份、集群系统、灾难恢复等存储管理任务。</p><p>基于主机的虚拟存储又可分为<strong>数据块以上虚拟层</strong>和<strong>数据块存储虚拟层</strong>：数据块以上虚拟层（ViAualizationaboveBlock）它是存储虚拟化的最顶层，通过文件系统和数据库给应用程序提供一个虚拟数据视图，屏蔽了底层实现。数据块存储虚拟层（BlockStorageVirtualzation）通过基于主机的卷管理程序和附加设备接口，给主机提供一个整合的存储访问视图。卷管理程序为虚拟存储设备创建逻辑卷，井负责数据I/O请求的路由。如下图所示，为基于主机的虚拟化存储示意图，<strong>主要应用于服务器的存储空间可以跨越多个异构的磁盘阵列场景，常用于在不同磁盘阵列之间做数据镜像保护。</strong></p><p><img src="https://i.loli.net/2019/05/27/5ceb442eda30f46624.jpg"></p><p>一般由操作系统下的逻辑卷管理软件完成（安装客户端软件），不同操作系统的逻辑卷管理软件也不相同。<strong>优点是：</strong>支持异构的存储系统。<strong>缺点是：</strong>占用主机资源，转发性能差，与主机OS兼容性差，数据迁移复杂。</p><p><strong>2）基于存储设备的虚拟存储</strong> </p><p>基于存储设备的存储虚拟化方法依赖于提供相关功能的存储模块。如果没有第三方的虚拟软件，基于存储的虚拟化经常只能提供一种不完全的存储虚拟化解决方案。对于包含多厂商存储设备的SAN存储系统，这种方法的运行效果并不是很好。利用这种方法意味着最终将锁定某一家单独的存储厂商。如下图所示，为基于存储设备的虚拟化示意图，<strong>主要应用于在同一存储设备内部，进行数据保护和数据迁移的场景。</strong></p><p><img src="https://i.loli.net/2019/05/27/5ceb444810a8344557.jpg"></p><p>通过在存储控制器上添加虚拟化功能实现，只有中高端存储设备具备此功能。<strong>优点是：</strong>与主机无关，不占用主机资源，数据管理功能丰富。<strong>缺点是：</strong>只能对本设备内的磁盘虚拟化，厂商绑定不能异构，多套存储设备软件不兼容，需多部署，成本高。</p><p>比较常见的基于设备的存储虚拟化应用就是<strong>精简配置虚拟磁盘</strong>，能够提供远远大于物理磁盘容量的虚拟空间。不管虚拟机磁盘分配了多少空间，如果没有数据写到虚拟磁盘上，就不会占用任何物理磁盘空间。精简配置虚拟磁盘的示意图如下所示，可以用小的物理容量为操作系统提供超大容量的虚拟存储空间。并且，随着应用数据量的增长，实际存储空间也可以及时扩展，而无须手动扩展。总之，<strong>自动精简配置提供的是“运行时空间”，可以显著减少已分配但是未使用的存储空间。</strong></p><p><img src="https://i.loli.net/2019/05/27/5ceb446b00c5735992.jpg"></p><p>如果采用传统的磁盘分配方法，如上图左边。需要用户对当前和未来业务发展规模进行正确的预判，提前做好空间资源的规划。在实际中，由于对应用系统规模估计得不准确，往往会造成容量分配的浪费。</p><p>自动精简配置磁盘，如上图右边。有效地解决了存储资源的空间分配难题，提高了资源利用率。采用自动精简配置技术的数据卷分配给用户的是一个逻辑的虚拟磁盘，而不是一个固定的物理空间，只有当用户真正向该逻辑资源写数据时，才按照预先设定好的策略从物理空间分配实际空间容量。</p><p><strong>3）基于网络的虚拟存储</strong>  </p><p>网络虚拟层包括了绑定管理软件的存储服务器和网络互联设备。基于网络的虚拟化是在网络设备之间实现存储虚拟化功能，它将类似于卷管理的功能扩展到整个存储网络，负责管理Host视图、共享存储资源、数据复制、数据迁移及远程备份等，并对数据路径进行管理避免性能瓶颈。如下图所示，基于网络的虚拟存储示意图，<strong>主要用应用与异构存储系统的整合和统一管理场景。</strong></p><p><img src="https://i.loli.net/2019/05/27/5ceb4497df8e120691.jpg"></p><p>通过在存储域网（SAN）中添加虚拟化引擎实现。<strong>优点是：</strong>与主机无关，性能好、能够异构主机和存储设备、管理统一、功能丰富。<strong>缺点是：</strong>各厂商产品品质参差不齐，部分厂商产品想能差，兼容性差。</p><p>基于网络的虚拟存储可采用<strong>对称</strong>或<strong>非对称</strong>的虚拟存储架构。在非对称架构中，虚拟存储控制器处于系统数据通路之外，不直接参与数据的传输。服务器可以直接经过标准的交换机对存储设备进行访问。虚拟存储控制器对所有存储设备进行配置，并将配置信息提交给所有服务器，如下图所示，服务器在访问存储设备时，不再经过虚拟存储控制器，而是直接访问存储设备并发工作，同样达到了增大传输带宽的目的，这种架构也称为存储虚拟化的<strong>带外虚拟引擎</strong>（out-of-band）。</p><p><img src="https://i.loli.net/2019/05/27/5ceb44cb1b60a87719.jpg"></p><p><strong>一般用于不同存储设备之间的数据复制。优点是：</strong>虚拟化设备发生故障，整个系统将不会中断。<strong>缺点是：</strong>主机资源占用大，数据配置、同步复杂，缺乏统一管理。</p><p>而对称式架构中，虚拟存储控制设备直接位于服务器与存储设备之间，利用运行其上的存储管理软件来管理和配置所有存储设备，组成一个大型的存储池，其中的若干存储设备以一个逻辑分区的形式，被系统中所有服务器访问，这种架构也称为<strong>带内存储虚拟化引擎（in-band）</strong>。如下图所示，虚拟存储控制设备有多个数据通路与存储设备连接，多个存储设备并发工作，所以系统总的存储设备访问效率可达到较高水平。</p><p><img src="https://i.loli.net/2019/05/27/5ceb44e4060ec92829.jpg"></p><p><strong>主要用于异构存储系统整合，统一数据管理，在业务运行同时完成复制、镜像、CDP等各种数据管理功能。优点是：</strong>兼容性好，不占主机资源，配置简单，功能丰富。<strong>缺点是：</strong>虚拟化设备发生故障，整个系统将中断。</p><h2 id="软件定义存储SDS"><a href="#软件定义存储SDS" class="headerlink" title="软件定义存储SDS"></a>软件定义存储SDS</h2><p>上面提到过存储虚拟化并不等于软件定义存储SDS，其实存储虚拟化也可以归入软件定义存储的类别，实际上很多虚拟化存储厂商也是这么做的。但是严格意义上来说，这两者又略有不同，存储虚拟化一般只能在专门的硬件设备上使用，它的控制平面和存储数据平面是紧耦合的，很多厂商都要使用专门量身定做的设备才能实现存储虚拟化，而软件定义存储则没有设备限制，其控制平面和存储数据平面是松耦合，其本质上只定义控制平面的“软化”，而存储数据平面仍由各厂商去各自实现。可以简单理解成就是一个存储的管理程序。</p><p>软件定义存储实际上存在更大的适用范围，它的目标是从存储硬件中分离出存储控制功能和服务并提供编程接口，如 OpenStack Cinder， EMC ViPR，华为的Fusion Sphere和Fusion Storage都是这个范畴。如下图所示：</p><p><img src="https://i.loli.net/2019/05/27/5ceb4501611b596861.jpg"></p><p>再具体一点，软件定义存储是把存储硬件或软件提供的控制能力抽象出来，并与数据层面的能力(数据访问)分开，这些控制能力包括卷管理，RAID，QoS，数据复制，监控，快照和备份等等，这个举动意义在于这些控制能力抽象出来以后，任何厂商提供的存储能力控制都是接近的，避免对厂商的绑定。</p><p>然后它通过这些控制能力进一步为管理员提供自定义、基于策略的虚拟存储层，这些策略可以是基于空间、性能、费用等等因素。它的优势在于与存储虚拟化相比更加轻量，通常可以保留底层存储系统如SAN，阵列的特性并仍然发挥作用，而且部署和实现难度都大幅度下降，可以采用更小的代价实现管理存储基础设施的能力，如下图所示：</p><p><img src="https://i.loli.net/2019/05/27/5ceb451ede6a036106.jpg"></p><p>OpenStack Cinder是一个典型的软件定义存储产品，它目前支持大量的存储厂商设备，它定义了一些卷管理，快照，备份，简单统计等特性，用户可以使用Cinder提供的接口来获得不同存储设备提供的相似能力。</p><p><img src="https://i.loli.net/2019/05/27/5ceb453a6687d81104.jpg"></p><p>而Ceph可以看作一个典型的存储虚拟化产品，它将大量的通用存储设备联合起来提供一个存储池，并实现了一般存储厂商产品的能力。而Ceph的块存储能力使得它成为了Cinder的一个Driver。同时Cinder通过了这些基本API进行扩展，可以定义出不同的存储池，智能化的存储区域等等。</p><p><img src="https://i.loli.net/2019/05/27/5ceb455b5ab5057548.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;存储虚拟化概述&quot;&gt;&lt;a href=&quot;#存储虚拟化概述&quot; class=&quot;headerlink&quot; title=&quot;存储虚拟化概述&quot;&gt;&lt;/a&gt;&lt;strong&gt;存储虚拟化概述&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;存储虚拟化（StorageVirtualization）最通俗的理解就是对&lt;strong&gt;存储硬件资源进行抽象化表现&lt;/strong&gt;。这种虚拟化可以将用户与存储资源中大量的物理特性隔绝开来，就好像我们去仓库存放或者提取物品一样，只要跟仓库管理员打交道，而不必关心我们的物品究竟存放在仓库内的哪一个角落。对于用户来说，虚拟化的存储资源就像是一个巨大的“&lt;strong&gt;存储池&lt;/strong&gt;”，用户不会看到具体的存储磁盘、磁带，也不必关心自己的数据经过哪一条路径通往哪一个具体的存储设备。
    
    </summary>
    
      <category term="NFV关键技术" scheme="https://kkutysllb.cn/categories/NFV%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="电信云" scheme="https://kkutysllb.cn/tags/%E7%94%B5%E4%BF%A1%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://kkutysllb.cn/2019/05/27/2019-05-27-Linux%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4-%E7%AC%AC%E5%8D%81%E7%AF%87%E3%80%8A%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4%E3%80%8B/"/>
    <id>https://kkutysllb.cn/2019/05/27/2019-05-27-Linux系统命令-第十篇《系统管理命令》/</id>
    <published>2019-05-27T01:11:32.538Z</published>
    <updated>2019-05-27T01:47:40.637Z</updated>
    
    <content type="html"><![CDATA[<p>title: 2019-05-27-Linux系统命令-第十篇《系统管理命令》<br>date: 2019-05-27 09:11:32<br>tags:</p><ul><li>Linux<br>category:</li><li>Linux核心命令</li></ul><h2 id="lsof：查看进程打开的文件"><a href="#lsof：查看进程打开的文件" class="headerlink" title="lsof：查看进程打开的文件"></a>lsof：查看进程打开的文件</h2><p>lsof全名为list open files，也就是列举系统中已经被打开的文件，通过lsof命令，就可以根据文件找到对应的进程信息，也可以根据进程信息找到进程打开的文件。<a id="more"></a></p><p><strong>语法格式：lsof [option]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/05/27/5ceb398a4a0c461158.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）显示使用文件的进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示使用/var/log/message文件的进程信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># lsof /var/log/messages </span></span><br><span class="line">COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF      NODE NAME</span><br><span class="line">rsyslogd 1039 root    6w   REG    8,3   782990 101157938 /var/<span class="built_in">log</span>/messages</span><br></pre></td></tr></table></figure><blockquote><p><strong>如果想知道文件是被哪个进程所使用，直接lsof+文件名就可以查询。</strong></p><p><strong>上述结果的说明如下：</strong></p><p><strong>COMMAND：</strong>命令，进程的名称。</p><p><strong>PID：</strong>进程号。</p><p><strong>USER：</strong>进程的所有者。</p><p><strong>FD：</strong>文件描述符，它又包含如下内容。</p><p>​    <strong>0：</strong>表示标准输出。</p><p>​    <strong>1：</strong>表示标准输入。</p><p>​    <strong>2：</strong>表示标准错误。</p><p>​    <strong>u：</strong>表示该文件被打开并处于读取/写入模式。</p><p>​    <strong>r：</strong>表示该文件被打开并处于只读模式。</p><p>​    <strong>w：</strong>表示该文件被打开并处于写入模式。</p><p><strong>TYPE：</strong>文件类型，REG（regular）为普通文件。</p><p><strong>DEVICE：</strong>指定磁盘的标识。</p><p><strong>SIZE/OFF：</strong>文件的大小。</p><p><strong>NODE：</strong>索引节点。</p><p><strong>NAME：</strong>文件名称。进程号。</p><p><strong>USER：</strong>进程的所有者。</p><p><strong>FD：</strong>文件描述符，它又包含如下内容。</p><p>​    <strong>0：</strong>表示标准输出。</p><p>​    <strong>1：</strong>表示标准输入。</p><p>​    <strong>2：</strong>表示标准错误。</p><p>​    <strong>u：</strong>表示该文件被打开并处于读取/写入模式。</p><p>​    <strong>r：</strong>表示该文件被打开并处于只读模式。</p><p>​    <strong>w：</strong>表示该文件被打开并处于写入模式。</p><p><strong>TYPE：</strong>文件类型，REG（regular）为普通文件。</p><p><strong>DEVICE：</strong>指定磁盘的标识。</p><p><strong>SIZE/OFF：</strong>文件的大小。</p><p><strong>NODE：</strong>索引节点。</p><p><strong>NAME：</strong>文件名称。</p></blockquote><p><strong>2）显示指定进程所打开的文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过-c选项指定进程名</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># lsof -c crond</span></span><br><span class="line">COMMAND PID USER   FD      TYPE             DEVICE  SIZE/OFF      NODE NAME</span><br><span class="line">crond   671 root  cwd       DIR                8,3       224        64 /</span><br><span class="line">crond   671 root  rtd       DIR                8,3       224        64 /</span><br><span class="line">crond   671 root  txt       REG                8,3     70128    462795 /usr/sbin/crond</span><br><span class="line">crond   671 root  mem       REG                8,3     62184      1900 /usr/lib64/libnss_files-2.17.so</span><br><span class="line">crond   671 root  mem       REG                8,3 106070960 100665267 /usr/lib/locale/locale-archive</span><br><span class="line">crond   671 root  mem       REG                8,3    144792      1908 /usr/lib64/libpthread-2.17.so</span><br><span class="line">crond   671 root  mem       REG                8,3     23968      2361 /usr/lib64/libcap-ng.so.0.0.0</span><br><span class="line">crond   671 root  mem       REG                8,3    402384      2006 /usr/lib64/libpcre.so.1.2.0</span><br><span class="line">crond   671 root  mem       REG                8,3   2173512      1882 /usr/lib64/libc-2.17.so</span><br><span class="line">crond   671 root  mem       REG                8,3    127184      2359 /usr/lib64/libaudit.so.1.0.0</span><br><span class="line">crond   671 root  mem       REG                8,3     19776      1888 /usr/lib64/libdl-2.17.so</span><br><span class="line">crond   671 root  mem       REG                8,3     61672      3998 /usr/lib64/libpam.so.0.83.1</span><br><span class="line">crond   671 root  mem       REG                8,3    155784    190119 /usr/lib64/libselinux.so.1</span><br><span class="line">crond   671 root  mem       REG                8,3    164240      1875 /usr/lib64/ld-2.17.so</span><br><span class="line">crond   671 root    0r      CHR                1,3       0t0      1028 /dev/null</span><br><span class="line">crond   671 root    1u     unix 0xffff9fd574eca800       0t0     23970 socket</span><br><span class="line">crond   671 root    2u     unix 0xffff9fd574eca800       0t0     23970 socket</span><br><span class="line">crond   671 root    3uW     REG               0,20         4     23971 /run/crond.pid</span><br><span class="line">crond   671 root    4u     unix 0xffff9fd574e3f800       0t0     25637 socket</span><br><span class="line">crond   671 root    5r  a_inode               0,10         0      8261 inotify</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过-p选项指定进程号</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># lsof -p 1105</span></span><br><span class="line">COMMAND  PID   USER   FD      TYPE             DEVICE SIZE/OFF      NODE NAME</span><br><span class="line">httpd   1105 apache  cwd       DIR                8,3      224        64 /</span><br><span class="line">httpd   1105 apache  rtd       DIR                8,3      224        64 /</span><br><span class="line">httpd   1105 apache  txt       REG                8,3   523672   5947365 /usr/sbin/httpd</span><br><span class="line">httpd   1105 apache  mem       REG                8,3    62184      1900 /usr/lib64/libnss_files-2.17.so</span><br><span class="line">httpd   1105 apache  mem       REG                8,3    27808  68422763 /usr/lib64/httpd/modules/mod_cgi.so</span><br><span class="line">httpd   1105 apache  mem       REG                8,3    68192      2275 /usr/lib64/libbz2.so.1.0.6</span><br><span class="line">httpd   1105 apache  mem       REG                8,3   157424      2265 /usr/lib64/liblzma.so.5.2.2</span><br><span class="line">httpd   1105 apache  mem       REG                8,3    99944      2264 /usr/lib64/libelf-0.170.so</span><br><span class="line">httpd   1105 apache  mem       REG                8,3    19896      1993 /usr/lib64/libattr.so.1.1.0</span><br><span class="line">httpd   1105 apache  mem       REG                8,3    88720        84 /usr/lib64/libgcc_s-4.8.5-20150702.so.1</span><br><span class="line">httpd   1105 apache  mem       REG                8,3   297360    193704 /usr/lib64/libdw-0.170.so</span><br><span class="line">httpd   1105 apache  mem       REG                8,3    20032      1998 /usr/lib64/libcap.so.2.22</span><br><span class="line">httpd   1105 apache  mem       REG                8,3    44448      1912 /usr/lib64/librt-2.17.so</span><br><span class="line">。。。</span><br></pre></td></tr></table></figure><p><strong>3）监听指定的协议、端口和主机等信息，显示符合条件的网络服务进程</strong></p><p><strong>语法格式：lsof -i [46] [protocol][@hostname][:service|port]</strong></p><blockquote><p><strong>说明如下：</strong></p><p>46：4代表IPv4，6代表IPv6。</p><p>protocol：传输协议，可以是TCP或UDP。</p><p>hostname：主机名称或者IP地址。</p><p>service：进程的服务名，例如NFS、SSH和FTP等。</p><p>port：系统中与服务对应的端口号。例如HTTP服务默认对应的端口号为80，SSH服务默认对应的端口号为22。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有网络服务进程</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># lsof -i</span></span><br><span class="line">COMMAND    PID   USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class="line">systemd      1   root   48u  IPv6  42537      0t0  TCP *:telnet (LISTEN)</span><br><span class="line">chronyd    645 chrony    1u  IPv4  22341      0t0  UDP localhost:323 </span><br><span class="line">chronyd    645 chrony    2u  IPv6  22342      0t0  UDP localhost:323 </span><br><span class="line">sshd      1038   root    3u  IPv4  26920      0t0  TCP *:ssh (LISTEN)</span><br><span class="line">sshd      1038   root    4u  IPv6  26929      0t0  TCP *:ssh (LISTEN)</span><br><span class="line">httpd     1042   root    4u  IPv6  27020      0t0  TCP *:http (LISTEN)</span><br><span class="line">httpd     1101 apache    4u  IPv6  27020      0t0  TCP *:http (LISTEN)</span><br><span class="line">httpd     1102 apache    4u  IPv6  27020      0t0  TCP *:http (LISTEN)</span><br><span class="line">httpd     1103 apache    4u  IPv6  27020      0t0  TCP *:http (LISTEN)</span><br><span class="line">httpd     1104 apache    4u  IPv6  27020      0t0  TCP *:http (LISTEN)</span><br><span class="line">httpd     1105 apache    4u  IPv6  27020      0t0  TCP *:http (LISTEN)</span><br><span class="line">master    1310   root   13u  IPv4  24294      0t0  TCP localhost:smtp (LISTEN)</span><br><span class="line">master    1310   root   14u  IPv6  24295      0t0  TCP localhost:smtp (LISTEN)</span><br><span class="line">docker-pr 1648   root    4u  IPv6  24517      0t0  TCP *:terabase (LISTEN)</span><br><span class="line">sshd      1736   root    3u  IPv4  29038      0t0  TCP C7-Server01:ssh-&gt;192.168.101.1:servicetags (ESTABLISHED)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有tcp连接进程</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># lsof -i tcp</span></span><br><span class="line">COMMAND    PID   USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class="line">systemd      1   root   48u  IPv6  42537      0t0  TCP *:telnet (LISTEN)</span><br><span class="line">sshd      1038   root    3u  IPv4  26920      0t0  TCP *:ssh (LISTEN)</span><br><span class="line">sshd      1038   root    4u  IPv6  26929      0t0  TCP *:ssh (LISTEN)</span><br><span class="line">httpd     1042   root    4u  IPv6  27020      0t0  TCP *:http (LISTEN)</span><br><span class="line">httpd     1101 apache    4u  IPv6  27020      0t0  TCP *:http (LISTEN)</span><br><span class="line">httpd     1102 apache    4u  IPv6  27020      0t0  TCP *:http (LISTEN)</span><br><span class="line">httpd     1103 apache    4u  IPv6  27020      0t0  TCP *:http (LISTEN)</span><br><span class="line">httpd     1104 apache    4u  IPv6  27020      0t0  TCP *:http (LISTEN)</span><br><span class="line">httpd     1105 apache    4u  IPv6  27020      0t0  TCP *:http (LISTEN)</span><br><span class="line">master    1310   root   13u  IPv4  24294      0t0  TCP localhost:smtp (LISTEN)</span><br><span class="line">master    1310   root   14u  IPv6  24295      0t0  TCP localhost:smtp (LISTEN)</span><br><span class="line">docker-pr 1648   root    4u  IPv6  24517      0t0  TCP *:terabase (LISTEN)</span><br><span class="line">sshd      1736   root    3u  IPv4  29038      0t0  TCP C7-Server01:ssh-&gt;192.168.101.1:servicetags (ESTABLISHED)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示端口号为22的网络服务进程</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># lsof -i :22</span></span><br><span class="line">COMMAND  PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class="line">sshd    1038 root    3u  IPv4  26920      0t0  TCP *:ssh (LISTEN)</span><br><span class="line">sshd    1038 root    4u  IPv6  26929      0t0  TCP *:ssh (LISTEN)</span><br><span class="line">sshd    1736 root    3u  IPv4  29038      0t0  TCP C7-Server01:ssh-&gt;192.168.101.1:servicetags (ESTABLISHED)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有支持ipv6的进程</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># lsof -i 6</span></span><br><span class="line">COMMAND    PID   USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class="line">systemd      1   root   48u  IPv6  42537      0t0  TCP *:telnet (LISTEN)</span><br><span class="line">chronyd    645 chrony    2u  IPv6  22342      0t0  UDP localhost:323 </span><br><span class="line">sshd      1038   root    4u  IPv6  26929      0t0  TCP *:ssh (LISTEN)</span><br><span class="line">httpd     1042   root    4u  IPv6  27020      0t0  TCP *:http (LISTEN)</span><br><span class="line">httpd     1101 apache    4u  IPv6  27020      0t0  TCP *:http (LISTEN)</span><br><span class="line">httpd     1102 apache    4u  IPv6  27020      0t0  TCP *:http (LISTEN)</span><br><span class="line">httpd     1103 apache    4u  IPv6  27020      0t0  TCP *:http (LISTEN)</span><br><span class="line">httpd     1104 apache    4u  IPv6  27020      0t0  TCP *:http (LISTEN)</span><br><span class="line">httpd     1105 apache    4u  IPv6  27020      0t0  TCP *:http (LISTEN)</span><br><span class="line">master    1310   root   14u  IPv6  24295      0t0  TCP localhost:smtp (LISTEN)</span><br><span class="line">docker-pr 1648   root    4u  IPv6  24517      0t0  TCP *:terabase (LISTEN)</span><br></pre></td></tr></table></figure><p><strong>3）显示指定用户使用的文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-u选项，显示chrony用户使用的文件</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># lsof -u chrony</span></span><br><span class="line">COMMAND PID   USER   FD   TYPE             DEVICE SIZE/OFF   NODE NAME</span><br><span class="line">chronyd 645 chrony  cwd    DIR                8,3      224     64 /</span><br><span class="line">chronyd 645 chrony  rtd    DIR                8,3      224     64 /</span><br><span class="line">chronyd 645 chrony  txt    REG                8,3   261024 466082 /usr/sbin/chronyd</span><br><span class="line">chronyd 645 chrony  mem    REG                8,3   547568   1239 /usr/lib64/libfreeblpriv3.so</span><br><span class="line">chronyd 645 chrony  mem    REG                8,3    68192   2275 /usr/lib64/libbz2.so.1.0.6</span><br><span class="line">chronyd 645 chrony  mem    REG                8,3   157424   2265 /usr/lib64/liblzma.so.5.2.2</span><br><span class="line">chronyd 645 chrony  mem    REG                8,3    90248 190122 /usr/lib64/libz.so.1.2.7</span><br><span class="line">chronyd 645 chrony  mem    REG                8,3    99944   2264 /usr/lib64/libelf-0.170.so</span><br><span class="line">chronyd 645 chrony  mem    REG                8,3    88720     84 /usr/lib64/libgcc_s-4.8.5-20150702.so.1</span><br><span class="line">chronyd 645 chrony  mem    REG                8,3   297360 193704 /usr/lib64/libdw-0.170.so</span><br><span class="line">chronyd 645 chrony  mem    REG                8,3    44448   1912 /usr/lib64/librt-2.17.so</span><br><span class="line">chronyd 645 chrony  mem    REG                8,3    86544 193707 /usr/lib64/libnss_myhostname.so.2</span><br><span class="line">chronyd 645 chrony  mem    REG                8,3   106848   1910 /usr/lib64/libresolv-2.17.so</span><br><span class="line">chronyd 645 chrony  mem    REG                8,3    31824   1898 /usr/lib64/libnss_dns-2.17.so</span><br><span class="line">chronyd 645 chrony  mem    REG                8,3    62184   1900 /usr/lib64/libnss_files-2.17.so</span><br><span class="line">chronyd 645 chrony  mem    REG                8,3    19896   1993 /usr/lib64/libattr.so.1.1.0</span><br><span class="line">chronyd 645 chrony  mem    REG                8,3    19776   1888 /usr/lib64/libdl-2.17.so</span><br><span class="line">chronyd 645 chrony  mem    REG                8,3  2173512   1882 /usr/lib64/libc-2.17.so</span><br><span class="line">chronyd 645 chrony  mem    REG                8,3   144792   1908 /usr/lib64/libpthread-2.17.so</span><br><span class="line">chronyd 645 chrony  mem    REG                8,3   266680  86207 /usr/lib64/libseccomp.so.2.3.1</span><br><span class="line">chronyd 645 chrony  mem    REG                8,3    20032   1998 /usr/lib64/libcap.so.2.22</span><br><span class="line">chronyd 645 chrony  mem    REG                8,3    11464   1237 /usr/lib64/libfreebl3.so</span><br><span class="line">chronyd 645 chrony  mem    REG                8,3  1139680   1890 /usr/lib64/libm-2.17.so</span><br><span class="line">chronyd 645 chrony  mem    REG                8,3   164240   1875 /usr/lib64/ld-2.17.so</span><br><span class="line">chronyd 645 chrony    0u  unix 0xffff9fd57f8d7000      0t0  22339 socket</span><br><span class="line">chronyd 645 chrony    1u  IPv4              22341      0t0    UDP localhost:323 </span><br><span class="line">chronyd 645 chrony    2u  IPv6              22342      0t0    UDP localhost:323 </span><br><span class="line">chronyd 645 chrony    3r   CHR                1,9      0t0   1033 /dev/urandom</span><br><span class="line">chronyd 645 chrony    5u  unix 0xffff9fd57f8d6c00      0t0  22347 /var/run/chrony/chronyd.sock</span><br></pre></td></tr></table></figure><p><strong>4）显示所有socket文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-U选项可以显示所有socket文件</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># lsof -U</span></span><br><span class="line">COMMAND    PID    USER   FD   TYPE             DEVICE SIZE/OFF  NODE NAME</span><br><span class="line">systemd      1    root   12u  unix 0xffff9fd375ba5800      0t0 10700 /run/systemd/private</span><br><span class="line">systemd      1    root   14u  unix 0xffff9fd56b38ec00      0t0 42422 socket</span><br><span class="line">systemd      1    root   20u  unix 0xffff9fd577436400      0t0    31 /run/systemd/notify</span><br><span class="line">systemd      1    root   21u  unix 0xffff9fd577436800      0t0    33 /run/systemd/cgroups-agent</span><br><span class="line">systemd      1    root   22u  unix 0xffff9fd375ba1800      0t0 18449 /run/systemd/journal/stdout</span><br><span class="line">systemd      1    root   23u  unix 0xffff9fd5717e5c00      0t0 19070 /run/systemd/journal/stdout</span><br><span class="line">systemd      1    root   24u  unix 0xffff9fd3fb00f800      0t0 17293 /run/systemd/journal/stdout</span><br><span class="line">systemd      1    root   25u  unix 0xffff9fd3fbb68800      0t0 17326 /run/systemd/journal/stdout</span><br><span class="line">systemd      1    root   26u  unix 0xffff9fd5733cec00      0t0 19182 /run/systemd/journal/stdout</span><br><span class="line">systemd      1    root   28u  unix 0xffff9fd3fbb7fc00      0t0 19185 /run/systemd/journal/stdout</span><br><span class="line">systemd      1    root   29u  unix 0xffff9fd574eca400      0t0 24785 /run/systemd/journal/stdout</span><br><span class="line">systemd      1    root   30u  unix 0xffff9fd574e38000      0t0 24108 /run/systemd/journal/stdout</span><br><span class="line">systemd      1    root   31u  unix 0xffff9fd376117000      0t0 26054 /run/systemd/journal/stdout</span><br><span class="line">systemd      1    root   32u  unix 0xffff9fd3fbb74400      0t0 26904 /run/systemd/journal/stdout</span><br><span class="line">systemd      1    root   33u  unix 0xffff9fd375bec800      0t0 26905 /run/systemd/journal/stdout</span><br><span class="line">systemd      1    root   34u  unix 0xffff9fd376116c00      0t0 26908 /run/systemd/journal/stdout</span><br><span class="line">systemd      1    root   35u  unix 0xffff9fd3fb8f5800      0t0 14396 /run/systemd/shutdownd</span><br><span class="line">systemd      1    root   36u  unix 0xffff9fd5733c9000      0t0 22337 socket</span><br><span class="line">systemd      1    root   37u  unix 0xffff9fd375be8800      0t0 22569 /var/run/docker.sock</span><br><span class="line">systemd      1    root   38u  unix 0xffff9fd37612d800      0t0 22571 /run/dbus/system_bus_socket</span><br><span class="line">systemd      1    root   41u  unix 0xffff9fd3fb8f5000      0t0 14401 /run/udev/control</span><br><span class="line">systemd      1    root   42u  unix 0xffff9fd577437800      0t0    41 /run/systemd/journal/stdout</span><br><span class="line">systemd      1    root   43u  unix 0xffff9fd577437c00      0t0    44 /run/systemd/journal/socket</span><br><span class="line">systemd      1    root   45u  unix 0xffff9fd577436000      0t0    46 /dev/<span class="built_in">log</span></span><br><span class="line">systemd-j  462    root    3u  unix 0xffff9fd577437800      0t0    41 /run/systemd/journal/stdout</span><br><span class="line">systemd-j  462    root    4u  unix 0xffff9fd577437c00      0t0    44 /run/systemd/journal/socket</span><br><span class="line">。。。</span><br></pre></td></tr></table></figure><h2 id="uptime：显示系统的运行时间及负载"><a href="#uptime：显示系统的运行时间及负载" class="headerlink" title="uptime：显示系统的运行时间及负载"></a>uptime：显示系统的运行时间及负载</h2><p>uptime命令可以输出当前系统时间、系统开机到现在的运行时间、目前有多少用户在线和系统平均负载等信息。</p><p><strong>语法格式：uptime</strong></p><p><strong>【使用示例】</strong></p><p><strong>显示系统的运行时间及负载信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ~]<span class="comment"># uptime </span></span><br><span class="line">18:56:22 up  2:59,  1 user,  load average: 0.00, 0.01, 0.05</span><br></pre></td></tr></table></figure><h2 id="free：查看系统内存信息"><a href="#free：查看系统内存信息" class="headerlink" title="free：查看系统内存信息"></a>free：查看系统内存信息</h2><p>free命令用于显示系统内存状态，具体包括系统物理内存、虚拟内存、共享内存和系统缓存等。</p><p><strong>语法格式：free [option]</strong></p><p><strong>重要参数选项</strong></p><p><img src="https://i.loli.net/2019/05/27/5ceb3b0dcbba119224.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）查看系统内存</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不加任何参数使用free命令，结果是以字节为单位显示，很难看懂</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># free</span></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:        7992344      243632      259960       12084     7488752     7369040</span><br><span class="line">Swap:       8388604           0     8388604</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-m选项以MB为单位显示，但是可能不是很精确</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># free -m</span></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           7805         238         253          11        7313        7196</span><br><span class="line">Swap:          8191           0        8191</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-h选项，以人类可读的方式显示</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># free -h</span></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           7.6G        238M        253M         11M        7.1G        7.0G</span><br><span class="line">Swap:          8.0G          0B        8.0G</span><br></pre></td></tr></table></figure><p><strong>Linux系统的特性是将不用的物理内存缓存起来，因此253MB不是系统的真实剩余内存，系统真正可用的内存为7.0G。buffers为写入数据的缓冲区，cache为读取数据的缓冲区。</strong></p><p><strong>2）定时查询内存</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-s选项设定每10秒刷新一次内存</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># free -h -s 10</span></span><br><span class="line">total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           7.6G        236M        7.1G         11M        327M        7.1G</span><br><span class="line">Swap:          8.0G          0B        8.0G</span><br><span class="line">total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           7.6G        236M        7.1G         11M        327M        7.1G</span><br><span class="line">Swap:          8.0G          0B        8.0G</span><br><span class="line">total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           7.6G        237M        7.1G         11M        327M        7.1G</span><br><span class="line">Swap:          8.0G          0B        8.0G</span><br><span class="line">total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           7.6G        237M        7.1G         11M        327M        7.1G</span><br><span class="line">Swap:          8.0G          0B        8.0G</span><br></pre></td></tr></table></figure><h2 id="iftop：动态显示网络接口流量信息"><a href="#iftop：动态显示网络接口流量信息" class="headerlink" title="iftop：动态显示网络接口流量信息"></a>iftop：动态显示网络接口流量信息</h2><p>iftop是一款实时流量监控工具，可用于监控TCP/IP连接等，必须以root用户的身份运行。一般最小化安装系统都是没有这个命令的，需要使用yum命令额外安装，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装iftop</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># yum list | grep iftop</span></span><br><span class="line">iftop.x86_64                            1.0-0.14.pre4.el7              epel    </span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># yum install -y iftop</span></span><br></pre></td></tr></table></figure><p><strong>语法格式：iftop [option]</strong></p><p><strong>重要参数选项</strong></p><p><img src="https://i.loli.net/2019/05/27/5ceb3b7b2821539240.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）不使用任何选项启动iftop命令监控流量</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认监听系统的第一块网卡，可以使用-i选项指定网卡</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># iftop</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/05/27/5ceb3ba4db46537601.jpg"></p><blockquote><p><strong>上图说明如下：</strong></p><p>界面上显示的是类似刻度尺的刻度范围，是以标尺的形式显示流量图形的长条。</p><p>中间的&lt;=或=&gt;这两个左右箭头，表示的是流量的方向。</p><p>TX：发送流量。</p><p>RX：接收流量。</p><p>TOTAL：总流量。</p><p>Cum：运行iftop到目前时间的总流量。</p><p>peak：流量峰值。</p><p>rates：分别表示过去2s、10s、40s的平均流量。</p></blockquote><p><strong>2）常用命令组合</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -nNBP用于显示各服务端口号的流量情况，单位为byte</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认显示第一块网卡的流量，可以通过-i选项指定网卡</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># iftop -nNBP</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/05/27/5ceb3bdb6a02c59773.jpg"></p><h2 id="vmstat：虚拟内存统计"><a href="#vmstat：虚拟内存统计" class="headerlink" title="vmstat：虚拟内存统计"></a>vmstat：虚拟内存统计</h2><p>vmstat是Virtual Memory Statistics（虚拟内存统计）的缩写，利用vmstat命令可以对操作系统的内存信息、进程状态和CPU活动等进行监视。但是只能对系统的整体情况进行统计，无法对某个进程进行深入分析。</p><p><strong>语法格式：vmstat [option] [delay [ count]]，delay表示两次输出之间的间隔时间。count表示按照delay指定的时间间隔统计的次数。</strong></p><p><strong>重要参数选项</strong></p><p><img src="https://i.loli.net/2019/05/27/5ceb3bfc5d87271319.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）显示虚拟内存的使用情况</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果省略间隔时间和次数选项，则仅显示最后一次报告就退出</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># vmstat </span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   <span class="keyword">in</span>   cs us sy id wa st</span><br><span class="line"> 1  0      0 7267600   2076 479564    0    0    79     4   55   57  0  0 100  0  0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用delay选项，可以每隔n秒显示一次，直到ctrl+c退出</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># vmstat 5</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   <span class="keyword">in</span>   cs us sy id wa st</span><br><span class="line"> 1  0      0 7267436   2076 479652    0    0    75     4   53   56  0  0 100  0  0</span><br><span class="line"> 1  0      0 7267412   2076 479652    0    0     0     0   95  104  0  0 100  0  0</span><br><span class="line"> 0  0      0 7267288   2076 479652    0    0     0     0   84  101  0  0 100  0  0</span><br><span class="line"> 0  0      0 7267288   2076 479652    0    0     0     0   87  106  0  0 100  0  0</span><br><span class="line"> 0  0      0 7267288   2076 479652    0    0     0     0   88   99  0  0 100  0  0</span><br><span class="line"> 0  0      0 7267288   2076 479652    0    0     0     0   91  102  0  0 100  0  0</span><br><span class="line"> 0  0      0 7267288   2076 479652    0    0     0     0   83  100  0  0 100  0  0</span><br><span class="line"> 0  0      0 7267288   2076 479652    0    0     0     0   90  105  0  0 100  0  0</span><br><span class="line"> 0  0      0 7267288   2076 479652    0    0     0     0   85   95  0  0 100  0  0</span><br><span class="line">^C </span><br><span class="line"></span><br><span class="line"><span class="comment"># 加上count选项，可以按照指定次数显示，完成后自动退出</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># vmstat 5 6</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   <span class="keyword">in</span>   cs us sy id wa st</span><br><span class="line"> 1  0      0 7267312   2076 479652    0    0    70     3   51   54  0  0 100  0  0</span><br><span class="line"> 0  0      0 7267288   2076 479652    0    0     0     0  102  110  0  0 100  0  0</span><br><span class="line"> 0  0      0 7267288   2076 479652    0    0     0     0   85   95  0  0 100  0  0</span><br><span class="line"> 0  0      0 7267288   2076 479652    0    0     0     0   85   97  0  0 100  0  0</span><br><span class="line"> 0  0      0 7267288   2076 479652    0    0     0     0   90   98  0  0 100  0  0</span><br><span class="line"> 0  0      0 7267288   2076 479652    0    0     0     0   89   97  0  0 100  0  0</span><br></pre></td></tr></table></figure><blockquote><p><strong>上面输出的结果说明：</strong></p><p>第1列：procs。</p><p>​    r列表示运行和等待CPU时间片的进程数。</p><p>​    b列表示正在等待资源的进程数。</p><p>第2列：memory。</p><p>​    swpd列表示使用虚拟内存的大小。</p><p>​    free列表示当前空闲的物理内存数量。</p><p>​    buff列表示buffers的内存数量。</p><p>​    cache列表示cache的内存数量。</p><p>第3列：swap。</p><p>​    si（swap in）列表示由磁盘调入内存，也就是磁盘读入内存交换区的数量。</p><p>​    so（swap out）列表示由内存调入磁盘，也就是内存交换区写入磁盘的数量。</p><p>第4列：I/O项显示磁盘读写状况。</p><p>​    bi列表示从块设备读入数据的总量（即读磁盘）（块/s）。</p><p>​    bo列表示写入块设备的数据总量（即写磁盘）（块/s）。</p><p>第5列：system显示采集间隔内发生的中断数。</p><p>​    in列表示在某一时间间隔中观测到的每秒设备中断数。</p><p>​    cs列表示每秒产生的上下文切换次数。</p><p>第6列：CPU项显示了CPU的使用状态。</p><p>​    us列显示了用户进程消耗的CPU时间百分比。</p><p>​    sy列显示了系统（内核）进程消耗的CPU时间百分比。</p><p>​    id列显示了CPU处在空闲状态的时间百分比。</p><p>​    wa列显示了I/O等待所占用的CPU时间百分比。</p><p>​    st列显示了虚拟机占用的CPU时间的百分比。</p></blockquote><p><strong>2）显示活跃和非活跃内存</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每2秒刷新一次，共刷新5此，通过-a选项显示系统活跃和非活跃内存</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># vmstat -a 2 5</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line">r  b   swpd   free  inact active   si   so    bi    bo   <span class="keyword">in</span>   cs us sy id wa st</span><br><span class="line">1  0      0 7266764 244696 250212    0    0    57     3   45   48  0  0 100  0  0</span><br><span class="line">0  0      0 7266648 244696 250168    0    0     0     0   98  104  0  0 100  0  0</span><br><span class="line">0  0      0 7266648 244696 250168    0    0     0     0   81   93  0  0 100  0  0</span><br><span class="line">0  0      0 7266648 244696 250168    0    0     0     0   82   93  0  0 100  0  0</span><br><span class="line">0  0      0 7266648 244696 250168    0    0     0     0  114  135  0  0 100  0  0</span><br></pre></td></tr></table></figure><ul><li><strong>inact：表示非活跃内存的大小。</strong></li><li><strong>active：表示活跃内存的大小。</strong></li></ul><p><strong>3）查看内存使用的详细信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过-s选项可以查看内存使用的详细信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这些信息来自/proc/meminfo、/proc/stat和/proc/vmstat等内存映射文件</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># vmstat -s </span></span><br><span class="line">7992344 K total memory</span><br><span class="line">243984 K used memory</span><br><span class="line">250216 K active memory</span><br><span class="line">244696 K inactive memory</span><br><span class="line">7266392 K free memory</span><br><span class="line">2076 K buffer memory</span><br><span class="line">479892 K swap cache</span><br><span class="line">8388604 K total swap</span><br><span class="line">0 K used swap</span><br><span class="line">8388604 K free swap</span><br><span class="line">390 non-nice user cpu ticks</span><br><span class="line">0 nice user cpu ticks</span><br><span class="line">1466 system cpu ticks</span><br><span class="line">812275 idle cpu ticks</span><br><span class="line">229 IO-wait cpu ticks</span><br><span class="line">0 IRQ cpu ticks</span><br><span class="line">52 softirq cpu ticks</span><br><span class="line">0 stolen cpu ticks</span><br><span class="line">411934 pages paged <span class="keyword">in</span></span><br><span class="line">20492 pages paged out</span><br><span class="line">0 pages swapped <span class="keyword">in</span></span><br><span class="line">0 pages swapped out</span><br><span class="line">348908 interrupts</span><br><span class="line">371812 CPU context switches</span><br><span class="line">1556980554 boot time</span><br><span class="line">2038 forks</span><br></pre></td></tr></table></figure><p><strong>4）查看磁盘的读写信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-d可以查看所有磁盘的读写信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这些信息主要来自/proc/diskstats文件，merged表示合并写/读请求次数</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># vmstat -d</span></span><br><span class="line">disk- ------------reads------------ ------------writes----------- -----IO------</span><br><span class="line">total merged sectors      ms  total merged sectors      ms    cur    sec</span><br><span class="line">sr0       18      0    2056      28      0      0       0       0      0      0</span><br><span class="line">sda    10037      2  821813    7396   2986    132   40987    1497      0      4</span><br></pre></td></tr></table></figure><p><strong>5）查看指定分区的读写信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过-p选项可以指定分区查看读写信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># vmstat -p /dev/sda3</span></span><br><span class="line">sda3          reads   <span class="built_in">read</span> sectors  writes    requested writes</span><br><span class="line">8008     771194        931      36850</span><br></pre></td></tr></table></figure><blockquote><p><strong>这些信息主要来自于/proc/diskstats，输出结果各列的说明具体如下：</strong></p><p>reads：来自于该分区的读的次数。</p><p>read sectors：来自于该分区的读扇区的次数。</p><p>writes：来自于该分区的写的次数。</p><p>requested writes：来自于该分区的写请求次数。</p></blockquote><h2 id="mpstat：CPU信息统计"><a href="#mpstat：CPU信息统计" class="headerlink" title="mpstat：CPU信息统计"></a>mpstat：CPU信息统计</h2><p>mpstat是Multiprocessor Statistics的缩写，是一种实时系统监控工具。mpstat命令会输出CPU的一些统计信息，这些信息存放在/proc/stat文件中。在多CPU的系统里，此命令不但能用来查看所有CPU的平均状况信息，而且还能够用来查看特定CPU的信息。mpstat命令的最大特点是：可以查看多核心CPU中每个计算核心的统计数据，而类似命令vmstat只能查看系统整体的CPU情况。</p><p><strong>语法格式：mpstat [option] [delay [ count]]，delay和count的含义同vmstat。</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/05/27/5ceb3ccb675ce10702.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）显示CPU信息统计</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不加任何选项，默认显示所有CPU信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 省却delay和count，仅显示最后一次报告就退出</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># mpstat </span></span><br><span class="line">Linux 3.10.0-862.el7.x86_64 (C7-Server01) 05/04/2019 _x86_64_(4 CPU)</span><br><span class="line"></span><br><span class="line">11:26:00 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span><br><span class="line">11:26:00 PM  all    0.05    0.00    0.15    0.02    0.00    0.00    0.00    0.00    0.00   99.77</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每2秒刷新一次，共刷新5次</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># mpstat 2 5</span></span><br><span class="line">Linux 3.10.0-862.el7.x86_64 (C7-Server01) 05/04/2019 _x86_64_(4 CPU)</span><br><span class="line"></span><br><span class="line">11:27:09 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span><br><span class="line">11:27:11 PM  all    0.00    0.00    0.12    0.00    0.00    0.00    0.00    0.00    0.00   99.88</span><br><span class="line">11:27:13 PM  all    0.00    0.00    0.12    0.00    0.00    0.00    0.00    0.00    0.00   99.88</span><br><span class="line">11:27:15 PM  all    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00</span><br><span class="line">11:27:17 PM  all    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00</span><br><span class="line">11:27:19 PM  all    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00</span><br><span class="line">Average:     all    0.00    0.00    0.05    0.00    0.00    0.00    0.00    0.00    0.00   99.95</span><br></pre></td></tr></table></figure><blockquote><p><strong>命令输出结果的说明如下：</strong></p><p>第1列：11：27：09 PM，表示当前时间。</p><p>第2列：CPU，all表示所有CPU，0表示第一个CPU……</p><p>后面9列的含义分别如下。</p><p>％usr：用户进程消耗的CPU时间百分比。</p><p>％nice：改变过优先级的进程占用的CPU时间百分比。</p><p>％sys：系统（内核）进程消耗的CPU时间百分比。</p><p>％iowait：IO等待所占用的CPU时间百分比。</p><p>％irq：硬中断占用的CPU时间百分比。</p><p>％soft：软中断占用的CPU时间百分比。</p><p>％steal：虚拟机强制CPU等待的时间百分比。</p><p>％guest：虚拟机占用CPU时间的百分比。</p><p>％idle：CPU处在空闲状态的时间百分比。</p></blockquote><p><strong>2）显示指定CPU的信息统计</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 系统有4个cpu，通过-P选项指定显示第二个CPU的信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># mpstat -P 1</span></span><br><span class="line">Linux 3.10.0-862.el7.x86_64 (C7-Server01) 05/04/2019 _x86_64_(4 CPU)</span><br><span class="line">11:30:31 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span><br><span class="line">11:30:31 PM    1    0.06    0.00    0.22    0.02    0.00    0.01    0.00    0.00    0.00   99.70</span><br></pre></td></tr></table></figure><p>注意：这里的CPU指的是逻辑CPU，也就是超线程。</p><h2 id="iostat：I-O信息统计"><a href="#iostat：I-O信息统计" class="headerlink" title="iostat：I/O信息统计"></a>iostat：I/O信息统计</h2><p>iostat是I/O statistics（输入/输出统计）的缩写，其主要功能是对系统的磁盘I/O操作进行监视。它的输出主要是显示磁盘读写操作的统计信息，同时也会给出CPU的使用情况。同vmstat命令一样，iostat命令也不能对某个进程进行深入分析，仅会对系统的整体情况进行分析。</p><p><strong>语法格式：iostat [option] [ interval [ count ] ]，interval同delay。</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/05/27/5ceb3d27f0cb984707.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）显示所有设备的负载情况</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认不接任何选项，显示所有设备的负载情况</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 省略时间间隔和次数，仅显示最后一次报告就退出</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># iostat </span></span><br><span class="line">Linux 3.10.0-862.el7.x86_64 (C7-Server01) 05/04/2019 _x86_64_(4 CPU)</span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">0.05    0.00    0.13    0.02    0.00   99.80</span><br><span class="line">Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn</span><br><span class="line">scd0              0.01         0.29         0.00       1028          0</span><br><span class="line">sda               3.86       115.53         8.72     411970      31087</span><br></pre></td></tr></table></figure><blockquote><p><strong>命令输出结果的说明如下：</strong></p><p>第1～2行中各列的含义具体如下：</p><p>％user：用户进程消耗的CPU时间百分比。</p><p>％nice：改变过优先级的进程占用的CPU时间百分比。</p><p>％system：系统（内核）进程消耗的CPU时间百分比。</p><p>％iowait：IO等待所占用的CPU时间百分比。</p><p>％steal：虚拟机强制CPU等待的时间百分比。</p><p>％idle：CPU处在空闲状态的时间百分比。</p><p>第3～4行中各列的含义如下：</p><p>tps：表示该设备每秒的传输次数，“一次传输”的意思是“一次I/O请求”，多个逻辑请求可能会被合并为“一次I/O请求”，“一次传输”请求的大小是未知的。</p><p>kB_read/s：表示每秒读取的数据块数。</p><p>kB_wrtn/s：表示每秒写入的数据块数。</p><p>kB_read：表示读取的所有块数。</p><p>kB_wrtn：表示写入的所有块数。</p></blockquote><p><strong>3）只显示磁盘统计信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过-d选项直线磁盘的统计信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># iostat -d</span></span><br><span class="line">Linux 3.10.0-862.el7.x86_64 (C7-Server01) 05/04/2019 _x86_64_(4 CPU)</span><br><span class="line">Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn</span><br><span class="line">scd0              0.00         0.27         0.00       1028          0</span><br><span class="line">sda               3.63       108.57         8.20     411970      31124</span><br></pre></td></tr></table></figure><p><strong>4）查看扩展信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-x选项可以查看扩展信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># iostat -d -x</span></span><br><span class="line">Linux 3.10.0-862.el7.x86_64 (C7-Server01) 05/04/2019 _x86_64_(4 CPU)</span><br><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">scd0              0.00     0.00    0.00    0.00     0.27     0.00   114.22     0.00    1.56    1.56    0.00   1.11   0.00</span><br><span class="line">sda               0.00     0.05    2.63    0.93   106.63     8.06    64.38     0.00    0.68    0.74    0.54   0.33   0.12</span><br></pre></td></tr></table></figure><blockquote><p><strong>命令输出结果说明如下：</strong></p><p>rrqm/s：每秒进行merge的读操作数目。</p><p>wrqm/s：每秒进行merge的写操作数目。</p><p>r/s：每秒完成的读I/O设备次数。</p><p>w/s：每秒完成的写I/O设备次数。</p><p>rkB/s：每秒读入的千字节数。</p><p>wkB/s：每秒写入的千字节数。</p><p>avgrq-sz：设备平均每次进行I/O操作的数据大小（扇区）。</p><p>avgqu-sz：平均I/O队列长度。</p><p>await：设备平均每次I/O操作的等待时间（毫秒）。</p><p>svctm：设备平均每次I/O操作的服务时间（毫秒）。</p><p>％util：每秒钟用于I/O操作的百分比。</p></blockquote><p><strong>5）只查看CPU的统计信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过-c选项可以产看CPU的统计信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># iostat -c</span></span><br><span class="line">Linux 3.10.0-862.el7.x86_64 (C7-Server01) 05/04/2019 _x86_64_(4 CPU)</span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">0.04    0.00    0.12    0.02    0.00   99.82</span><br></pre></td></tr></table></figure><h2 id="iotop：动态显示磁盘I-O统计信息"><a href="#iotop：动态显示磁盘I-O统计信息" class="headerlink" title="iotop：动态显示磁盘I/O统计信息"></a>iotop：动态显示磁盘I/O统计信息</h2><p>iotop命令是一款实时监控磁盘I/O的工具，但必须以root用户的身份运行。使用iotop命令可以很方便地查看每个进程使用磁盘I/O的情况。最小化安装系统一般是没有这个命令的，需要使用yum命令额外安装，安装命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install iotop</span><br></pre></td></tr></table></figure><p><strong>语法格式：iotop [option]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/05/27/5ceb3dd50f76288111.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>不使用任何参数</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过iotop指令启动服务，类似top指令，不过它只显示磁盘io的使用情况</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># iotop</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/05/27/5ceb3dfba05f727072.jpg"></p><blockquote><p><strong>命令显示结果的说明如下：</strong></p><p>Total DISK READ：总的磁盘读取速度。</p><p>Total DISK WRITE：总的磁盘写入速度。</p><p>TID：进程pid值。</p><p>PRIO：优先级。</p><p>USER：用户。</p><p>DISK READ：磁盘读取速度。</p><p>DISK WRITE：磁盘写入速度。</p><p>SWAPIN：从swap分区读取数据占用的百分比。</p><p>IO：I/O占用的百分比。</p><p>COMMAND：消耗I/O的进程名。</p></blockquote><h2 id="sar：收集系统信息"><a href="#sar：收集系统信息" class="headerlink" title="sar：收集系统信息"></a>sar：收集系统信息</h2><p>通过sar命令，可以全面地获取系统的CPU、运行队列、磁盘I/O、分页（交换区）、内存、CPU中断和网络等性能数据。</p><p><strong>语法格式：sar [option] [ interval [ count ] ]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/05/27/5ceb3e2aa200578443.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）查看系统CPU的负载</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-u选项只显示系统CPU的负载情况</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># sar -u 2 3</span></span><br><span class="line">Linux 3.10.0-862.el7.x86_64 (C7-Server01) 05/04/2019 _x86_64_(4 CPU)</span><br><span class="line">11:55:12 PM     CPU     %user     %nice   %system   %iowait    %steal     %idle</span><br><span class="line">11:55:14 PM     all      0.00      0.00      0.00      0.00      0.00    100.00</span><br><span class="line">11:55:16 PM     all      0.00      0.00      0.12      0.00      0.00     99.88</span><br><span class="line">11:55:18 PM     all      0.00      0.00      0.00      0.00      0.00    100.00</span><br><span class="line">Average:        all      0.00      0.00      0.04      0.00      0.00     99.96</span><br></pre></td></tr></table></figure><p><strong>2）显示运行队列的大小</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-q选项，只显示运行队列大小</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># sar -q 2 3</span></span><br><span class="line">Linux 3.10.0-862.el7.x86_64 (C7-Server01) 05/04/2019 _x86_64_(4 CPU)</span><br><span class="line">11:56:26 PM   runq-sz  plist-sz   ldavg-1   ldavg-5  ldavg-15   blocked</span><br><span class="line">11:56:28 PM         0       248      0.00      0.01      0.05         0</span><br><span class="line">11:56:30 PM         0       248      0.00      0.01      0.05         0</span><br><span class="line">11:56:32 PM         1       248      0.00      0.01      0.05         0</span><br><span class="line">Average:            0       248      0.00      0.01      0.05         0</span><br></pre></td></tr></table></figure><blockquote><p><strong>命令输出结果说明如下：</strong></p><p>runq-sz：运行队列的长度（等待运行的进程数）。</p><p>plist-sz：进程列表中进程（process）和线程（thread）的数量。</p><p>ldavg-1：最后1分钟的系统平均负载（system load average）。</p><p>ldavg-5：过去5分钟的系统平均负载。</p><p>ldavg-15：过去15分钟的系统平均负载。</p></blockquote><p><strong>3）只显示系统内存的使用情况</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-r选项，只显示系统内存的使用</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># sar -r 2 3</span></span><br><span class="line">Linux 3.10.0-862.el7.x86_64 (C7-Server01) 05/04/2019 _x86_64_(4 CPU)</span><br><span class="line">11:59:34 PM kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty</span><br><span class="line">11:59:36 PM   7258452    733892      9.18      2076    390608    558672      3.41    268816    230800         0</span><br><span class="line">11:59:38 PM   7258452    733892      9.18      2076    390608    558672      3.41    268816    230800         0</span><br><span class="line">11:59:40 PM   7258452    733892      9.18      2076    390608    558672      3.41    268824    230800         0</span><br><span class="line">Average:      7258452    733892      9.18      2076    390608    558672      3.41    268819    230800         0</span><br></pre></td></tr></table></figure><blockquote><p><strong>命令输出结果说明如下：</strong></p><p>kbmemfree：空闲物理内存量。</p><p>kbmemused：使用中的物理内存量。</p><p>％memused：物理内存量的使用率。</p><p>kbbuffers：内核中作为缓冲区使用的物理内存容量。</p><p>kbcached：内核中作为缓存使用的物理内存容量。</p><p>kbcommit：应用程序当前使用的内存大小。</p><p>％commit：应用程序当前使用的内存大小占总大小的使用百分比。</p></blockquote><p><strong>4）显示缓冲区的使用情况</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-b选项，只显示缓冲区的使用情况</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># sar -b 2 3</span></span><br><span class="line">Linux 3.10.0-862.el7.x86_64 (C7-Server01) 05/05/2019 _x86_64_(4 CPU)</span><br><span class="line">12:01:59 AM       tps      rtps      wtps   bread/s   bwrtn/s</span><br><span class="line">12:02:01 AM      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">12:02:03 AM      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">12:02:05 AM      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">Average:         0.00      0.00      0.00      0.00      0.00</span><br></pre></td></tr></table></figure><blockquote><p><strong>命令输出结果如下：</strong></p><p>tps：每秒钟物理设备的I/O传输总量。</p><p>rtps：每秒钟从物理设备读入的数据总量。</p><p>wtps：每秒钟向物理设备写入的数据总量。</p><p>bread/s：每秒钟从物理设备读入的数据量，单位为块/s。</p><p>bwrtn/s：每秒钟向物理设备写入的数据量，单位为块/s。</p></blockquote><p><strong>5）显示网络的运行状态</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-n选项，只显示网络运行状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DEV表示网络接口</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># sar -n DEV 2 3</span></span><br><span class="line">Linux 3.10.0-862.el7.x86_64 (C7-Server01) 05/05/2019 _x86_64_(4 CPU)</span><br><span class="line"></span><br><span class="line">12:04:55 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s</span><br><span class="line">12:04:57 AM      eth0      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">12:04:57 AM      eth1      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">12:04:57 AM      eth2      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">12:04:57 AM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">12:04:57 AM vethc27967f      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">12:04:57 AM   docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line"></span><br><span class="line">12:04:57 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s</span><br><span class="line">12:04:59 AM      eth0      0.50      0.50      0.03      0.37      0.00      0.00      0.00</span><br><span class="line">12:04:59 AM      eth1      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">12:04:59 AM      eth2      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">12:04:59 AM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">12:04:59 AM vethc27967f      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">12:04:59 AM   docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line"></span><br><span class="line">12:04:59 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s</span><br><span class="line">12:05:01 AM      eth0      0.50      0.50      0.03      0.37      0.00      0.00      0.00</span><br><span class="line">12:05:01 AM      eth1      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">12:05:01 AM      eth2      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">12:05:01 AM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">12:05:01 AM vethc27967f      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">12:05:01 AM   docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line"></span><br><span class="line">Average:        IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s</span><br><span class="line">Average:         eth0      0.33      0.33      0.02      0.25      0.00      0.00      0.00</span><br><span class="line">Average:         eth1      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">Average:         eth2      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">Average:           lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">Average:    vethc27967f      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">Average:      docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示网络接口错包统计</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># EDEV表示网络接口错误信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># sar -n EDEV 2 3</span></span><br><span class="line">Linux 3.10.0-862.el7.x86_64 (C7-Server01) 05/05/2019 _x86_64_(4 CPU)</span><br><span class="line"></span><br><span class="line">12:06:49 AM     IFACE   rxerr/s   txerr/s    coll/s  rxdrop/s  txdrop/s  txcarr/s  rxfram/s  rxfifo/s  txfifo/s</span><br><span class="line">12:06:51 AM      eth0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">12:06:51 AM      eth1      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">12:06:51 AM      eth2      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">12:06:51 AM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">12:06:51 AM vethc27967f      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">12:06:51 AM   docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line"></span><br><span class="line">12:06:51 AM     IFACE   rxerr/s   txerr/s    coll/s  rxdrop/s  txdrop/s  txcarr/s  rxfram/s  rxfifo/s  txfifo/s</span><br><span class="line">12:06:53 AM      eth0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">12:06:53 AM      eth1      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">12:06:53 AM      eth2      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">12:06:53 AM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">12:06:53 AM vethc27967f      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">12:06:53 AM   docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line"></span><br><span class="line">12:06:53 AM     IFACE   rxerr/s   txerr/s    coll/s  rxdrop/s  txdrop/s  txcarr/s  rxfram/s  rxfifo/s  txfifo/s</span><br><span class="line">12:06:55 AM      eth0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">12:06:55 AM      eth1      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">12:06:55 AM      eth2      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">12:06:55 AM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">12:06:55 AM vethc27967f      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">12:06:55 AM   docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line"></span><br><span class="line">Average:        IFACE   rxerr/s   txerr/s    coll/s  rxdrop/s  txdrop/s  txcarr/s  rxfram/s  rxfifo/s  txfifo/s</span><br><span class="line">Average:         eth0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">Average:         eth1      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">Average:         eth2      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">Average:           lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">Average:    vethc27967f      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">Average:      docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过SOCK关键字，可以只显示套接字信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># sar -n SOCK 2 3</span></span><br><span class="line">Linux 3.10.0-862.el7.x86_64 (C7-Server01) 05/05/2019 _x86_64_(4 CPU)</span><br><span class="line"></span><br><span class="line">12:08:42 AM    totsck    tcpsck    udpsck    rawsck   ip-frag    tcp-tw</span><br><span class="line">12:08:44 AM       979         4         1         0         0         0</span><br><span class="line">12:08:46 AM       979         4         1         0         0         0</span><br><span class="line">12:08:48 AM       979         4         1         0         0         0</span><br><span class="line">Average:          979         4         1         0         0         0</span><br></pre></td></tr></table></figure><blockquote><p><strong>命令输出结果的说明：</strong></p><p>IFACE：网络接口。</p><p>rxpck/s：每秒钟接收的数据包。</p><p>txpck/s：每秒钟发送的数据包。</p><p>rxkB/s：每秒钟接收的字节数。</p><p>txkB/s：每秒钟发送的字节数。</p><p>rxcmp/s：每秒钟接收的压缩数据包。</p><p>txcmp/s：每秒钟发送的压缩数据包。</p><p>rxmcst/s：每秒钟接收的多播数据包。</p></blockquote><p><strong>6）显示磁盘的读写性能</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过-d选项，可以只显示磁盘的读写状态</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># sar -d 2 3</span></span><br><span class="line">Linux 3.10.0-862.el7.x86_64 (C7-Server01) 05/05/2019 _x86_64_(4 CPU)</span><br><span class="line">12:10:13 AM       DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util</span><br><span class="line">12:10:15 AM   dev11-0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">12:10:15 AM    dev8-0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">12:10:15 AM       DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util</span><br><span class="line">12:10:17 AM   dev11-0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">12:10:17 AM    dev8-0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">12:10:17 AM       DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util</span><br><span class="line">12:10:19 AM   dev11-0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">12:10:19 AM    dev8-0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">Average:          DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util</span><br><span class="line">Average:      dev11-0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">Average:       dev8-0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br></pre></td></tr></table></figure><blockquote><p><strong>输出结果说明如下：</strong></p><p>DEV：表示磁盘的设备名称。</p><p>tps：表示该设备每秒的传输次数，“一次传输”的意思是“一次I/O请求”，多个逻辑请求可能会被合并为“一次I/O请求”，“一次传输”请求的大小是未知的。</p><p>rd_sec/s：表示每秒从设备读取的扇区数。</p><p>wr_sec/s：表示每秒写入设备的扇区数目。</p><p>avgrq-sz：设备平均每次I/O操作的数据大小（扇区）。</p><p>avgqu-sz：平均I/O队列长度。</p><p>await：设备平均每次I/O操作的等待时间（毫秒）。</p><p>svctm：设备平均每次I/O操作的服务时间（毫秒）。</p><p>％util：每秒钟用于I/O操作的百分比。</p></blockquote><h2 id="ntsysv：管理开机服务"><a href="#ntsysv：管理开机服务" class="headerlink" title="ntsysv：管理开机服务"></a>ntsysv：管理开机服务</h2><p>ntsysv命令提供了一种基于文本界面的菜单操作方式，以设置不同运行级别下的系统服务启动状态。</p><p>此工具在最小化系统安装时没有安装，需要手动安装，安装命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询ntsysv的yum包，结果显示属于基础包</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># yum list | grep ntsysv</span></span><br><span class="line">ntsysv.x86_64                           1.7.4-1.el7                    base</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行yum install进行安装</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># yum install -y ntsysv</span></span><br></pre></td></tr></table></figure><p><strong>语法格式：ntsysv [option]</strong> </p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/05/27/5ceb3f2f7bcc312594.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>配置系统服务</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在命令行直接输入ntsysv，进入交互式菜单界面</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ntsysv</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/05/27/5ceb3f56f2f2286102.jpg"></p><p><strong>进入后，就可以通过键盘的上下左右键和tab键选择你需要配置的开机启动服务，如果需要确认某个选项，按空格键完成，取消确认按两次空格键即可。</strong></p><h2 id="rpm：RPM包管理器"><a href="#rpm：RPM包管理器" class="headerlink" title="rpm：RPM包管理器"></a>rpm：RPM包管理器</h2><p>rpm命令的全称是Red Hat Package Manager（Red Hat包管理器），几乎所有的Linux发行版本都使用了这种形式的命令管理、安装、更新和卸载软件。概括地说，rpm命令包含了五种基本功能（不包括创建rpm包）：安装、卸载、升级、查询和验证。</p><p><strong>语法格式：rpm [option]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/05/27/5ceb3f77ab40292709.jpg"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载一个软件包作为测试</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># wget https://mirrors.aliyun.com/centos/6/os/x86_64/Packages/lrzsz-0.12.20-27.1.el6.x86_64.rpm</span></span><br><span class="line">--2019-05-05 00:35:39--  https://mirrors.aliyun.com/centos/6/os/x86_64/Packages/lrzsz-0.12.20-27.1.el6.x86_64.rpm</span><br><span class="line">Resolving mirrors.aliyun.com (mirrors.aliyun.com)... 112.19.3.240, 112.19.3.241, 112.19.3.182, ...</span><br><span class="line">Connecting to mirrors.aliyun.com (mirrors.aliyun.com)|112.19.3.240|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 72436 (71K) [application/x-redhat-package-manager]</span><br><span class="line">Saving to: ‘lrzsz-0.12.20-27.1.el6.x86_64.rpm’</span><br><span class="line">100%[=====================================================&gt;] 72,436      --.-K/s   <span class="keyword">in</span> 0.07s   </span><br><span class="line">2019-05-05 00:35:42 (974 KB/s) - ‘lrzsz-0.12.20-27.1.el6.x86_64.rpm’ saved [72436/72436]</span><br></pre></td></tr></table></figure><p><strong>【使用示例】</strong></p><p><strong>1）查看rpm包信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示rpm包概要信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-q选项查询软件包</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-p选项指定某一个rpm包</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-i选线关于-qp联用，表示查看某个rpm包的概要信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># rpm -qpi lrzsz-0.12.20-27.1.el6.x86_64.rpm </span></span><br><span class="line">warning: lrzsz-0.12.20-27.1.el6.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID c105b9de: NOKEY</span><br><span class="line">Name        : lrzsz</span><br><span class="line">Version     : 0.12.20</span><br><span class="line">Release     : 27.1.el6</span><br><span class="line">Architecture: x86_64</span><br><span class="line">Install Date: (not installed)</span><br><span class="line">Group       : Applications/Communications</span><br><span class="line">Size        : 162901</span><br><span class="line">License     : GPLv2+</span><br><span class="line">Signature   : RSA/SHA256, Sun 03 Jul 2011 12:43:30 PM CST, Key ID 0946fca2c105b9de</span><br><span class="line">Source RPM  : lrzsz-0.12.20-27.1.el6.src.rpm</span><br><span class="line">Build Date  : Thu 19 Aug 2010 02:20:40 PM CST</span><br><span class="line">Build Host  : c6b3.bsys.dev.centos.org</span><br><span class="line">Relocations : (not relocatable)</span><br><span class="line">Packager    : CentOS BuildSystem </span><br><span class="line">Vendor      : CentOS</span><br><span class="line">URL         : http://www.ohse.de/uwe/software/lrzsz.html</span><br><span class="line">Summary     : The lrz and lsz modem communications programs</span><br><span class="line">Description :</span><br><span class="line">Lrzsz (consisting of lrz and lsz) is a cosmetically modified</span><br><span class="line">zmodem/ymodem/xmodem package built from the public-domain version of</span><br><span class="line">the rzsz package. Lrzsz was created to provide a working GNU</span><br><span class="line">copylefted Zmodem solution <span class="keyword">for</span> Linux systems.</span><br></pre></td></tr></table></figure><p><strong>2）查询软件包内容</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-q选项表示查询软件包</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-p选项表示查询某一个rpm包</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-l选项表示查看某一个rpm包里的软件列表</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># rpm -qpl lrzsz-0.12.20-27.1.el6.x86_64.rpm </span></span><br><span class="line">warning: lrzsz-0.12.20-27.1.el6.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID c105b9de: NOKEY</span><br><span class="line">/usr/bin/rb</span><br><span class="line">/usr/bin/rx</span><br><span class="line">/usr/bin/rz</span><br><span class="line">/usr/bin/sb</span><br><span class="line">/usr/bin/sx</span><br><span class="line">/usr/bin/sz</span><br><span class="line">/usr/share/locale/de/LC_MESSAGES/lrzsz.mo</span><br><span class="line">/usr/share/man/man1/rz.1.gz</span><br><span class="line">/usr/share/man/man1/sz.1.gz</span><br></pre></td></tr></table></figure><p><strong>3）查询软件包的依赖</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-q选项表示查询软件包</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-p选项表示查询某一个rpm包</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-R选项表示查看某一个rpm包依赖关系</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># rpm -qpR lrzsz-0.12.20-27.1.el6.x86_64.rpm </span></span><br><span class="line">warning: lrzsz-0.12.20-27.1.el6.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID c105b9de: NOKEY</span><br><span class="line">libc.so.6()(64bit)</span><br><span class="line">libc.so.6(GLIBC_2.11)(64bit)</span><br><span class="line">libc.so.6(GLIBC_2.2.5)(64bit)</span><br><span class="line">libc.so.6(GLIBC_2.3)(64bit)</span><br><span class="line">libc.so.6(GLIBC_2.3.4)(64bit)</span><br><span class="line">libc.so.6(GLIBC_2.4)(64bit)</span><br><span class="line">libc.so.6(GLIBC_2.7)(64bit)</span><br><span class="line">libnsl.so.1()(64bit)</span><br><span class="line">rpmlib(CompressedFileNames) &lt;= 3.0.4-1</span><br><span class="line">rpmlib(FileDigests) &lt;= 4.6.0-1</span><br><span class="line">rpmlib(PartialHardlinkSets) &lt;= 4.0.4-1</span><br><span class="line">rpmlib(PayloadFilesHavePrefix) &lt;= 4.0-1</span><br><span class="line">rtld(GNU_HASH)</span><br><span class="line">rpmlib(PayloadIsXz) &lt;= 5.2-1</span><br></pre></td></tr></table></figure><p><strong>4）安装软件包</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单独使用-i选项，表示安装某一个rpm包</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-v选项，表示安装时显示详细信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-h选项，表示用‘#’符号显示安装进度条</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># rpm -ivh lrzsz-0.12.20-27.1.el6.x86_64.rpm </span></span><br><span class="line">warning: lrzsz-0.12.20-27.1.el6.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID c105b9de: NOKEY</span><br><span class="line">Preparing...                          <span class="comment">################################# [100%]</span></span><br><span class="line">package lrzsz-0.12.20-36.el7.x86_64 (<span class="built_in">which</span> is newer than lrzsz-0.12.20-27.1.el6.x86_64) is already installed</span><br><span class="line">file /usr/bin/rb from install of lrzsz-0.12.20-27.1.el6.x86_64 conflicts with file from package lrzsz-0.12.20-36.el7.x86_64</span><br><span class="line">file /usr/bin/rx from install of lrzsz-0.12.20-27.1.el6.x86_64 conflicts with file from package lrzsz-0.12.20-36.el7.x86_64</span><br><span class="line">file /usr/bin/rz from install of lrzsz-0.12.20-27.1.el6.x86_64 conflicts with file from package lrzsz-0.12.20-36.el7.x86_64</span><br><span class="line">file /usr/bin/sb from install of lrzsz-0.12.20-27.1.el6.x86_64 conflicts with file from package lrzsz-0.12.20-36.el7.x86_64</span><br><span class="line">file /usr/bin/sx from install of lrzsz-0.12.20-27.1.el6.x86_64 conflicts with file from package lrzsz-0.12.20-36.el7.x86_64</span><br><span class="line">file /usr/bin/sz from install of lrzsz-0.12.20-27.1.el6.x86_64 conflicts with file from package lrzsz-0.12.20-36.el7.x86_64</span><br><span class="line">file /usr/share/man/man1/sz.1.gz from install of lrzsz-0.12.20-27.1.el6.x86_64 conflicts with file from package lrzsz-0.12.20-36.el7.x86_64</span><br></pre></td></tr></table></figure><p><strong>注意：我的机器因为已经安装过lrzsz工具，所以有上面的提示。</strong></p><p><strong>5）查询系统是否已经安装某个软件包</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-q选项，表示查询软件包</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-a选项，表示查询系统是否已经安装某个软件包</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有输出，表示没有安装，如果有输出表示已经安装</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># rpm -qa lrzsz</span></span><br><span class="line">lrzsz-0.12.20-36.el7.x86_64</span><br></pre></td></tr></table></figure><p><strong>6）卸载软件包</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-e选项，可以卸载指定的rpm包</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># rpm -e lrzsz</span></span><br></pre></td></tr></table></figure><p><strong>注意：这个参数比较危险，因为通过rpm是强依赖卸载，因为很有可能会误删除一些系统必备的文件，最后导致系统损坏。如果非要卸载，可以通过yum工具完成。</strong></p><p><strong>7）插叙文件属于哪个软件包</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-q选项，表示查询软件包</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-f选项，表示查询文件属于哪个软件包</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># rpm -qf $(which ifconfig)</span></span><br><span class="line">net-tools-2.0-0.24.20131004git.el7.x86_64</span><br></pre></td></tr></table></figure><p><strong>有时候会发现系统没有某些文件或者命令，但是又不知道这个文件或命令是属于哪个软件包，这时就可以使用-f参数来查询（在有这个文件的系统上查询）。比如本例查询ifconfig命令属于net-tools软件包。</strong></p><h2 id="yum：自动化RPM包管理工具"><a href="#yum：自动化RPM包管理工具" class="headerlink" title="yum：自动化RPM包管理工具"></a>yum：自动化RPM包管理工具</h2><p>yum（Yellow dog Updater Modified）是多个Linux发行版的软件包管理器，例如Redhat RHEL、CentOS和Fedora。yum主要用于自动安装、升级rpm软件包，它能自自动查找并解决rpm包之间的依赖关系。如下图：</p><p><img src="https://i.loli.net/2019/05/27/5ceb4053ebcb844502.jpg"></p><p>通过执行yum install -y lrzsz命令后，它会自动发现系统老版本的软件包，然后进行更新，更新后会自动删除老版本的软件包。</p><p><strong>语法格式：yum [option] [command] [package]</strong></p><p><strong>重要选线参数</strong></p><p><img src="https://i.loli.net/2019/05/27/5ceb406c42a6f39618.jpg"></p><p><img src="https://i.loli.net/2019/05/27/5ceb408073af029814.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）安装httpd软件包</strong></p><ul><li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-y选项，自动确认，无需交互式手动</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># yum install -y httpd</span></span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"></span><br><span class="line">- base: mirrors.aliyun.com</span><br><span class="line">- epel: mirrors.njupt.edu.cn</span><br><span class="line">- extras: mirrors.huaweicloud.com</span><br><span class="line">- updates: mirrors.huaweicloud.com</span><br><span class="line">  Package httpd-2.4.6-89.el7.centos.x86_64 already installed and latest version</span><br><span class="line">  Nothing to <span class="keyword">do</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>注意：有上面输出是因为我的系统已经安装过了httpd软件包。</strong></p><p><strong>2）查看httpd软件包的安装列表</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用list命令，可以查看某个软件包的安装列表</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># yum list httpd</span></span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"></span><br><span class="line">- base: mirrors.aliyun.com</span><br><span class="line">- epel: mirrors.njupt.edu.cn</span><br><span class="line">- extras: mirrors.huaweicloud.com</span><br><span class="line">- updates: mirrors.huaweicloud.com</span><br><span class="line">  Installed Packages</span><br><span class="line">  httpd.x86_64                            2.4.6-89.el7.centos                            @updates</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用search命令，可以搜索软件处仓库包含某个字段的所有软件包</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># yum search httpd</span></span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"></span><br><span class="line">- base: mirrors.aliyun.com</span><br><span class="line">- epel: mirrors.njupt.edu.cn</span><br><span class="line">- extras: mirrors.huaweicloud.com</span><br><span class="line">- updates: mirrors.huaweicloud.com</span><br><span class="line">  ===================================== N/S matched: httpd ======================================</span><br><span class="line">  iipsrv-httpd-fcgi.noarch : Apache HTTPD files <span class="keyword">for</span> iipsrv</span><br><span class="line">  keycloak-httpd-client-install.noarch : Tools to configure Apache HTTPD as Keycloak client</span><br><span class="line">  libmicrohttpd-devel.i686 : Development files <span class="keyword">for</span> libmicrohttpd</span><br><span class="line">  libmicrohttpd-devel.x86_64 : Development files <span class="keyword">for</span> libmicrohttpd</span><br><span class="line">  libmicrohttpd-doc.noarch : Documentation <span class="keyword">for</span> libmicrohttpd</span><br><span class="line">  lighttpd-fastcgi.x86_64 : FastCGI module and spawning helper <span class="keyword">for</span> lighttpd and PHP configuration</span><br><span class="line">  lighttpd-mod_authn_gssapi.x86_64 : Authentication module <span class="keyword">for</span> lighttpd that uses GSSAPI</span><br><span class="line">  lighttpd-mod_authn_mysql.x86_64 : Authentication module <span class="keyword">for</span> lighttpd that uses a MySQL database</span><br><span class="line">  lighttpd-mod_authn_pam.x86_64 : Authentication module <span class="keyword">for</span> lighttpd that uses PAM</span><br><span class="line">  lighttpd-mod_geoip.x86_64 : GeoIP module <span class="keyword">for</span> lighttpd to use <span class="keyword">for</span> location lookups</span><br><span class="line">  lighttpd-mod_mysql_vhost.x86_64 : Virtual host module <span class="keyword">for</span> lighttpd that uses a MySQL database</span><br><span class="line">  nextcloud-httpd.noarch : Httpd integration <span class="keyword">for</span> NextCloud</span><br><span class="line">  owncloud-httpd.noarch : Httpd integration <span class="keyword">for</span> ownCloud</span><br><span class="line">  python2-keycloak-httpd-client-install.noarch : Tools to configure Apache HTTPD as Keycloak</span><br><span class="line">                                            : client</span><br><span class="line">  radicale-httpd.noarch : httpd config <span class="keyword">for</span> Radicale</span><br><span class="line">  darkhttpd.x86_64 : A secure, lightweight, fast, single-threaded HTTP/1.1 server</span><br><span class="line">  httpd.x86_64 : Apache HTTP Server</span><br><span class="line">  httpd-devel.x86_64 : Development interfaces <span class="keyword">for</span> the Apache HTTP server</span><br><span class="line">  httpd-itk.x86_64 : MPM Itk <span class="keyword">for</span> Apache HTTP Server</span><br><span class="line">  httpd-manual.noarch : Documentation <span class="keyword">for</span> the Apache HTTP server</span><br><span class="line">  httpd-tools.x86_64 : Tools <span class="keyword">for</span> use with the Apache HTTP Server</span><br><span class="line">  libmicrohttpd.i686 : Lightweight library <span class="keyword">for</span> embedding a webserver <span class="keyword">in</span> applications</span><br><span class="line">  libmicrohttpd.x86_64 : Lightweight library <span class="keyword">for</span> embedding a webserver <span class="keyword">in</span> applications</span><br><span class="line">  lighttpd.x86_64 : Lightning fast webserver with light system requirements</span><br><span class="line">  mirmon-httpd.noarch : Apache configuration <span class="keyword">for</span> mirmon</span><br><span class="line">  mod_auth_mellon.x86_64 : A SAML 2.0 authentication module <span class="keyword">for</span> the Apache Httpd Server</span><br><span class="line">  mod_dav_svn.x86_64 : Apache httpd module <span class="keyword">for</span> Subversion server</span><br><span class="line">  opensips-httpd.x86_64 : HTTP transport layer implementation</span><br><span class="line">  perl-Test-Fake-HTTPD.noarch : Fake HTTP server module <span class="keyword">for</span> testing</span><br><span class="line">  python2-sphinxcontrib-httpdomain.noarch : Sphinx domain <span class="keyword">for</span> documenting HTTP APIs</span><br><span class="line">  sysusage-httpd.noarch : Apache configuration <span class="keyword">for</span> sysusage</span><br><span class="line">  thttpd.x86_64 : A tiny, turbo, throttleable lightweight HTTP server</span><br><span class="line">  viewvc-httpd-fcgi.noarch : ViewVC configuration <span class="keyword">for</span> Apache/mod_fcgid</span><br><span class="line">  viewvc-httpd-wsgi.noarch : ViewVC configuration <span class="keyword">for</span> Apache/mod_wsgi</span><br><span class="line">  web-assets-httpd.noarch : Web Assets aliases <span class="keyword">for</span> the Apache HTTP daemon</span><br><span class="line"></span><br><span class="line">  Name and summary matches only, use <span class="string">"search all"</span> <span class="keyword">for</span> everything.</span><br></pre></td></tr></table></figure><p><strong>3）查看已安装和未安装的包组</strong></p><ul><li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用grouplist命令，可以查看所有包组情况</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># yum grouplist</span></span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">There is no installed groups file.</span><br><span class="line">Maybe run: yum groups mark convert (see man yum)</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"></span><br><span class="line">- base: mirrors.aliyun.com</span><br><span class="line">- epel: mirrors.njupt.edu.cn</span><br><span class="line">- extras: mirrors.huaweicloud.com</span><br><span class="line">- updates: mirrors.huaweicloud.com</span><br><span class="line">  Available Environment Groups:</span><br><span class="line">  Minimal Install</span><br><span class="line">  Compute Node</span><br><span class="line">  Infrastructure Server</span><br><span class="line">  File and Print Server</span><br><span class="line">  Cinnamon Desktop</span><br><span class="line">  MATE Desktop</span><br><span class="line">  Basic Web Server</span><br><span class="line">  Virtualization Host</span><br><span class="line">  Server with GUI</span><br><span class="line">  GNOME Desktop</span><br><span class="line">  KDE Plasma Workspaces</span><br><span class="line">  Development and Creative Workstation</span><br><span class="line">  Available Groups:</span><br><span class="line">  Cinnamon</span><br><span class="line">  Compatibility Libraries</span><br><span class="line">  Console Internet Tools</span><br><span class="line">  Development Tools</span><br><span class="line">  Educational Software</span><br><span class="line">  Electronic Lab</span><br><span class="line">  Fedora Packager</span><br><span class="line">  General Purpose Desktop</span><br><span class="line">  Graphical Administration Tools</span><br><span class="line">  Haskell</span><br><span class="line">  Legacy UNIX Compatibility</span><br><span class="line">  MATE</span><br><span class="line">  Milkymist</span><br><span class="line">  Scientific Support</span><br><span class="line">  Security Tools</span><br><span class="line">  Smart Card Support</span><br><span class="line">  System Administration Tools</span><br><span class="line">  System Management</span><br><span class="line">  TurboGears application framework</span><br><span class="line">  Xfce</span><br><span class="line">  Done</span><br></pre></td></tr></table></figure></li></ul><p><strong>4）从包组中安装某个软件包</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用groupinstall命令，可以从包组查找指定软件包进行安装</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># yum groupinstall -y "SNMP Support"</span></span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">There is no installed groups file.</span><br><span class="line">Maybe run: yum groups mark convert (see man yum)</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">。。。。</span><br></pre></td></tr></table></figure><p><strong>注意：此例只是示例，只是表示可以这样使用，并不代表真的存在相关描述的软件包。因为从包组中查找安装软件包非常少用，几乎用不到。如果想安装某个软件包，可以使用yum list | grep “软件包名或通配”来完成。</strong></p><p><strong>至此，Linux常用的系统管理命令已经更新完毕，其实，在Linux系统管理中最常用的还是一些管理工具，会在Linux常用工具分类中系统管理工具有总体介绍。</strong></p><p><strong>随着Linux系统管理命令更新结束，Linux系统核心命令部分全部更新完毕，共分为10篇，约70-80个常用命令，与Linux系统总体命令600余个相比还差很远。但是，这些常用命令以及后续介绍常用工具是一个运维人员必须掌握的，至于其它命令和工具在实际中碰到了再查询使用帮助即可。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;title: 2019-05-27-Linux系统命令-第十篇《系统管理命令》&lt;br&gt;date: 2019-05-27 09:11:32&lt;br&gt;tags:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux&lt;br&gt;category:&lt;/li&gt;
&lt;li&gt;Linux核心命令&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;lsof：查看进程打开的文件&quot;&gt;&lt;a href=&quot;#lsof：查看进程打开的文件&quot; class=&quot;headerlink&quot; title=&quot;lsof：查看进程打开的文件&quot;&gt;&lt;/a&gt;lsof：查看进程打开的文件&lt;/h2&gt;&lt;p&gt;lsof全名为list open files，也就是列举系统中已经被打开的文件，通过lsof命令，就可以根据文件找到对应的进程信息，也可以根据进程信息找到进程打开的文件。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2019-05-25-Linux系统命令-第九篇《网络管理命令》</title>
    <link href="https://kkutysllb.cn/2019/05/25/2019-05-25-Linux%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4-%E7%AC%AC%E4%B9%9D%E7%AF%87%E3%80%8A%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4%E3%80%8B/"/>
    <id>https://kkutysllb.cn/2019/05/25/2019-05-25-Linux系统命令-第九篇《网络管理命令》/</id>
    <published>2019-05-25T13:51:45.000Z</published>
    <updated>2019-05-25T14:13:21.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ifconfig：配置或显示网络接口信息"><a href="#ifconfig：配置或显示网络接口信息" class="headerlink" title="ifconfig：配置或显示网络接口信息"></a>ifconfig：配置或显示网络接口信息</h2><p>ifconfig命令用于配置网卡IP地址等网络参数或显示当前网络的接口状态，其类似于Windows下的ipconfig命令，这两个命令很容易混淆，读者需要区分一下。此外，ifconfig命令在配置网卡信息时必须以root用户的身份来执行。使用ifconfig命令配置网卡信息仅会临时生效，重启网络或服务器配置就会失效。要想配置永久生效，正确的姿势是“编辑配置网卡配置文件”。<a id="more"></a></p><p>如果系统中没有ifconfig命令，那就需要安装一下，安装命令为yum-y install net-tools。</p><p>interface为网络接口名，Linux下的网络接口名类似于eth0、eth1和lo等，分别表示第1块网卡、第2块网卡和回环接口。这是个可选项，如果不添加此选项，则显示系统中所有的网卡信息；如果添加此选项，则显示指定的网卡信息。</p><p><strong>语法格式：ifconfig [interface] [option]</strong></p><p><strong>重要参数选项</strong></p><p><img src="https://i.loli.net/2019/05/25/5ce948c28413a32697.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）显示当前系统开启的所有网络接口</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用ifconfig不带任何选项显示所有活动的网络接口</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ifconfig</span></span><br><span class="line">docker0: flags=4163  mtu 1500</span><br><span class="line">inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class="line">inet6 fe80::42:56ff:fe71:5647  prefixlen 64  scopeid 0x20</span><br><span class="line">ether 02:42:56:71:56:47  txqueuelen 0  (Ethernet)</span><br><span class="line">RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">TX packets 8  bytes 648 (648.0 B)</span><br><span class="line">TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line">eth0: flags=4163  mtu 1500</span><br><span class="line">inet 192.168.101.81  netmask 255.255.255.0  broadcast 192.168.101.255</span><br><span class="line">inet6 fe80::20c:29ff:fe17:f09e  prefixlen 64  scopeid 0x20</span><br><span class="line">ether 00:0c:29:17:f0:9e  txqueuelen 1000  (Ethernet)</span><br><span class="line">RX packets 84  bytes 9437 (9.2 KiB)</span><br><span class="line">RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">TX packets 112  bytes 11835 (11.5 KiB)</span><br><span class="line">TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line">eth1: flags=4163  mtu 1500</span><br><span class="line">inet 172.0.2.81  netmask 255.255.255.0  broadcast 172.0.2.255</span><br><span class="line">inet6 fe80::20c:29ff:fe17:f0a8  prefixlen 64  scopeid 0x20</span><br><span class="line">ether 00:0c:29:17:f0:a8  txqueuelen 1000  (Ethernet)</span><br><span class="line">RX packets 1  bytes 243 (243.0 B)</span><br><span class="line">RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">TX packets 14  bytes 1008 (1008.0 B)</span><br><span class="line">TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line">eth2: flags=4163  mtu 1500</span><br><span class="line">inet 10.0.5.81  netmask 255.255.255.0  broadcast 10.0.5.255</span><br><span class="line">inet6 fe80::20c:29ff:fe17:f0b2  prefixlen 64  scopeid 0x20</span><br><span class="line">ether 00:0c:29:17:f0:b2  txqueuelen 1000  (Ethernet)</span><br><span class="line">RX packets 1  bytes 243 (243.0 B)</span><br><span class="line">RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">TX packets 14  bytes 1008 (1008.0 B)</span><br><span class="line">TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line">lo: flags=73  mtu 65536</span><br><span class="line">inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">inet6 ::1  prefixlen 128  scopeid 0x10</span><br><span class="line">loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line">veth1f3cf35: flags=4163  mtu 1500</span><br><span class="line">inet6 fe80::483c:5fff:fe03:30fa  prefixlen 64  scopeid 0x20</span><br><span class="line">ether 4a:3c:5f:03:30:fa  txqueuelen 0  (Ethernet)</span><br><span class="line">RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">TX packets 16  bytes 1296 (1.2 KiB)</span><br><span class="line">TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><p><strong>2）显示指定网卡信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示网卡eth2的信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ifconfig eth2</span></span><br><span class="line">eth2: flags=4163  mtu 1500</span><br><span class="line">inet 10.0.5.81  netmask 255.255.255.0  broadcast 10.0.5.255</span><br><span class="line">inet6 fe80::20c:29ff:fe17:f0b2  prefixlen 64  scopeid 0x20</span><br><span class="line">ether 00:0c:29:17:f0:b2  txqueuelen 1000  (Ethernet)</span><br><span class="line">RX packets 2  bytes 501 (501.0 B)</span><br><span class="line">RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">TX packets 14  bytes 1008 (1008.0 B)</span><br><span class="line">TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><p><strong>3）启动/关闭指定网卡</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭eth2网卡</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ifconfig eth2 down</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-a选项查询关闭状态下的网卡信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 网卡flags没有UP项，表示网卡关闭</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ifconfig -a eth2</span></span><br><span class="line">eth2: flags=4098  mtu 1500</span><br><span class="line">        inet 10.0.5.81  netmask 255.255.255.0  broadcast 10.0.5.255</span><br><span class="line">        ether 00:0c:29:17:f0:b2  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 12  bytes 1572 (1.5 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 14  bytes 1008 (1008.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次启动网卡eth2</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ifconfig eth2 up</span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ifconfig -a eth2</span></span><br><span class="line">eth2: flags=4163  mtu 1500</span><br><span class="line">        inet 10.0.5.81  netmask 255.255.255.0  broadcast 10.0.5.255</span><br><span class="line">        inet6 fe80::20c:29ff:fe17:f0b2  prefixlen 64  scopeid 0x20</span><br><span class="line">        ether 00:0c:29:17:f0:b2  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 12  bytes 1572 (1.5 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 21  bytes 1586 (1.5 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><p><strong>4）配置网卡ip地址</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询网卡eth2的ip地址信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示eth2网卡的ip为10.0.5.81</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ifconfig eth2</span></span><br><span class="line">eth2: flags=4163  mtu 1500</span><br><span class="line">        inet 10.0.5.81  netmask 255.255.255.0  broadcast 10.0.5.255</span><br><span class="line">        inet6 fe80::20c:29ff:fe17:f0b2  prefixlen 64  scopeid 0x20</span><br><span class="line">        ether 00:0c:29:17:f0:b2  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 13  bytes 1830 (1.7 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 22  bytes 1656 (1.6 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改eth2网卡的ip地址为10.0.5.181</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ifconfig eth2 10.0.5.181</span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ifconfig eth2</span></span><br><span class="line">eth2: flags=4163  mtu 1500</span><br><span class="line">        inet 10.0.5.181  netmask 255.0.0.0  broadcast 10.255.255.255</span><br><span class="line">        inet6 fe80::20c:29ff:fe17:f0b2  prefixlen 64  scopeid 0x20</span><br><span class="line">        ether 00:0c:29:17:f0:b2  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 13  bytes 1830 (1.7 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 22  bytes 1656 (1.6 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><p><strong>在实际运维中，除非测试环境，否则不建议这样修改网卡ip地址，因为会引起生产环境网络连接异常。如果要增加对应ip，可以给对应网卡增加子接口的方式实现，见下面示例。</strong></p><p><strong>5）添加网卡子接口，并配置ip地址</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 网卡子接口的格式eth2:0、eth2:1.。。。</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ifconfig eth2:0 192.168.101.181/24 up</span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ifconfig eth2:0</span></span><br><span class="line">eth2:0: flags=4163  mtu 1500</span><br><span class="line">inet 192.168.101.181  netmask 255.255.255.0  broadcast 192.168.101.255</span><br><span class="line">ether 00:0c:29:17:f0:b2  txqueuelen 1000  (Ethernet)</span><br></pre></td></tr></table></figure><p><strong>6）修改网卡MAC地址</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询eth2的MAC地址为ether 00:0c:29:17:f0:b2</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ifconfig eth2</span></span><br><span class="line">eth2: flags=4163  mtu 1500</span><br><span class="line">        inet 10.0.5.181  netmask 255.0.0.0  broadcast 10.255.255.255</span><br><span class="line">        inet6 fe80::20c:29ff:fe17:f0b2  prefixlen 64  scopeid 0x20</span><br><span class="line">        ether 00:0c:29:17:f0:b2  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 22  bytes 4077 (3.9 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 22  bytes 1656 (1.6 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用hw选项和网卡类型关键ether修改MAC地址</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ifconfig eth2 hw ether 00:AA:BB:CC:DD:EE</span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ifconfig eth2</span></span><br><span class="line">eth2: flags=4163  mtu 1500</span><br><span class="line">        inet 10.0.5.181  netmask 255.0.0.0  broadcast 10.255.255.255</span><br><span class="line">        inet6 fe80::20c:29ff:fe17:f0b2  prefixlen 64  scopeid 0x20</span><br><span class="line">        ether 00:aa:bb:cc:dd:ee  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 23  bytes 4320 (4.2 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 22  bytes 1656 (1.6 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><p><strong>总结：上述修改在服务器重启后就失效了，要想永久生效，只能修改网卡的配置文件。CentOS系统的网卡配置文件在/etc/sysconfig/network-scripts/下，Ubuntu系统在/etc/network/interfaces中。</strong></p><h2 id="ifup：激活网络接口"><a href="#ifup：激活网络接口" class="headerlink" title="ifup：激活网络接口"></a>ifup：激活网络接口</h2><p>ifup命令用于激活指定的网络接口。ifup命令其实是一个Shell脚本，有Shell基础的读者可以使用which命令来找到这个脚本并读一读。ifup命令可读取配置文件/etc/sysconfig/network和/etc/sysconfig/network-scripts/ifcfg-<configuration>对网络接口进行相应的操作。</configuration></p><p><strong>语法格式：ifup [iface]</strong></p><p><strong>【使用示例】</strong></p><p><strong>激活网络接口</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用ifconfig down关闭网络接口eth2，再使用ifup激活</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ifconfig eth2 down</span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ifconfig eth2</span></span><br><span class="line">eth2: flags=4098  mtu 1500</span><br><span class="line">        inet 10.0.5.181  netmask 255.0.0.0  broadcast 10.255.255.255</span><br><span class="line">        ether 00:aa:bb:cc:dd:ee  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 23  bytes 4320 (4.2 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 22  bytes 1656 (1.6 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ifup eth2</span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ifconfig eth2</span></span><br><span class="line">eth2: flags=4163  mtu 1500</span><br><span class="line">        inet 10.0.5.181  netmask 255.0.0.0  broadcast 10.255.255.255</span><br><span class="line">        inet6 fe80::2aa:bbff:fecc:ddee  prefixlen 64  scopeid 0x20</span><br><span class="line">        ether 00:aa:bb:cc:dd:ee  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 23  bytes 4320 (4.2 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 35  bytes 2634 (2.5 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><p><strong>除了激活网卡用ifup外，还有个关闭网卡指令ifdown，用法和ifup类似，请大家自行练习。</strong></p><h2 id="route：显示或管理路由表"><a href="#route：显示或管理路由表" class="headerlink" title="route：显示或管理路由表"></a>route：显示或管理路由表</h2><p>route命令可以显示或管理Linux系统的路由表，route命令设置的路由主要是静态路由。Linux上配置的路由都属于静态路由。静态路由规则是系统管理员使用route命令加入的，也就是通过手动输入的方式来加入的路由规则。动态路由无需手动配置，其路由规则是本机与不同的机器彼此经过路由程序（Routing daemon）相互交换路由规则而来的。</p><p><strong>语法格式：route [option]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/05/25/5ce94a18a931965974.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）查看当前系统的路由表信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接使用route命令就可以查看当前系统的路由表信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># route</span></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">default         gateway         0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">10.0.0.0        0.0.0.0         255.0.0.0       U     0      0        0 eth2</span><br><span class="line">10.0.5.0        0.0.0.0         255.255.255.0   U     0      0        0 eth2</span><br><span class="line">link-local      0.0.0.0         255.255.0.0     U     1002   0        0 eth0</span><br><span class="line">link-local      0.0.0.0         255.255.0.0     U     1003   0        0 eth1</span><br><span class="line">link-local      0.0.0.0         255.255.0.0     U     1004   0        0 eth2</span><br><span class="line">172.0.2.0       0.0.0.0         255.255.255.0   U     0      0        0 eth1</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</span><br><span class="line">192.168.101.0   0.0.0.0         255.255.255.0   U     0      0        0 eth0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-ee选项可以查看更详细的路由表信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># route -ee</span></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface    MSS   Window irtt</span><br><span class="line">default         gateway         0.0.0.0         UG    0      0        0 eth0     0     0      0</span><br><span class="line">10.0.0.0        0.0.0.0         255.0.0.0       U     0      0        0 eth2     0     0      0</span><br><span class="line">10.0.5.0        0.0.0.0         255.255.255.0   U     0      0        0 eth2     0     0      0</span><br><span class="line">link-local      0.0.0.0         255.255.0.0     U     1002   0        0 eth0     0     0      0</span><br><span class="line">link-local      0.0.0.0         255.255.0.0     U     1003   0        0 eth1     0     0      0</span><br><span class="line">link-local      0.0.0.0         255.255.0.0     U     1004   0        0 eth2     0     0      0</span><br><span class="line">172.0.2.0       0.0.0.0         255.255.255.0   U     0      0        0 eth1     0     0      0</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker   0     0      0</span><br><span class="line">192.168.101.0   0.0.0.0         255.255.255.0   U     0      0        0 eth0     0     0      0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-n选项可以不进行DNS解析，这样会加快显示</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># route -n</span></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         192.168.101.2   0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">10.0.0.0        0.0.0.0         255.0.0.0       U     0      0        0 eth2</span><br><span class="line">10.0.5.0        0.0.0.0         255.255.255.0   U     0      0        0 eth2</span><br><span class="line">169.254.0.0     0.0.0.0         255.255.0.0     U     1002   0        0 eth0</span><br><span class="line">169.254.0.0     0.0.0.0         255.255.0.0     U     1003   0        0 eth1</span><br><span class="line">169.254.0.0     0.0.0.0         255.255.0.0     U     1004   0        0 eth2</span><br><span class="line">172.0.2.0       0.0.0.0         255.255.255.0   U     0      0        0 eth1</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</span><br><span class="line">192.168.101.0   0.0.0.0         255.255.255.0   U     0      0        0 eth0</span><br></pre></td></tr></table></figure><blockquote><p><strong>命令结果说明如下：</strong></p><p>Destination：表示网络号，也就是network的意思。</p><p>Gateway：连出网关地址，也就是说该网络是通过该IP连接出去的，如果显示0.0.0.0，则表示该路由是直接由本机传送出去的。如果有IP显示，则表示本条路由必须经过该IP的转接才能连接出去。</p><p>Genmask：表示子网掩码地址，也就是netmask。Destination和Genmask将组合成一个完整的网络地址段。</p><p>Flags：路由标记信息，通常会有下面几种不同的标记：</p><p>​    U（route is up）：表示此路由当前为启动状态。</p><p>​    H（target is a host）：目标路由是一个主机（IP）而非网络。</p><p>​    R（reinstate route for dynamic routing）：使用动态路由时，恢复路由信息标识。</p><p>​    G（use gateway）：表示需要通过外部的主机（gateway）来转接传递数据。</p><p>​    M（modified from routing daemon or redirect）：表示路由已经被修改了。</p><p>​    D（dynamically installed by daemon or redirect）：已经由服务设定为动态路由。</p><p>​    ！（reject route）：这个路由将不会被接受（用来抵挡不安全的网络）。</p><p>Metric：需要经过几个网络节点（hops）才能到达路由的目标网络地址。</p><p>Ref：学习到此路由规则的数目。</p><p>Use：有几个转发数据包学习到了此路由规则。</p><p>Iface：路由对应的网络设备接口。</p></blockquote><p><strong>命令输出结果的第一行是系统的默认网关信息，表示去任何地方（0.0.0.0）都发给192.168.101.2，因为是默认网关，所以放在了第一条，如果不符合任何一条规则就交给默认网关来处理。</strong></p><p><strong>2）删除和添加默认网关</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示路由信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># route -n</span></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         192.168.101.2   0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">10.0.0.0        0.0.0.0         255.0.0.0       U     0      0        0 eth2</span><br><span class="line">10.0.5.0        0.0.0.0         255.255.255.0   U     0      0        0 eth2</span><br><span class="line">169.254.0.0     0.0.0.0         255.255.0.0     U     1002   0        0 eth0</span><br><span class="line">169.254.0.0     0.0.0.0         255.255.0.0     U     1003   0        0 eth1</span><br><span class="line">169.254.0.0     0.0.0.0         255.255.0.0     U     1004   0        0 eth2</span><br><span class="line">172.0.2.0       0.0.0.0         255.255.255.0   U     0      0        0 eth1</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</span><br><span class="line">192.168.101.0   0.0.0.0         255.255.255.0   U     0      0        0 eth0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一种方式删除默认网关</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># route del default</span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># route -n</span></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">10.0.0.0        0.0.0.0         255.0.0.0       U     0      0        0 eth2</span><br><span class="line">10.0.5.0        0.0.0.0         255.255.255.0   U     0      0        0 eth2</span><br><span class="line">169.254.0.0     0.0.0.0         255.255.0.0     U     1002   0        0 eth0</span><br><span class="line">169.254.0.0     0.0.0.0         255.255.0.0     U     1003   0        0 eth1</span><br><span class="line">169.254.0.0     0.0.0.0         255.255.0.0     U     1004   0        0 eth2</span><br><span class="line">172.0.2.0       0.0.0.0         255.255.255.0   U     0      0        0 eth1</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</span><br><span class="line">192.168.101.0   0.0.0.0         255.255.255.0   U     0      0        0 eth0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一种方式添加默认网关</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># route add default gw 192.168.101.2</span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># route -n</span></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         192.168.101.2   0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">10.0.0.0        0.0.0.0         255.0.0.0       U     0      0        0 eth2</span><br><span class="line">10.0.5.0        0.0.0.0         255.255.255.0   U     0      0        0 eth2</span><br><span class="line">169.254.0.0     0.0.0.0         255.255.0.0     U     1002   0        0 eth0</span><br><span class="line">169.254.0.0     0.0.0.0         255.255.0.0     U     1003   0        0 eth1</span><br><span class="line">169.254.0.0     0.0.0.0         255.255.0.0     U     1004   0        0 eth2</span><br><span class="line">172.0.2.0       0.0.0.0         255.255.255.0   U     0      0        0 eth1</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</span><br><span class="line">192.168.101.0   0.0.0.0         255.255.255.0   U     0      0        0 eth0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种方式删除默认网关</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># route del default gw 192.168.101.2</span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># route -n</span></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">10.0.0.0        0.0.0.0         255.0.0.0       U     0      0        0 eth2</span><br><span class="line">10.0.5.0        0.0.0.0         255.255.255.0   U     0      0        0 eth2</span><br><span class="line">169.254.0.0     0.0.0.0         255.255.0.0     U     1002   0        0 eth0</span><br><span class="line">169.254.0.0     0.0.0.0         255.255.0.0     U     1003   0        0 eth1</span><br><span class="line">169.254.0.0     0.0.0.0         255.255.0.0     U     1004   0        0 eth2</span><br><span class="line">172.0.2.0       0.0.0.0         255.255.255.0   U     0      0        0 eth1</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</span><br><span class="line">192.168.101.0   0.0.0.0         255.255.255.0   U     0      0        0 eth0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种方式添加默认网关</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># route add default gw 192.168.101.2 dev eth0</span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># route -n</span></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         192.168.101.2   0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">10.0.0.0        0.0.0.0         255.0.0.0       U     0      0        0 eth2</span><br><span class="line">10.0.5.0        0.0.0.0         255.255.255.0   U     0      0        0 eth2</span><br><span class="line">169.254.0.0     0.0.0.0         255.255.0.0     U     1002   0        0 eth0</span><br><span class="line">169.254.0.0     0.0.0.0         255.255.0.0     U     1003   0        0 eth1</span><br><span class="line">169.254.0.0     0.0.0.0         255.255.0.0     U     1004   0        0 eth2</span><br><span class="line">172.0.2.0       0.0.0.0         255.255.255.0   U     0      0        0 eth1</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</span><br><span class="line">192.168.101.0   0.0.0.0         255.255.255.0   U     0      0        0 eth0</span><br></pre></td></tr></table></figure><p><strong>3）配置网络路由</strong></p><p>一般多网段之间互相通信，会希望建立一条优先路由，而不是通过默认网关，这时就可以配置网络路由。还是拿房子作比喻，你现在不是要出门，而是要去卧室或卫生间，去卧室就要经过卧室的门，去卫生间就要经过卫生间的门，这里的卧室和卫生间的门就可以认为是去往某一网段的路由，而不是默认路由（即房子的大门）。在实际工作中也会有类似的需求，即两个不同的内部网络之间互相访问，而不是出网访问。</p><p>由于我们是VMware虚拟机实验环境，因此，我们主要验证虚拟机主机之间互通。主机的网段是192.168.100.0/24，虚拟机网段是192.168.101.0/24。在虚拟机安装完成后，天生就具备和主机进行互通，这是因为VMware虚拟网卡的网关功能实现。为了验证我们的配置，首先需要删除虚拟机上的默认网关，然后添加到主机的静态路由来验证。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不删除默认网关，虚拟机可以ping主机（我的主机地址是192.168.100.199）</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ping -c 5 192.168.100.199</span></span><br><span class="line">PING 192.168.100.199 (192.168.100.199) 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.100.199: icmp_seq=1 ttl=128 time=0.277 ms</span><br><span class="line">64 bytes from 192.168.100.199: icmp_seq=2 ttl=128 time=0.566 ms</span><br><span class="line">64 bytes from 192.168.100.199: icmp_seq=3 ttl=128 time=0.497 ms</span><br><span class="line">64 bytes from 192.168.100.199: icmp_seq=4 ttl=128 time=2.19 ms</span><br><span class="line">64 bytes from 192.168.100.199: icmp_seq=5 ttl=128 time=0.524 ms</span><br><span class="line"></span><br><span class="line">--- 192.168.100.199 ping statistics ---</span><br><span class="line">5 packets transmitted, 5 received, 0% packet loss, time 4004ms</span><br><span class="line">rtt min/avg/max/mdev = 0.277/0.811/2.193/0.698 ms</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除虚拟机默认路由后再次尝试ping主机</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># route del default gw 192.168.101.2</span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ping -c 5 192.168.100.199</span></span><br><span class="line">connect: Network is unreachable</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加到主机网段的静态路由</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># route add -net 192.168.100.0/24 gw 192.168.101.2</span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ping -c 5 192.168.100.199</span></span><br><span class="line">PING 192.168.100.199 (192.168.100.199) 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.100.199: icmp_seq=1 ttl=128 time=0.736 ms</span><br><span class="line">64 bytes from 192.168.100.199: icmp_seq=2 ttl=128 time=0.466 ms</span><br><span class="line">64 bytes from 192.168.100.199: icmp_seq=3 ttl=128 time=0.690 ms</span><br><span class="line">64 bytes from 192.168.100.199: icmp_seq=4 ttl=128 time=0.416 ms</span><br><span class="line">64 bytes from 192.168.100.199: icmp_seq=5 ttl=128 time=0.467 ms</span><br><span class="line"></span><br><span class="line">--- 192.168.100.199 ping statistics ---</span><br><span class="line">5 packets transmitted, 5 received, 0% packet loss, time 4002ms</span><br><span class="line">rtt min/avg/max/mdev = 0.416/0.555/0.736/0.131 ms</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询路右边，发现多了一条道192.168.100.0/24网段的静态路由，从eth0网口转发</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># route -n</span></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">10.0.5.0        0.0.0.0         255.255.255.0   U     0      0        0 eth2</span><br><span class="line">169.254.0.0     0.0.0.0         255.255.0.0     U     1002   0        0 eth0</span><br><span class="line">169.254.0.0     0.0.0.0         255.255.0.0     U     1003   0        0 eth1</span><br><span class="line">169.254.0.0     0.0.0.0         255.255.0.0     U     1004   0        0 eth2</span><br><span class="line">172.0.2.0       0.0.0.0         255.255.255.0   U     0      0        0 eth1</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</span><br><span class="line">192.168.100.0   192.168.101.2   255.255.255.0   UG    0      0        0 eth0</span><br><span class="line">192.168.101.0   0.0.0.0         255.255.255.0   U     0      0        0 eth0</span><br></pre></td></tr></table></figure><p><strong>上述的路由配置只是临时的，要想永久生效可以有多种方法，但是建议大家采用如下方式实现：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建一个路由配置文件route-eth0</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># touch /etc/sysconfig/network-scripts/route-eth0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加如下内容到配置文件中</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># echo "192.168.100.0/24 via 192.168.101.2" &gt;&gt; /etc/sysconfig/network-scripts/route-eth0</span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># cat /etc/sysconfig/network-scripts/route-eth0 </span></span><br><span class="line">192.168.100.0/24 via 192.168.101.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启网卡或重启系统后永久生效</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># systemctl restart network</span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># route -n</span></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         192.168.101.2   0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">10.0.5.0        0.0.0.0         255.255.255.0   U     0      0        0 eth2</span><br><span class="line">169.254.0.0     0.0.0.0         255.255.0.0     U     1002   0        0 eth0</span><br><span class="line">169.254.0.0     0.0.0.0         255.255.0.0     U     1003   0        0 eth1</span><br><span class="line">169.254.0.0     0.0.0.0         255.255.0.0     U     1004   0        0 eth2</span><br><span class="line">172.0.2.0       0.0.0.0         255.255.255.0   U     0      0        0 eth1</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</span><br><span class="line">192.168.100.0   192.168.101.2   255.255.255.0   UG    0      0        0 eth0</span><br><span class="line">192.168.101.0   0.0.0.0         255.255.255.0   U     0      0        0 eth0</span><br></pre></td></tr></table></figure><p><strong>4）配置/删除到主机的路由</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加到C7-Server02主机（192.168.101.82）的静态路由，由eth2网口转发</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># route add -host 192.168.101.82 dev eth2</span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># route -n|tail -1</span></span><br><span class="line">192.168.101.82  0.0.0.0         255.255.255.255 UH    0      0        0 eth2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 尝试trace，查看配置是否生效</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># traceroute -In 192.168.101.82</span></span><br><span class="line">traceroute to 192.168.101.82 (192.168.101.82), 30 hops max, 60 byte packets</span><br><span class="line"> 1  192.168.101.82  0.434 ms  0.484 ms  0.498 ms</span><br></pre></td></tr></table></figure><p><strong>在keepalived或HA高可用服务器对之间使用单独的网卡接心跳线通信时，就会用到以上的主机路由。</strong></p><h2 id="arp：管理系统的arp缓存"><a href="#arp：管理系统的arp缓存" class="headerlink" title="arp：管理系统的arp缓存"></a>arp：管理系统的arp缓存</h2><p>arp命令用于操作本机的arp缓存区，它可以显示arp缓存区中的所有条目、删除指定的条目或者添加静态的IP地址与MAC地址的对应关系。APR主要功能是根据IP地址获取物理地址（MAC地址）。</p><p><strong>语法格式：arp [option]</strong></p><p><strong>重要参数选项</strong></p><p><img src="https://i.loli.net/2019/05/25/5ce94af8b0a4187954.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）显示arp缓存区的所有条目</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ~]<span class="comment"># arp</span></span><br><span class="line">Address                  HWtype  HWaddress           Flags Mask            Iface</span><br><span class="line">192.168.101.82           ether   00:0c:29:d3:54:c1   C                     eth2</span><br><span class="line">gateway                  ether   00:50:56:f8:93:68   C                     eth0</span><br><span class="line">192.168.101.1            ether   00:50:56:c0:00:08   C                     eth0</span><br><span class="line">10.0.5.82                ether   00:0c:29:d3:54:c1   C                     eth2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-n选项，以数字ip的形式显示缓存区所有条目</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># arp -n</span></span><br><span class="line">Address                  HWtype  HWaddress           Flags Mask            Iface</span><br><span class="line">192.168.101.82           ether   00:0c:29:d3:54:c1   C                     eth2</span><br><span class="line">192.168.101.2            ether   00:50:56:f8:93:68   C                     eth0</span><br><span class="line">192.168.101.1            ether   00:50:56:c0:00:08   C                     eth0</span><br><span class="line">10.0.5.82                ether   00:0c:29:d3:54:c1   C                     eth2</span><br></pre></td></tr></table></figure><blockquote><p><strong>输出结果说明：</strong></p><p>Address：主机地址。</p><p>Hwtype：硬件类型。</p><p>Hwaddress：硬件地址。</p><p>Flags Mask：记录标志，“C”表示arp高速缓存中的条目，“M”表示静态的arp条目。</p><p>Iface：网络接口。</p></blockquote><p><strong>2）绑定静态ip地址和MAC地址</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-s选项可以绑定主机ip和固定mac地址的映射关系</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># arp -s 192.168.101.254 00:AA:BB:CC:DD:EE</span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># arp -n</span></span><br><span class="line">Address                  HWtype  HWaddress           Flags Mask            Iface</span><br><span class="line">192.168.101.82           ether   00:0c:29:d3:54:c1   C                     eth2</span><br><span class="line">192.168.101.2            ether   00:50:56:f8:93:68   C                     eth0</span><br><span class="line">192.168.101.254          ether   00:aa:bb:cc:dd:ee   CM                    eth0</span><br><span class="line">192.168.101.1            ether   00:50:56:c0:00:08   C                     eth0</span><br><span class="line">10.0.5.82                ether   00:0c:29:d3:54:c1   C                     eth2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除绑定关系可以使用选项-d</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># arp -d 192.168.101.254</span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># arp -n</span></span><br><span class="line">Address                  HWtype  HWaddress           Flags Mask            Iface</span><br><span class="line">192.168.101.82           ether   00:0c:29:d3:54:c1   C                     eth2</span><br><span class="line">192.168.101.2            ether   00:50:56:f8:93:68   C                     eth0</span><br><span class="line">192.168.101.1            ether   00:50:56:c0:00:08   C                     eth0</span><br><span class="line">10.0.5.82                ether   00:0c:29:d3:54:c1   C                     eth2</span><br></pre></td></tr></table></figure><p><strong>当局域网有arp病毒时，就可以用上述方法绑定MAC地址，以防止中毒。</strong></p><h2 id="netstat：查看网络状态"><a href="#netstat：查看网络状态" class="headerlink" title="netstat：查看网络状态"></a>netstat：查看网络状态</h2><p>netstat命令用于显示本机网络的连接状态、运行端口和路由表等信息。</p><p><strong>语法格式：netstat [option]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/05/25/5ce94b6a6ac4364705.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）常用选项组合</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -an选项组合以ip地址的形式显示所有socket的监听信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># netstat -an</span></span><br><span class="line">Active Internet connections (servers and established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State      </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN     </span><br><span class="line">tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN     </span><br><span class="line">tcp        0     52 192.168.101.81:22       192.168.101.1:6481      ESTABLISHED</span><br><span class="line">tcp6       0      0 :::4000                 :::*                    LISTEN     </span><br><span class="line">tcp6       0      0 :::80                   :::*                    LISTEN     </span><br><span class="line">tcp6       0      0 :::22                   :::*                    LISTEN     </span><br><span class="line">tcp6       0      0 ::1:25                  :::*                    LISTEN     </span><br><span class="line">udp        0      0 127.0.0.1:323           0.0.0.0:*                          </span><br><span class="line">udp6       0      0 ::1:323                 :::*                               </span><br><span class="line">Active UNIX domain sockets (servers and established)</span><br><span class="line">Proto RefCnt Flags       Type       State         I-Node   Path</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     19221    /var/run/vmware/guestServicePipe</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     27162    /var/run/docker.sock</span><br><span class="line">unix  3      [ ]         DGRAM                    31       /run/systemd/notify</span><br><span class="line">unix  2      [ ]         DGRAM                    33       /run/systemd/cgroups-agent</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     22569    /var/run/docker.sock</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     41       /run/systemd/journal/stdout</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     22571    /run/dbus/system_bus_socket</span><br><span class="line">unix  6      [ ]         DGRAM                    44       /run/systemd/journal/socket</span><br><span class="line">unix  12     [ ]         DGRAM                    46       /dev/<span class="built_in">log</span></span><br><span class="line">。。。</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-lntup选项组合，查看所有监听连接的端口和进程PID</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># netstat -lntup</span></span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1038/sshd           </span><br><span class="line">tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      1310/master         </span><br><span class="line">tcp6       0      0 :::4000                 :::*                    LISTEN      1648/docker-proxy   </span><br><span class="line">tcp6       0      0 :::80                   :::*                    LISTEN      1042/httpd          </span><br><span class="line">tcp6       0      0 :::22                   :::*                    LISTEN      1038/sshd           </span><br><span class="line">tcp6       0      0 ::1:25                  :::*                    LISTEN      1310/master         </span><br><span class="line">udp        0      0 127.0.0.1:323           0.0.0.0:*                           645/chronyd         </span><br><span class="line">udp6       0      0 ::1:323                 :::*</span><br></pre></td></tr></table></figure><blockquote><p><strong>输出结果说明如下：</strong></p><p>Active Internet connections (servers and established) ：表示活动的TCP/IP网络连接。</p><p>Active UNIX domain sockets (servers and established)：表示活动的unix socket连接。</p><p>Proto：表示socket使用的协议（TCP、UDP、RAW）</p><p>Recv-Q：接收到但还未处理的字节数。</p><p>Send-Q：已经发送，但是还未收到远程主机响应的自己数。</p><p>Local Address：本地主机地址和端口信息。</p><p>Foreign Address：远程主机的地址和端口信息。</p><p>State：socket的状态，通常仅有TCP的状态信息，状态值有ESTABBLISHED、SYN_SENT、SYN_RECV、FIN_WAIT、FIN_WAIT2、TIME_WAIT等。</p></blockquote><p><strong>2）显示当前系统的路由信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-r选项显示系统路由表信息，使用-n选项显示ip地址，不进行DNS解析</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># netstat -rn</span></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface</span><br><span class="line">0.0.0.0         192.168.101.2   0.0.0.0         UG        0 0          0 eth0</span><br><span class="line">10.0.5.0        0.0.0.0         255.255.255.0   U         0 0          0 eth2</span><br><span class="line">169.254.0.0     0.0.0.0         255.255.0.0     U         0 0          0 eth0</span><br><span class="line">169.254.0.0     0.0.0.0         255.255.0.0     U         0 0          0 eth1</span><br><span class="line">169.254.0.0     0.0.0.0         255.255.0.0     U         0 0          0 eth2</span><br><span class="line">172.0.2.0       0.0.0.0         255.255.255.0   U         0 0          0 eth1</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U         0 0          0 docker0</span><br><span class="line">192.168.100.0   192.168.101.2   255.255.255.0   UG        0 0          0 eth0</span><br><span class="line">192.168.101.0   0.0.0.0         255.255.255.0   U         0 0          0 eth0</span><br><span class="line">192.168.101.82  0.0.0.0         255.255.255.255 UH        0 0          0 eth2</span><br></pre></td></tr></table></figure><p><strong>3）显示网卡状态</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-i选项显示网络接口状态信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># netstat -i</span></span><br><span class="line">Kernel Interface table</span><br><span class="line">Iface             MTU    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg</span><br><span class="line">docker0          1500        0      0      0 0             8      0      0      0 BMRU</span><br><span class="line">eth0             1500     8480      0      0 0          4404      0      0      0 BMRU</span><br><span class="line">eth1             1500       24      0      0 0            54      0      0      0 BMRU</span><br><span class="line">eth2             1500       41      0      0 0            60      0      0      0 BMRU</span><br><span class="line">lo              65536       10      0      0 0            10      0      0      0 LRU</span><br><span class="line">vethe5480a8      1500        0      0      0 0            16      0      0      0 BMRU</span><br></pre></td></tr></table></figure><blockquote><p><strong>输出结果说明如下：</strong></p><p>Iface：表示网络设备的接口名称。</p><p>MTU：表示最大传输单元，单位为字节。</p><p>RX-OK/TX-OK：表示已经准确无误地接收/发送了多少数据包。</p><p>RX-ERR/TX-ERR：表示接收/发送数据包时产生了多少错误。</p><p>RX-DRP/TX-DRP：表示接收/发送数据包时丢弃了多少数据包。</p><p>RX-OVR/TX-OVR：表示由于误差而遗失了多少数据包。</p><p>Flg：表示接口标记，其中各标记含义具体如下。</p><p>​    L：表示该接口是个回环设备。</p><p>​    B：表示设置了广播地址。</p><p>​    M：表示接收所有数据包。</p><p>​    R：表示接口正在运行。</p><p>​    U：表示接口处于活动状态。</p><p>​    O：表示在该接口上禁用arp。</p><p>​    P：表示一个点到点的连接。</p></blockquote><p><strong>正常情况下，RX-ERR/TX-ERR、RX-DRP/TX-DRP和RX-OVR/TX-OVR的值都应该为0，如果这几个选项的值不为0，并且很大，那么网络质量肯定有问题，网络传输性能也一定会下降。</strong></p><h2 id="ping：测试主机之间网络的连通性"><a href="#ping：测试主机之间网络的连通性" class="headerlink" title="ping：测试主机之间网络的连通性"></a>ping：测试主机之间网络的连通性</h2><p>ping命令可用于测试主机之间网络的连通性。执行ping命令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而可得知该主机运作正常。但是，如果ping不通，不一定是网络问题，也可能是远端主机设置了禁ping功能，就是收到ICMP包不会回应。</p><p><strong>语法格式：ping [option] [destination]</strong></p><p><strong>重要参数选项</strong></p><p><img src="https://i.loli.net/2019/05/25/5ce94c01ae0ff71667.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）测试目标主机的网络连通性</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试openstack官网的连通性</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ping www.openstack.org</span></span><br><span class="line">PING www.openstack.org.cdn.cloudflare.net (104.20.111.33) 56(84) bytes of data.</span><br><span class="line">64 bytes from 104.20.111.33 (104.20.111.33): icmp_seq=1 ttl=128 time=41.8 ms</span><br><span class="line">64 bytes from 104.20.111.33 (104.20.111.33): icmp_seq=2 ttl=128 time=40.7 ms</span><br><span class="line">64 bytes from 104.20.111.33 (104.20.111.33): icmp_seq=3 ttl=128 time=41.0 ms</span><br><span class="line">64 bytes from 104.20.111.33 (104.20.111.33): icmp_seq=6 ttl=128 time=49.0 ms</span><br><span class="line">64 bytes from 104.20.111.33 (104.20.111.33): icmp_seq=7 ttl=128 time=40.2 ms</span><br><span class="line">64 bytes from 104.20.111.33 (104.20.111.33): icmp_seq=8 ttl=128 time=40.9 ms</span><br><span class="line">64 bytes from 104.20.111.33 (104.20.111.33): icmp_seq=9 ttl=128 time=40.9 ms</span><br><span class="line">64 bytes from 104.20.111.33 (104.20.111.33): icmp_seq=10 ttl=128 time=41.7 ms</span><br><span class="line">。。。。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时不使用ctrl+c就会一直ping下去</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-c选项，设定ping的次数</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ping -c 3 www.openstack.org</span></span><br><span class="line">PING www.openstack.org.cdn.cloudflare.net (104.20.110.33) 56(84) bytes of data.</span><br><span class="line">64 bytes from 104.20.110.33 (104.20.110.33): icmp_seq=1 ttl=128 time=63.3 ms</span><br><span class="line">64 bytes from 104.20.110.33 (104.20.110.33): icmp_seq=2 ttl=128 time=54.0 ms</span><br><span class="line">64 bytes from 104.20.110.33 (104.20.110.33): icmp_seq=3 ttl=128 time=54.0 ms</span><br><span class="line"></span><br><span class="line">--- www.openstack.org.cdn.cloudflare.net ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 5517ms</span><br><span class="line">rtt min/avg/max/mdev = 54.017/57.164/63.387/4.404 ms</span><br></pre></td></tr></table></figure><p>ping命令会显示一个时间作为衡量网络延迟的参数，以判断源主机与目标主机之间网络的质量。ping命令的输出信息中含有TTL值。TTL（Time To Life）称为生存期，它是ICMP报文在网络上的存活时间。不同的操作系统发出的ICMP报文的生存期各不相同，常见的生存期为32、64、128和255等。TTL值反映了ICMP报文所能够经过的路由器数目，每经过一个路由器，路由器都会将其数据包的生存期减去1，如果TTL值变为0，则路由器将不再转发此报文。</p><p><strong>2）用1k的大包测试</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-s选项可以这是ICMP包的大小</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ping -c 5 -s 1024 www.openstack.org</span></span><br><span class="line">PING www.openstack.org.cdn.cloudflare.net (104.20.110.33) 1024(1052) bytes of data.</span><br><span class="line">1032 bytes from 104.20.110.33 (104.20.110.33): icmp_seq=1 ttl=128 time=55.2 ms</span><br><span class="line">1032 bytes from 104.20.110.33 (104.20.110.33): icmp_seq=2 ttl=128 time=55.6 ms</span><br><span class="line">1032 bytes from 104.20.110.33 (104.20.110.33): icmp_seq=3 ttl=128 time=55.2 ms</span><br><span class="line">1032 bytes from 104.20.110.33 (104.20.110.33): icmp_seq=4 ttl=128 time=55.0 ms</span><br><span class="line">1032 bytes from 104.20.110.33 (104.20.110.33): icmp_seq=5 ttl=128 time=63.0 ms</span><br><span class="line">--- www.openstack.org.cdn.cloudflare.net ping statistics ---</span><br><span class="line">5 packets transmitted, 5 received, 0% packet loss, time 7575ms</span><br><span class="line">rtt min/avg/max/mdev = 55.084/56.875/63.085/3.122 ms</span><br></pre></td></tr></table></figure><h2 id="telnet：远程登录主机"><a href="#telnet：远程登录主机" class="headerlink" title="telnet：远程登录主机"></a>telnet：远程登录主机</h2><p>telnet命令以前是用于登录远程主机，对远程主机进行管理的。但是因为telnet是采用明文传送报文的，其安全性不好，因此现在很多Linux服务器都不开放telnet服务，而是改用更安全的SSH服务了。现在，只有在交换机等网络设备还可能呢会采用telnet登录的方式。<strong>但是，使用telnet命令还可以判断远端服务器的端口是否开放，这是目前telnet命令使用最主要场景。</strong></p><p><strong>语法格式：telnet [option] [host] [port]</strong></p><p><strong>【使用示例】</strong></p><p><strong>测试SSH服务端口是否开放</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试192.168.101.83的ssh服务是否开放</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># telnet 192.168.101.83 22  # 22端口就是ssh服务的端口</span></span><br><span class="line">Trying 192.168.101.83...</span><br><span class="line">Connected to 192.168.101.83.</span><br><span class="line">Escape character is <span class="string">'^]'</span>.</span><br><span class="line">SSH-2.0-OpenSSH_7.4   <span class="comment"># &lt;==看到这种结果，就证明SSH服务的22端口已经开放了。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时命令行已经挂起了，不能再进行其他操作，Ctrl+C也无法退出。根据提示输入“Ctrl+]”，然后进入telnet命令行，输入quit就能退出。</span></span><br><span class="line"></span><br><span class="line">SSH-2.0-OpenSSH_7.4</span><br><span class="line">^]</span><br><span class="line">telnet&gt; quit</span><br><span class="line">Connection closed.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 出现下列情况表示服务未开启或端口被屏蔽无法访问</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># telnet 192.168.101.83 23</span></span><br><span class="line">Trying 192.168.101.83...</span><br><span class="line">telnet: connect to address 192.168.101.83: Connection refused</span><br></pre></td></tr></table></figure><h2 id="wget：命令行下载工具"><a href="#wget：命令行下载工具" class="headerlink" title="wget：命令行下载工具"></a>wget：命令行下载工具</h2><p>wget命令用于从网络上下载某些资料，该命令对于能够连接到互联网的Linux系统，作用非常大，可以直接从网络上下载自己所需要的文件。wget的特点如下：</p><ol><li>支持断点下载功能。</li><li>支持FTP和HTTP下载方式。</li><li>支持代理服务器。</li><li>非常稳定，它在带宽很窄的情况下或不稳定的网络中有很强的适应性。如果是由于网络的原因下载失败，wget会不断地尝试，直到整个文件下载完毕。如果是服务器打断了下载过程，它会再次连接到服务器上从停止的地方继续下载。这对那些从限定了连接时间的服务器上下载大文件非常有用。</li></ol><p><strong>语法格式：wget [option] [url]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/05/25/5ce94c90227ad34833.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）使用wget下载单个文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从阿里云镜像服务器上下载epel源</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># wget http://mirrors.aliyun.com/repo/epel-6.repo</span></span><br><span class="line">--2019-05-04 17:46:56--  http://mirrors.aliyun.com/repo/epel-6.repo</span><br><span class="line">Resolving mirrors.aliyun.com (mirrors.aliyun.com)... 183.201.217.232, 183.201.229.102, 183.201.217.227, ...</span><br><span class="line">Connecting to mirrors.aliyun.com (mirrors.aliyun.com)|183.201.217.232|:80... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 664 [application/octet-stream]</span><br><span class="line">Saving to: ‘epel-6.repo’</span><br><span class="line">100%[======================================================&gt;] 664         --.-K/s   <span class="keyword">in</span> 0s      </span><br><span class="line">2019-05-04 17:46:58 (191 MB/s) - ‘epel-6.repo’ saved [664/664]</span><br></pre></td></tr></table></figure><p><strong>2）指定保存文件名下载</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-O选项指定本地保存文件名</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># wget -O ~/MyCentOS6-epel.repo http://mirrors.aliyun.com/repo/epel-6.repo</span></span><br><span class="line">--2019-05-04 17:48:38--  http://mirrors.aliyun.com/repo/epel-6.repo</span><br><span class="line">Resolving mirrors.aliyun.com (mirrors.aliyun.com)... 183.201.217.230, 183.201.217.233, 111.48.28.118, ...</span><br><span class="line">Connecting to mirrors.aliyun.com (mirrors.aliyun.com)|183.201.217.230|:80... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 664 [application/octet-stream]</span><br><span class="line">Saving to: ‘/root/MyCentOS6-epel.repo’</span><br><span class="line">100%[======================================================&gt;] 664         --.-K/s   <span class="keyword">in</span> 0s      </span><br><span class="line">2019-05-04 17:48:40 (123 MB/s) - ‘/root/MyCentOS6-epel.repo’ saved [664/664]</span><br></pre></td></tr></table></figure><p><strong>wget默认会以最后一个符合“/”的后面的字符来命名，对于动态链接的下载文件名通常会不正确。为了解决这个问题，我们可以使用参数-O来指定一个文件名。</strong></p><p><strong>3）限速加载</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用--limit-rate选项限定下载速度为10K</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># wget -O ~/mydata/myico.ico --limit-rate=10k https://kkutysllb.cn/favicon.ico</span></span><br><span class="line">--2019-05-04 17:52:22--  https://kkutysllb.cn/favicon.ico</span><br><span class="line">Resolving kkutysllb.cn (kkutysllb.cn)... 185.199.110.153</span><br><span class="line">Connecting to kkutysllb.cn (kkutysllb.cn)|185.199.110.153|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 97780 (95K) [image/vnd.microsoft.icon]</span><br><span class="line">Saving to: ‘/root/mydata/myico.ico’</span><br><span class="line">100%[======================================================&gt;] 97,780      10.0KB/s   <span class="keyword">in</span> 9.5s   </span><br><span class="line">2019-05-04 17:52:34 (10.0 KB/s) - ‘/root/mydata/myico.ico’ saved [97780/97780]</span><br><span class="line">[root@C7-Server01 ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p><strong>4）断点续传</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从阿里云镜像仓库下载centos6.10的iso镜像</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-c选项支持断点续传，当下载到5%时，我们手动通过ctrl+c打断</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># wget -c https://mirrors.aliyun.com/centos/6/isos/x86_64/CentOS-6.10-x86_64-bin-DVD1.iso</span></span><br><span class="line">--2019-05-04 17:58:23--  https://mirrors.aliyun.com/centos/6/isos/x86_64/CentOS-6.10-x86_64-bin-DVD1.iso</span><br><span class="line">Resolving mirrors.aliyun.com (mirrors.aliyun.com)... 183.203.69.11, 183.201.217.227, 183.203.69.12, ...</span><br><span class="line">Connecting to mirrors.aliyun.com (mirrors.aliyun.com)|183.203.69.11|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 3991928832 (3.7G) [application/octet-stream]</span><br><span class="line">Saving to: ‘CentOS-6.10-x86_64-bin-DVD1.iso’</span><br><span class="line">5% [==&gt;                                                    ] 223,244,572 11.3MB/s  eta 5m 21s ^C</span><br></pre></td></tr></table></figure><p>再次下载，发现继续从5%开始下载，再次在11%打断，再次继续上次地方下载</p><p><img src="https://i.loli.net/2019/05/25/5ce94d0d2045c41932.jpg"></p><p><strong>5）后台下载</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-b选项后台下载，同时也可组合-c选项，支持断点续传</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># wget -bc https://mirrors.aliyun.com/centos/7.6.1810/isos/x86_64/CentOS-7-x86_64-DVD-1810.iso</span></span><br><span class="line">Continuing <span class="keyword">in</span> background, pid 3333.</span><br><span class="line">Output will be written to ‘wget-log’.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看下载进度日志文件wget-log</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># tail -f wget-log</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/05/25/5ce94d3aee85858500.jpg"></p><p><strong>6）伪装下载</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用--user-agent选项伪装客户端下载</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># wget --user-agent="Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16" https://kkutysllb.cn/favicon.ico</span></span><br><span class="line">--2019-05-04 18:11:26--  https://kkutysllb.cn/favicon.ico</span><br><span class="line">Resolving kkutysllb.cn (kkutysllb.cn)... 185.199.110.153</span><br><span class="line">Connecting to kkutysllb.cn (kkutysllb.cn)|185.199.110.153|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 97780 (95K) [image/vnd.microsoft.icon]</span><br><span class="line">Saving to: ‘favicon.ico’</span><br><span class="line">100%[======================================================&gt;] 97,780      24.0KB/s   <span class="keyword">in</span> 4.0s   </span><br><span class="line">2019-05-04 18:11:33 (24.0 KB/s) - ‘favicon.ico’ saved [97780/97780]</span><br></pre></td></tr></table></figure><p><strong>有些网站会根据判断代理名称不是浏览器而拒绝你的下载请求，不过你可以通过——user-agent参数进行伪装。</strong></p><p><strong>7）监控网站URL是否正常</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-T选项设置超时时间，单位为秒</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-q关闭尝试连接的输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用--tries选项设置重试次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用--spider选项模拟爬虫方式访问网站</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后通过echo $?输出结果判断，如果结果为0就是表示URL正常，否则异常</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># wget -q -T 3 --tries=3 --spider www.sina.com.cn</span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># echo $?</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure><p><strong>上述语句常用自动化运维脚本中。</strong></p><p><strong><em>结论：截止目前Linux系统核心命令中网络管理命令基本介绍这么多，还有一些常用的命令工具，如：抓包（tcpdump），监听（nmap）、追踪（traceroute）、配置（ip、nc）、邮件（mail、mailq）等等会放在Linux常用网络工具一文中介绍。</em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ifconfig：配置或显示网络接口信息&quot;&gt;&lt;a href=&quot;#ifconfig：配置或显示网络接口信息&quot; class=&quot;headerlink&quot; title=&quot;ifconfig：配置或显示网络接口信息&quot;&gt;&lt;/a&gt;ifconfig：配置或显示网络接口信息&lt;/h2&gt;&lt;p&gt;ifconfig命令用于配置网卡IP地址等网络参数或显示当前网络的接口状态，其类似于Windows下的ipconfig命令，这两个命令很容易混淆，读者需要区分一下。此外，ifconfig命令在配置网卡信息时必须以root用户的身份来执行。使用ifconfig命令配置网卡信息仅会临时生效，重启网络或服务器配置就会失效。要想配置永久生效，正确的姿势是“编辑配置网卡配置文件”。
    
    </summary>
    
      <category term="Linux核心命令" scheme="https://kkutysllb.cn/categories/Linux%E6%A0%B8%E5%BF%83%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Linux" scheme="https://kkutysllb.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>2019-05-25-计算虚拟化之I/O虚拟化</title>
    <link href="https://kkutysllb.cn/2019/05/25/2019-05-25-%E8%AE%A1%E7%AE%97%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B9%8BI-O%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    <id>https://kkutysllb.cn/2019/05/25/2019-05-25-计算虚拟化之I-O虚拟化/</id>
    <published>2019-05-25T13:35:24.000Z</published>
    <updated>2019-05-25T13:50:12.793Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IO虚拟化概述"><a href="#IO虚拟化概述" class="headerlink" title="IO虚拟化概述"></a>IO虚拟化概述</h2><p>现实中的外设资源是有限的，为了提高资源的利用率，满足多个虚拟机操作系统对外部设备的访问需求，VMM必须通过I/O虚拟化的方式来实现资源的复用，让有限的资源能被多个虚拟机共享。如何将服务器上的物理设备虚拟化为多个逻辑设备，并将物理设备与逻辑设备解耦，使虚拟机可以在各个虚拟化平台间无缝迁移，正是I/O虚拟化的目标。I/O虚拟化的基本要求主要有以下的三点：<a id="more"></a></p><p><strong>(1) 保真性，</strong>要求在虚拟化平台下进行的I/O访问与非虚拟化条件下的I/O访问除了完成时间差别外，其它效果相同；</p><p><strong>(2) 安全性，</strong>要求各虚拟机操作系统只能访问VMM分配给其的I/O资源，而各I/O设备也只能与属于同一个虚拟机的其它资源进行交互，如存储空间和CPU，而不能越界访问属于其它虚拟机的资源；</p><p><strong>(3) 性能，</strong>要求虚拟化系统下I/O访问的性能与非虚拟化系统下的I/O访问性能接近。</p><p>在这三个基本要求之中最为重要的就是<strong>安全性方面的要求，这是保证虚拟化环境可以正常运行的根本</strong>，只有首先满足这一要求才能保证虚拟化I/O的保真性，对于性能的要求才会有意义。虚拟化环境下之所以会出现安全性的问题是因为虚拟机操作系统可见的地址并不是实际的机器物理地址，而是客户物理地址，设备若无法获知客户物理地址和机器物理地址间的转换关系，直接使用客户物理地址进行内存访问，这会导致非法地址访问、破坏正常数据。</p><p>正是由于I/O虚拟化对于I/O空间安全隔离性方面的要求，所以对于虚拟机操作系统的I/O访问操作一般都需要VMM的介入，而不允许虚拟机操作系统与I/O设备直接进行交互，导致虚拟机操作系统的I/O访问会受到VMM干预，导致性能与非虚拟化环境有较大差距。而VMM介入之所以会导致性能严重损失的根本原因就是发生了上下文切换。</p><p>上下文切换分为两种<strong>，虚拟机与虚拟机之间发生的上下文切换</strong>以及<strong>虚拟机与VMM之间发生的上下文切换</strong>。在I/O虚拟化中影响性能的就是虚拟机和VMM之间的上下文切换。虚拟机操作系统产生的I/O请求会被VMM截获，VMM将I/O请求交由驱动域去处理，驱动域完成I/O请求要返回执行结果，这些过程都会造成上下文切换。虚拟机和VMM之间的上下文切换的开销主要分为以下三个部分：</p><p><strong>（1）直接开销，</strong>这个部分主要由CPU的切换造成，CPU需要停滞虚拟机切换到VMM去执行，之后又要从VMM转回虚拟机执行下一条指令。</p><p><strong>（2）间接开销，两种环境的切换导致需要保存上下文环境。</strong></p><p><strong>（3）同步开销，</strong>这个部分主要是VMM处理VM EXIT造成的。</p><p>因此，一旦发生大量的上下文切换，将严重影响I/O虚拟化的性能，尤其在I/O密集型的任务中，上下文切换导致的开销往往是无法忍受的。为了解决性能的问题，通过DMA重映射、IOMMU等硬件辅助，实现了域间隔离和设备地址转换，保证被分配给虚拟机的设备不会访问不属于该虚拟机的存储器空间。</p><p><strong>I/O虚拟化在具体实现上与CPU和内存虚拟化一样，分为软件与硬件虚拟化；在被虚拟机访问的方式上，又分为共享模式与直接访问模式。</strong></p><h2 id="软件I-O虚拟化技术"><a href="#软件I-O虚拟化技术" class="headerlink" title="软件I/O虚拟化技术"></a>软件I/O虚拟化技术</h2><p>软件I/O虚拟化通过软件模拟设备的方式，使得I/O设备资源能够被多个虚拟机共享，该方式可使I/O设备的利用率得到极大的提高，并且可以做到物理设备与逻辑设备分离，具有良好的通用性，但由于该方式需要VMM的介入而导致多次上下文切换，使得I/O性能受到影响。 其本质是VMM需要截获虚拟机操作系统对外部设备的访问请求，通过软件的方式模拟出真实的物理设备的效果，这样，虚拟机看到的实际只是一个虚拟设备，而不是真正的物理设备，这种模拟的方式就是I/O虚拟化的一种实现，下图所示就是一个典型的虚拟机I/O模型。</p><p><img src="https://i.loli.net/2019/05/25/5ce945341886148676.jpg"></p><p>为了达到虚拟化I/O的目的，VMM截获客户操作系统对设备的访问请求，然后通过软件的方式来模拟真实设备的效果。I/O虚拟化中的设备对软件来说，就是一堆的寄存器（I/O端口）和I/O内存，以及中断和DMA。而设备虚拟化的过程，就是模拟设备的这些寄存器和内存，然后截获Guest OS里面对I/O端口和寄存器的访问，然后通过软件的方式来模拟真实的硬件。软件I/O虚拟化需要解决3个问题：</p><p><strong>1）设备发现:</strong> 需要控制各虚拟机能够访问的设备。</p><p>所谓设备发现就是VMM必须采取某种方式，使得虚拟机能够发现虚拟设备。这样，虚拟机才能够加载相应的驱动程序。</p><p>在没有虚拟化的系统中，由BIOS或者操作系统通过遍历PCI总线上的所有设备完成设备发现过程，而<strong>在虚拟化系统中，则由VMM决定向虚拟机呈现哪些设备</strong>。具体过程要根据设备是否存在于物理总线上来进行。对于一个真实存在于物理总线的设备，如果是不可枚举的类型，例如PS/2键盘，由于这类设备是硬编码固定的，驱动程序会通过其特定的访问方式来检查设备是否存在，因此VMM只要在相应端口上模拟出该设备，虚拟机即可成功检测到它；如果是可枚举的类型，譬如PCI设备或者PCIe设备，这种设备通常定义了完整的设备发现方法，并允许BIOS或者操作系统在设备枚举过程中通过PCI配置空间对其资源进行配置。因此VMM不仅要模拟这些设备本身的逻辑，还要模拟PCI总线的一些属性，包括总线拓扑关系及相应设备的PCI配置空间，以便虚拟机OS在启动时能够发现这些设备。</p><p>VMM不仅可以模拟真实设备，还可以实际并不存在的虚拟设备。由于这类设备并没有现实中的规范和模型与之相对应，因此完全由VMM决定它们的总线类型。这类虚拟设备可以挂载在已有PCI总线上，也可以完全自定义一套新的总线。若使用自定义的新总线，则必须在虚拟机中加载特殊的总线驱动程序，且影响虚拟机在不同虚拟化平台的迁移性。</p><p><strong>2）访问截获:</strong> 通过I/O端口对设备的访问。</p><p>所谓访问截获就是虚拟机操作系统发现虚拟设备之后，虚拟机上的驱动程序就会按照特定接口访问这个虚拟设备。驱动程序对于接口的调用必须能够被VMM截获，并能按照真实设备的行为进行模拟。</p><p>以分配到端口I/O资源的设备为例，由于<strong>CPU对于端口I/O资源的控制与指令流所处的特权级别和相关 I/O位图有关</strong>，而在虚拟化环境中虚拟机OS又被降级到非特权级别，因此OS能否访问设备的I/O端口就完全由I/O位图决定。对于没有直接分配给虚拟机的设备，VMM就可以把它的I/O端口在I/O位图中关闭，当 虚拟机操作系统在访问该端口时，就会抛出一个保护异常，VMM即可获得异常原因，并进而将请求发送给底层设备模拟器进行模拟，并异常访问处理结果返回给虚拟机；如果该设备是直接分配给虚拟机，那么VMM就可以在I/O位图中打开它的I/O端口，这样虚拟机驱动程序就可以直接访问该设备。</p><p>同理，对于分配到MMIO（Memory Mapped I/ O）资源的设备，比如某些PCIe设备，由于MMIO是系统物理地址空间的一部分，物理地址空间由页表管理，因此VMM同样可以通过控制MMIO相应的页表项是否有效来截获虚拟机操作系统对于MMIO资源的访问。</p><p><strong>3）设备模拟：</strong>通过软件的方式模拟真实的物理设备。</p><p>所谓设备模拟就是模拟设备的功能，内容十分多样且复杂。对于像PS/2键盘、鼠标这样的设备，VMM需要根据设备的接口规范模拟设备的所有行为，才能够无需修改驱动就在虚拟机上展现出设备应有的效果。而<strong>对于磁盘存储系统，则不必受限于实际的磁盘控制器以及具体磁盘类型和型号</strong>。比如，对IDE硬盘其I/O端口虚拟化时，底层可以是一块磁盘，可以是一个分区，也可以是不同格式的文件；然后在其上实现一个专门的块设备抽象层；最后在块设备上使用文件系统，并引入一些真实硬件没有的高级特性，例如：加密、备份、增量存储等。</p><p>上述三个环节仅是VMM处理一个虚拟 机所发出I/O请求的流程。在实际中，系统的物理设备需要同时接受来自多个虚拟 机的I/O请求。因此，VMM还要将多个虚拟机的I/O请求合并为单独一个I/O数据流发送给底层设备驱动。当VMM收到来自底层设备驱动完成I/O请求的中断时，VMM还要能够将中断响应结果转发给正确的虚拟机，以通知其I/O操作结束。同时VMM在调度各个虚拟机发送来的I/O请求处理时，必须依据一定的算法确保虚拟机I/O的QoS与设备共享的公平性。</p><p><strong>在实现架构上，软件I/O虚拟化技术主要包括Hypervisor全虚架构和前端/后端的半虚架构来说实现。</strong></p><p><strong>1）全虚拟化—模拟模型**</strong>，即完全使用软件来模拟真实硬件，模拟通常硬件，例如键盘鼠标。**</p><p>该架构使用最为广泛的I/O设备虚拟化模型，采用软件的方式模拟设备行为，为虚拟机模拟出与底层硬件完全一致的虚拟化环境，保证虚拟机操作系统的行为与非虚拟化环境下完全一致。在模拟模型中，虚拟设备必须以某种方式让虚拟机可以发现，导致虚拟机被“<strong>欺骗</strong>”。当虚拟机访问虚拟设备时，访问请求被VMM截获，然后VMM将I/O请求交由domain0来模拟完成，最后将结果返回给虚拟机。如下图所示是一个基于设备模拟的xen的I/O虚拟化模型。</p><p><img src="https://i.loli.net/2019/05/25/5ce945600a26c48392.jpg"></p><p><strong>这种架构最大的优点在于不需要对虚拟机操作系统内核做修改，也不需要为改写其原生驱动程序，因此，这种架构是可移植性与兼容性最佳的一种I/O设备虚拟模型</strong>，这也是它被如此广泛使用的主要原因，除了Xen架构的全虚模型外，VMware的Workstations和ESX都有类似的全虚模型，且是全虚模型的典型代表。</p><p>但是，全虚模型有一个<strong>很大的不足之处，即性能不够高</strong>，主要原因有两方面：第一、模拟方式是用软件行为进行模拟，这种方式本身就无法得到很高的性能；第二、这种模型下I/O请求的完成需要虚拟机与VMM多次的交互，产生大量的上下文切换，造成巨大开销。模拟IO虚拟化方式的<strong>最大开销在于处理器模式的切换：包括从Guest OS到VMM的切换，以及从内核态的VMM到用户态的IO模拟进程之间的切换。</strong></p><p>在全虚拟化，由于VMM实现模式不同，采用的设备虚拟化方式也不同。比如，全虚拟化最有代表性的VMware ESX和VMWare Workstattion。</p><blockquote><p>在VMware ESX中，VMM直接运行在物理硬件之上，直接操作硬件设备，而Guest OS看到的则是一组统一的虚拟IO设备。Guest  OS对这些虚拟设备的每一个IO操作都会陷入VMM 中，由VMM对IO指令进行解析并映射到实际的物理设备，然后直接控制硬件完成。</p><p>而VMWare WorkStation采用了不同的方式。ＶＭＭ实际上运行在一个传统的操作系统之上，这类VMM无法获得对硬件资源的完全控制，因此采用软件模拟的方式来模拟IO设备。Guest OS的IO操作会被VMM捕获，并转发给宿主机（host OS）的一个用户态进程，该进程通过对宿主机操作系统的系统调用来模拟设备的行为。</p></blockquote><p>以下是VMware的ESX架构，<strong>VMkernel负责管理虚拟机对于网络和存储设备的访问。</strong>通过设备模拟术，不同的物理设备对于虚拟机可以呈现为某种特定的虚拟设备，甚至并不存在的虚拟设备。</p><p><img src="https://i.loli.net/2019/05/25/5ce9459328c1395295.jpg"></p><p>对于存储，物理服务器上部署的可能是某种SCSI设备、磁盘阵列甚至是SAN存储网络，但是ESX能够模拟出BusLogic或者LSILogic的SCSI适配器，因此对于虚拟机总是呈现为SCSI设备。而对于网络ESX则模拟为AMD Lance适配器或者一个并不存在的自定义接口vmxnet，来帮助虚拟机对网络的问。上图显示了在ESXi服务器内部经过的I/O路径。其中，虚拟机分别使用vmxnet虚拟网络适配器与LSI Logic虚拟SCSI适配器对网络和存储进行访问，而物理服务器则使用Intel e1000网卡连接到SAN网络的QLogic光纤HBA卡。</p><ul><li>第1步所示，虚拟机中的某个应用程序通过操作系统发起I/O访问，比如发送一个网络数据包或者向磁盘写入一个文件；</li><li>第2步表示操作系统对其进行处理，并调用设备驱动处理相应的I/O请求；</li><li>第3步表示当设驱动试图访问外设时，VMM拦截到该操作并将控制权切换到Vmkernel；</li><li>第4步为VMkernel获得控制权后，I/O请求会被转发到与设备无关的网络或者存储抽象层进行处理；</li><li>第5步表示VMkernel还会同时接收到来自其他虚拟机的多个I/O请求，并对这些I/O请求按照特定算法进行优先级调度处理。</li></ul><p>I/O请求最终会被转发到具有物理设备驱动程序的硬件接口层进行处理。当I/O请求的完成中断到达时，I/O处理过程则与上述路径完全相反。VMkernel中设备驱动会将到达的中断保护起来，并调用VMkernel来处理该中断；接下来VMkernel会通知相应虚拟机的VMM进程，VMM进程会向虚拟机发起中断，以通知I/O请求处理完毕；同时VMkernel还要确保I/O处理完毕的相关信息与其他虚拟机的数据相互隔离。</p><p>由于上述过程需要VMkernel处理I/O请求，因此从虚拟机到VMkernel上下文的切换过程会导致一定的开销。为了降低开销，vmxnet在收发数据包之前，会收集一组数据包再转发给各个虚拟机或者一起发送出去。对于多个虚拟机之间的设备资源管理方面，对于网络ESX采用了<strong>流量整形</strong>的方式限制每个虚拟机的总带外流量；对于存储ESX实现了<strong>比例公平的算法</strong>平衡多个虚拟机之间磁盘访问带宽。</p><p><strong>2）半虚拟化—泛虚拟化模型**</strong>，即属于前后端驱动模型的IO虚拟化，也称为分离驱动模型。**</p><p>泛虚拟化模型是被广泛使用的另一种I/O设备虚拟化模型。相比于全虚模型而言，泛虚拟化模型在性能上有很大的提升。主要有以下两个原因：<strong>一是该模型采用了I/O环机制（一种大块多队列聚合传输技术，支持I/O环适配功能的虚拟机操作系统，只有安装了Tools才能使用到IO环适配功能），减少了虚拟机与VMM之间的切换；二是该模型摒弃了传统的中断机制，而采用事件或回调机制来实现设备与客户机间的通信</strong>。进行中断处理时，传统的中断服务程序需要进行中断确认和上下文切换，而采用事件或回调机制，无需进行上下文切换。如下图所示是一个基于泛虚拟化的Xen的I/O虚拟化模型。</p><p><img src="https://i.loli.net/2019/05/25/5ce945be9222f40793.jpg"></p><p>前端/后端架构也称为“Split I/O”，即将传统的I/O驱动模型分为两个部分，一部分是位于客户机OS内部的设备驱动程序（前端），该驱动程序不会直接访问设备，所有的I/O设备请求会转发给位于一个特权虚机的驱动程序（后端），后端驱动可以直接调用物理I/O设备驱动访问硬件。前端驱动负责接收来自其他模块的I/O操作请求，并通过虚拟机之间的事件通道机制将I/O请求转发给后端驱动。后端在处理完请求后会异步地通知前端。相比于全虚模型中VMM需要截获每个I/O请求并多次上下文切换的式，这种基于请求/事务的方式能够在很大程度上减少上下文切换的频率，并降低开销。 但是这种I/O模型有一个<strong>很大的缺点，要修改操作系统内核以及驱动程序，因此会存在移植性和适用性方面的问题，导致其使用受限。**</strong>下面以Xen架构的模型为例说明：**</p><p><img src="https://i.loli.net/2019/05/25/5ce945e74afc210781.jpg"></p><p>在Xen架构的半虚拟化模型中，通过修改Guest OS的内核，将原生的设备驱动从Guest OS移出，放到一个特殊的设备虚拟机中Dom0了，其余虚拟机中的I/O请求都由设备虚拟机处理。而在Guest OS内部，为每个虚拟设备安装一个特殊的驱动程序，由该驱动程序负责I/O请求的传递，设备虚拟机经过VMM授权，解析收到的请求并映射到实际物理设备，最后交给设备的原生驱动来完成IO。实际上在这种情况下，<strong>Guest OS的驱动是消息代理的作用，把I/O事件转换为消息，发送给设备虚拟机处理。具体前后端驱动配合实现物理设备驱动功能，需要通过以下几步实现：</strong></p><p><strong>Step1：如何实现设备发现？</strong></p><p>a）所有VM的设备信息保存在Domain0的XenStore中。</p><p>b）VM中的XenBus (为Xen开发的半虚拟化驱动)通过与Domain0的XenStore通信，获取设备信息。</p><p>c）加载设备对应的前端驱动程序。</p><p><strong>Step2：如何实现设备数据截获？</strong></p><p>a）前端设备驱动将数据通过VMM提供的接口全部转发到后端驱动。</p><p>b）后端驱动VM的数据进行分时分通道进行处理。</p><p><strong>Step3：如何模拟使用IO设备</strong></p><p>Domain U中虚拟机程序使用IO设备时，通过前端驱动Front-End Driver由XenBus总线访问Domain 0中的Back-End Driver，Back-End Driver通过XenStor中记录的IO设备信息，找到真实的设备驱动Native Driver去访问真实IO设备。</p><p><strong>需要注意一点：这种前后端驱动架构的瓶颈就是Domain 0，因为Domain 0通过XenBus总线采用时分复用的策略与前端多个DomainU联动。</strong></p><h2 id="硬件I-O虚拟化技术"><a href="#硬件I-O虚拟化技术" class="headerlink" title="硬件I/O虚拟化技术"></a>硬件I/O虚拟化技术</h2><p>为了改善I/O性能，旨在简化I/O访问路径的设备直通访问方式又被提了出来。代表技术为Intel公司出 的VT-d与AMD公司的IOMMU技术。尽管这两种技术在一定程度上提高了I/O访问性能，但代价却是限制了系统的可扩展性。目前PCI-SIG提出的SR-IOV与MR-IOV是平衡I/O虚拟化通用性、访问性能与系统可扩展性的很好的解决方案。</p><p><strong>IO透传—设备直接分配模型**</strong>，即直接分配给虚拟机物理设备**</p><p>软件实现I/O虚拟化的技术中，所有的虚拟机都共享物理平台上的硬件设备。如果物理条件好，有足够的硬件，就可以考虑让每个虚拟机独占一个物理设备，这样无疑会提高系统的性能。把某一个设备直接分配给一个虚拟机，让虚拟机可以直接访问该物理设备而不需要通过VMM或被VMM截获，这就是设备直通技术。如下图所示为设备直接分配的I/O模型。</p><p><img src="https://i.loli.net/2019/05/25/5ce9461d9625e48412.jpg"></p><p>在设备直接分配模型中，虚拟机操作系统可直接拥有某一物理设备的访问控制权限，VMM不再干涉其访问操作。因此，该模型可以较大地改善虚拟化设备的性能，降低VMM程序的复杂性，易于实现，并且不需要修改操作系统，保证了高可用性。</p><p>设备直接分配模型虽然在性能上相比软件方式的两种I/O设备虚拟化模型有着很大的提升，但是该模型的使用也是有一定限制的。因为该模型将一件物理设备直接分配给了一个虚拟机，其它虚拟机是无法使用该设备的，所产生的一个问题就是如果其它虚拟机需要访问该设备则无法满足需求，解决办法就是物理资源充分满足需求或者通过硬件虚拟化技术虚拟出多个IO设备（与物理设备性能极为接近）供多个虚拟机使用（硬件必须支持）。</p><h3 id="Intel的设备硬件虚拟化技术—VT-d"><a href="#Intel的设备硬件虚拟化技术—VT-d" class="headerlink" title="Intel的设备硬件虚拟化技术—VT-d"></a>Intel的设备硬件虚拟化技术—VT-d</h3><p><strong>VT-d，即VT for Direct I/O，主要在芯片组中实现，允许虚拟机直接访问I/O设备，以减少VMM和CPU的负担</strong>，如下图画红框部分。</p><p><img src="https://i.loli.net/2019/05/25/5ce94660648d578256.jpg"></p><p>Intel公司提出的VT系列技术中VT-d其目的就是让虚拟机直接访问物理机底层I/O设备，使虚拟机能够使用自己的驱动直接操作I/O设备，而无需VMM的介入和干涉。通过引入DMA重映射，VT-d不仅可以使虚拟机直接访问设备，同时还提供了一种安全隔离机制，防止其他虚拟机或者VMM访问分配给指定虚拟机的物理内存。VT-d中DMA重映射原理如下图所示：（在北桥也就是现在CPU封装中实现）</p><p><img src="https://i.loli.net/2019/05/25/5ce94688b93c449969.jpg"></p><p>具体来说，<strong>VT-d技术在北桥引入了DMA重映射技术，并通过两种数据结构（Root Entry 和 Context Entry）维护了设备的I/O页表。设备上的DMA操作都会被DMA重映射硬件截获，并根据对应的I/O页表对DMA中的地址进行转换，同时也会对要访问的地址空间进行控制。</strong></p><p>在具体实现上，VT-d使用PCI总线中的设备描述符BDF（Bus Device Function）来标示DMA操作发起者的标示符。其次，VT-d使用两种数据结构来描述PCI总线结构，分别是<strong>根条目（Root Entry）</strong>和<strong>上下文条目（Context Entry）</strong>。如下图所示，其中根条目用于描述PCI总线。由于PCI总线个数可以达到256个，因此根条目的范围是0~255，其中每个根条目的一个指针字段都指向该总线的所有PCI设备的上下文条目表指针（Context Table Pointer，CTP）。由于一个PCI总线可以包含256个设备，因此上下文条目表的范围也是0~255 。在每个上下文条目中都包含两个重要字段：<strong>地址空间根（Address Space Root，ASR） 指向该设备的I/O页表；域标示符（Domain ID，DID）可以理解为唯一标示一个虚拟机的标示符。</strong></p><p><img src="https://i.loli.net/2019/05/25/5ce946aaf04ca75158.jpg"></p><p>基于这种方式，当某一个设备发起DMA操作及被DMA重映射硬件截获时，通过该设备的BDF中的Bus字段，可以找到其所在的根条目。根据device和function字段，可以索引到具体设备的上下文条目。这样就可根据上下文条目中的ASR字段找到该设备的I/O页表，再通过DMA重映射硬件将I/O请求的GPA转换为HPA，从而达到设备直接访问虚拟机内存的目的。</p><p>使用VT-d将设备直接分配给虚拟机的I/O访问性能十分接近无虚拟化环境下的I/O访问性能，然而VT-d事实上是一种I/O设备被虚拟机独占的方式，这种方式牺牲了虚拟化平台中的设备共享能力，设备用率大大降低，而且系统的可扩展性受到物理平台插槽个数的限制。比如，假定一个服务器配置4个CPU，每个CPU为8核，按照平均分配方式每个虚拟机一个核，则可以创建32个虚拟机，如果按照备 直接访问的方式分配网卡，则需要32个物理插槽，这是不现实的。</p><p><img src="https://i.loli.net/2019/05/25/5ce946d37b7ec39760.jpg"></p><p>VT-d还为DMA重映射提供了安全隔离的保障。上图是没有VT-d技术与有VT-d技术的虚拟化平台的对比。可以看出，图（a）部分没有VT-d虚拟化技术的平台中，物理设备的DMA操作可以访问整个系统内存。而图（b）有VT-d技术的平台中，对设备DMA操作的地址范围进行了限制，只能访问指定的地址空间。</p><p>除了DMA重映射外，VT-d还提供了中断重映射功能，有兴趣的可以参考Intel官网的VT技术手册。</p><h3 id="VMDq和VMDc技术"><a href="#VMDq和VMDc技术" class="headerlink" title="VMDq和VMDc技术"></a>VMDq和VMDc技术</h3><p>在集群和数据中心这类环境中，每台主机通常同时运行大量的虚拟机。由于主机的网络设备数目有限，多个虚拟机不得不复用同一个网络设备，从而导致性能下降。Intel VT-c 技术可针对虚拟化进一步优化网络性能。VT-c 包括如下两个关键技术：</p><p><strong>1）虚拟机设备队列（Virtual Machine Device Queues，VMDq）</strong>。收到一个数据包时，VMM必须将其分类以确定应该转发给哪个虚拟机，这占用了大量宝贵的处理器资源。如果以太网控制器支持 VMDq 技术，VMM可以为虚拟机使用不同的数据包队列，以太网控制器自动分类数据包并投放到相应的队列中，大大减轻VMM的负担，提高了I/O吞吐量，如下图所示。</p><p><img src="https://i.loli.net/2019/05/25/5ce9470a3591081240.jpg"></p><p>而Intel所使用的VMDq就是通过网卡芯片內建的 Layer 2 classifier / sorter 以加速网络数据传送,它可以先行將不同的虚拟机所需的网络数据包，直接在芯片里规划好，然后再通过 receive queue直送给虚拟机。这样就不用送过虚拟交换机转发数据包减少网络的负载与CPU的开销，有VMDq和没VMDq的对比如下：</p><p><img src="https://i.loli.net/2019/05/25/5ce9472e1ce2730190.jpg"></p><p><strong>2）虚拟机直接连接（Virtual Machine Direct Connect，VMDc）</strong>。这是Intel借鉴了SR-IOV技术的特点。与SR-IOV技术一样，支持该技术的网络设备能够对外展现出多个虚拟功能接口VF（Virtual Function）。每个功能接口相当于一个网络设备，VMM可将其直接分配给某个虚拟机，从而“避免”了网络设备的复用。例如，VMM仅用单个英特尔万兆位服务器网卡，可为10个客户机操作系统分配独立受保护的1Gb/秒的专用链路，VMM无需继续管理这些直接通信链路，进一步提升I/O性能并减少主机CPU的负载 。</p><h3 id="SR-IOV与MR-IOV：PCIe的虚拟化"><a href="#SR-IOV与MR-IOV：PCIe的虚拟化" class="headerlink" title="SR-IOV与MR-IOV：PCIe的虚拟化"></a>SR-IOV与MR-IOV：PCIe的虚拟化</h3><p>如前所述，软件设备模拟尽管实现了物理与逻辑的分离，但是性能受到影响；VT-d或者IOMMU技术则以牺牲系统扩展性为代价获得近似于直接访问设备的I/O性能，而且其中任何一种都不是基于现有的工业标准。因此，业界希望重新设计一种可以原生共享的设备。具有原生共享特性的设备可同时为多个虚拟机提供单独的内存空间、工作队列、中断与命令处理，使得设备的资源能够在多个虚拟机之间共享。同时，这些设备能够从多个源端同时接收命令，并将其合并再一起发送出去。因此，原生共享设备不需要VMM模拟设备，同时也在硬件层次上使得多个虚拟机同时访问设备，很好地兼顾了虚拟化系统的性能与可扩展性。</p><p>PCI-SIG组织提出了一个新的技术规范：SR-IOV（Single Root I/O Virtualization）。该规范定义了一个单根设备（如 一个以太网卡端口）如何呈现为多个虚拟设备。在SR-IOV中，定义了两个功能类型：一是物理功能类型PF，负责管理SR-IOV设备的特殊驱动，其主要功能是提供设备访问功能和全局共享资源配置的功能，虚拟机所有影响设备状态的操作均需通过通信机制向PF发出请求完成。二是虚拟功能类型VF是轻量级的PCIe功能，包含三个方面：向虚拟机操作系统提供的接口；数据的发送、接收功能；与PF进行通信，完成全局相关操作。由于VF的资源仅是设备资源的子集，因此VF驱动能够访问的资源有限，对其它资源的访问必须通过PF完成。</p><p><img src="https://i.loli.net/2019/05/25/5ce9476ca691932811.jpg"></p><p>上图是一个支持SR-IOV的网卡配置。其中左侧三个VM是通过VF可以直接分配到的网卡资源，而该网卡的PF所具有的完整资源仍能用于最右侧两个虚拟机对模拟设备的访问路径。一个具备SR-IOV特性的设备通过VMM配置可以在PCI配置空间中呈现为多个VF，每个VF都配置了基地址寄存器（Base Address Register，BAR）的完整配置空间。VMM通过将一个或多个VF的配置空间映射到虚拟机的PCI配置空间中实现VF的分配。结合VT-d内存映射等技术，虚拟机可以直接访问VF的内存空间，这就 能绕过VMM直接访问I/ O设备。如下图所示：</p><p><img src="https://i.loli.net/2019/05/25/5ce94791d8d3870020.jpg"></p><p>SR-IOV还实现了地址转换服务（Address Translation Service，ATS）来提供更好的性能。通过缓存TLB到本地，I/O设备可以在发起PCI事务之前直接对DMA地址进行转换，这样就避免了在IOMMU中进行地址转换时可能发生的缺页情况。通过这种方式，绑 定到VF的虚拟机可 获得与基于硬件I/O虚拟 化虚拟机接近的性能。但是与基于硬件I/O虚拟化较低的可扩展性相比，一个SR-IOV设备可以具有几百个VF，因此SR-IOV具有更好的可扩展性。</p><p>MR-IOV（Multiple Root I/O Virtualization）扩展了SR-IOV规范。MR-IOV允许PCIe设备在多个有独立PCI根的系统之间共享，这些系统通过基于PCIe转换器的拓扑结构与PCIe设备或者PCIe-PCI桥相接。MR-IOV与SR-IOV相比，每个VH（Virtual Hierarchy，一个VH就是一个虚拟独立的SR-IOV设备）拥有独立的PCI Memory，IO，配置空间。如下图是MR-IOV的作用，本来每个系统只有一个Host，两个PCIe设备，但是有了MRA Switch之后，系统里面有2个Host，4个PCIe设备。</p><p><img src="https://i.loli.net/2019/05/25/5ce947c6b699689726.jpg"></p><p>MR-IOV里有个重要概念：VH，Virtual Hirearchy：每个VH至少包含一个PCIe Switch，这个PCIe Switch是MRA Switch里面的一个虚拟组件。每个VH可以包含各种PCIe设备、MRA PCIe设备、或者PCIe-PCI桥的组合。如下图，在MRA PCIe Switch中，可以有多个根端口Root Port，RP。</p><p><img src="https://i.loli.net/2019/05/25/5ce947e96ec5549655.jpg"></p><p>这样，有了MR-IOV之后，软件系统变成了下面这种，物理机之间也能相互通信，PCIe设备被多台物理机共享。下图中的SI就是虚拟机OS、VI就是虚拟机监视器VMM。</p><p><img src="https://i.loli.net/2019/05/25/5ce9480e95a7c64528.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;IO虚拟化概述&quot;&gt;&lt;a href=&quot;#IO虚拟化概述&quot; class=&quot;headerlink&quot; title=&quot;IO虚拟化概述&quot;&gt;&lt;/a&gt;IO虚拟化概述&lt;/h2&gt;&lt;p&gt;现实中的外设资源是有限的，为了提高资源的利用率，满足多个虚拟机操作系统对外部设备的访问需求，VMM必须通过I/O虚拟化的方式来实现资源的复用，让有限的资源能被多个虚拟机共享。如何将服务器上的物理设备虚拟化为多个逻辑设备，并将物理设备与逻辑设备解耦，使虚拟机可以在各个虚拟化平台间无缝迁移，正是I/O虚拟化的目标。I/O虚拟化的基本要求主要有以下的三点：
    
    </summary>
    
      <category term="NFV关键技术" scheme="https://kkutysllb.cn/categories/NFV%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="电信云" scheme="https://kkutysllb.cn/tags/%E7%94%B5%E4%BF%A1%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>2019-05-18-计算虚拟化之内存虚拟化</title>
    <link href="https://kkutysllb.cn/2019/05/18/2019-05-18-%E8%AE%A1%E7%AE%97%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    <id>https://kkutysllb.cn/2019/05/18/2019-05-18-计算虚拟化之内存虚拟化/</id>
    <published>2019-05-18T02:45:07.000Z</published>
    <updated>2019-05-18T02:54:36.837Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存虚拟化概述"><a href="#内存虚拟化概述" class="headerlink" title="内存虚拟化概述"></a>内存虚拟化概述</h2><p><strong>所谓的内存虚拟化，即如何在多个虚拟机之间共享物理内存以及如何进行动态分配</strong>。在《x86架构基础》一文中已经介绍操作系统对物理服务器内存管理的知识，它的本质就是将物理内存地址映射到一段线性地址空间，也有叫逻辑地址空间，应用程序访问内存物理地址是通过段页查询机制完成。而这个线性地址空间或逻辑地址空间本身就是物理内存的虚拟化呈现。在虚拟化环境中，分配给虚拟机内存非常类似于操作系统中关于线性地址空间的实现。操作系统负责维护虚页号到实页号的映射，并将这一 映射信息保存到页表（Page Table）。在 x86架构的CPU中，内存管理单元MMU与TLB这两个模块就负责实现并优化虚拟内存的性能。详见《DPDK技术在电信云中最佳实践》系列文章。<a id="more"></a></p><p>一个操作系统对其物理内存存在两个主要的基本认识：<strong>物理地址从0开始</strong>和<strong>内存地址连续性</strong>（至少在一些大的粒度上连续）。</p><p><img src="https://i.loli.net/2019/05/18/5cdf720f6123725981.jpg"></p><p>如上图所示，而VMM与客户机操作系统在对物理内存的认识上存在冲突，这使得真正拥有物理内存的VMM必须对客户机操作系统所访问的内存进行一定程度的虚拟化。换句话说，就是VMM 负责将MMU进行虚拟化，为客户机操作系统提供一段连续的“物理”地址空间，而操作系统本身不会意识到这种变化，仍能够将虚拟机虚拟地址（Guest Virtual Address，GVA）映射到虚拟机物理地址（Guest Physical Address，GPA），但是需要VMM将虚拟机物理地址映射到物理机物理地址（Host Physical Address，HPA）。</p><p>所以，<strong>内存虚拟化的本质就是把物理机的真实物理内存统一管理，包装成多份虚拟的内存给若干虚拟机使用</strong>。内存虚拟化的核心，在于引入一层新的地址空间—<strong>客户机物理地址空间</strong>，客户机以为自己运行在真实的物理地址空间中，实际上它是通过VMM访问真实的物理地址的。在VMM中保存客户机地址空间和物理机地址空间之间的映射表。</p><p><strong>如下图所示：虚拟化系统中包括三层内存地址空间：虚拟机虚拟地址GVA、虚拟机物理地址GPA和物理机物理地址HPA。因此，原先由MMU完成的线性地址到物理地址的映射已经不能满足，必须由VMM接入来完成这三层地址的映射维护和转换。</strong></p><p><img src="https://i.loli.net/2019/05/18/5cdf7229c2feb27866.jpg"></p><ul><li><strong>GVA：</strong>指GuestOS提供给其应用程序使用的线性地址空间。</li><li><strong>GPA：</strong>经VMM抽象的，虚拟机看到的伪物理地址空间。</li><li><strong>HPA：</strong>真实的机器地址，即地址总线上出现的地址信号。</li></ul><p>为了实现上述映射和转换关系，主要有两种解决方案：<strong>软件解决方案—影子页表和硬件解决方案—Intel的EPT和AMD的RVI。</strong></p><h2 id="内存虚拟化软件解决方案"><a href="#内存虚拟化软件解决方案" class="headerlink" title="内存虚拟化软件解决方案"></a>内存虚拟化软件解决方案</h2><h3 id="MMU半虚拟化（MMU-Paravirtualization）这种方式主要为Xen所用"><a href="#MMU半虚拟化（MMU-Paravirtualization）这种方式主要为Xen所用" class="headerlink" title="MMU半虚拟化（MMU Paravirtualization）这种方式主要为Xen所用"></a>MMU半虚拟化（MMU Paravirtualization）这种方式主要为Xen所用</h3><p><strong>MMU半虚拟化主要原理是：</strong></p><p>1）当Guest OS创建新页表时，VMM从维护的空闲内存中为其分配页面并进行注册。后续，Guest OS对该页表的写操作都会陷入VMM进行验证和转换；VMM检查页表中的每一项，确保它们只映射到属于该虚拟机的机器页面，而且不包含对页表页面的可写映射。</p><p>2）然后，VMM会根据其维护的映射关系PA-MA，将页表项中的虚拟机逻辑地址VA替换为相应的机器地址MA。</p><p>3）最后把修改过的页表载入MMU，MMU就可以根据修改过的页表直接完成虚拟地址VA到机器地址MA的转换。</p><p><strong>这种方式的本质是将映射关系VA-MA直接写入Guest OS的页表中，以替换原来的映射VA-PA映射关系。</strong></p><h3 id="影子页表"><a href="#影子页表" class="headerlink" title="影子页表"></a>影子页表</h3><p>相比较MMU半虚，大部分虚拟化厂商在VMM中还使用了一种称为<strong>影子页表（Shadow Page Table）</strong>的技术实现上述功能。对于每个虚拟机的主页表（Primary Page Table），VMM都维持一个影子页表来记录和维护GVA与HPA的映射关系。 影子页表包括以下两种映射关系，如下图所示：</p><p><img src="https://i.loli.net/2019/05/18/5cdf728ab26fc27225.jpg"></p><p><strong>1）GVA&gt;&gt;&gt;GPA，</strong>虚拟机操作系统负责维护从虚拟机逻辑地址到虚拟机物理地址的映射关系，VMM可以从虚拟机主页表中获取这种映射关系。</p><p><strong>2）GPA&gt;&gt;&gt;HPA，</strong>VMM负责维护从虚拟机物理地址到物理机物理地址的映射关系。</p><p>通过这种两级映射的方式，VMM为Guest OS的每个页表维护一个影子页表，并将GVA-HPA的映射关系写入影子页表，Guest OS的页表内容保持不变，然后，VMM将影子页表写入MMU。同时，又对虚拟机可访问的内存边界进行了有效控制。并且，使用TLB缓存影子页表的内容可以大大提高虚拟机问内存的速度。</p><p>影子页表的维护将带来<strong>时间</strong>和<strong>空间</strong>上的较大开销。<strong>时间开销</strong>主要体现在Guest OS构造页表时不会主动通知VMM，VMM必须等到Guest OS发生缺页错误时（必须Guest OS要更新主页表），才会分析缺页原因再为其补全影子页表。而<strong>空间开销</strong>主要体现在VMM需要支持多台虚拟机同时运行，每台虚拟机的 Guest OS通常会为其上运行的每个进程创建一套页表系统，因此影子页表的空间开销会随着进程数量的增多而迅速增大。</p><p>为权衡时间开销和空间开销，现在一般采用<strong>影子页表缓存</strong>（Shadow Page Table Cache）技术，即VMM在内存中维护部分最近使用过的影子页表，只有当影子页表在缓存中找不到时，才构建一个新的影子页表。<strong>当前主要的虚拟化技术都采用了影子页表缓存技术</strong>。</p><h3 id="内存虚拟化的硬件解决方案"><a href="#内存虚拟化的硬件解决方案" class="headerlink" title="内存虚拟化的硬件解决方案"></a>内存虚拟化的硬件解决方案</h3><p>为了解决影子页表导致的上述开销问题，除了使用影子页表缓存技术外（这项技术虽然能避免时间上的一部分开销，但是空间开销还是实实在在存在的）， Intel与AMD公司都针对MMU虚拟化给出了自 的解决方案：Intel公司在Nehalem微架构CPU中推出<strong>扩展页表（Extended Page Table，EPT）</strong>技术；AMD公司在四核皓龙CPU中推出<strong>快速虚拟化索引（Rapid Virtualization Index，RVI）</strong>技术。</p><p>RVI与EPT尽管在具体实现细节上有所不同，但是在设计理念上却完全一致：<strong>通过在物理MMU中保存两个不同的页表，使得内存地址的两次映射都在硬件中完成，进而达到提高性能的目的。</strong>具体来说，MMU中管理管理了两个页表，第一个是GVA &gt;&gt;&gt;GPA，由虚拟机决定；第二个是GPA&gt;&gt;&gt;HPA，对虚拟机透明，由VMM决定。根据这两个映射页表，CPU中的page walker就可以生成最近访问过key-value键值对&lt;GVA，HPA&gt; ，并缓存在TLB中（类似影子页表缓存技术思路）。</p><p>另外，原来在影子页表中由VMM维持的GPA&gt;&gt;&gt;HPA映射关系，则由一组新的数据结构扩展页表（Extended Page Table，也称为Nested Page Table）来保存。由于GPA &gt;&gt;&gt;HPA的映射关系非常定，并在虚拟机创建或修改页表时无需更新，因此VMM在虚拟机更新页表的时候无需进行干涉。VMM也无需参与到虚拟机上下文切换，虚拟机可以自己修改GVA &gt;&gt;&gt;GPA的页表。</p><p>我们以Intel EPT技术为例说明。Intel EPT是Intel VT-x 提供的内存虚拟化支持技术，其基本原理下图所示。在原有的CR3页表地址映射的基础上，EPT引入EPT页表来实现另一次映射。比如：假设客户机页表和EPT页表都是4级页表，CPU完成一次地址转换的基本过程如下：</p><p><img src="https://i.loli.net/2019/05/18/5cdf72c9c659e24729.jpg"></p><p>CPU首先查找客户机CR3寄存器指向的L4页表。客户机CR3寄存器给出的是GPA，所以，CPU通过EPT页表将客户机CR3中的GPA转换为HPA：CPU 首先查找EPT TLB，如果没有相应的记录，就进一步查找EPT页表，如果还没有，CPU则抛出EPT Violation异常交给VMM处理。</p><p>CPU获得L4页表地址（指的是HPA）后，CPU根据GVA和L4页表项的内容来获取L3 页表项的GPA。如果L4页表中GVA对应的表项显示为“缺页”，那么CPU 产生Page Fault，直接交由客户机操作系统处理。获得L3 页表项的GPA后，CPU通过查询EPT页表来将L3的GPA转换为HPA。同理，CPU 会依次完成L2、L1页表的查询，获得GVA所对应的GPA，然后进行最后一次查询EPT页表获得HPA。</p><p>正如上图所示，CPU需要5次查询EPT页表，每次查询都需要4次内存访问。这样，在最坏的情况下总共需要20次内存访问。<strong>EPT硬件通过增大EPT TLB 尽量减少内存访问。</strong></p><h2 id="内存虚拟化管理"><a href="#内存虚拟化管理" class="headerlink" title="内存虚拟化管理"></a>内存虚拟化管理</h2><p>在虚拟化环境中，内存是保证虚拟机工作性能的关键因素。如何尽可能提高虚拟机的性能、提高内存利用率、降低虚拟机上下文切换的内存开销，依然非常复杂，这就引入了<strong>内存虚拟化管理的问题</strong>。像介绍CPU虚拟化管理一样，我们还是通过实例来说明内存的虚拟化管理。以VMware的ESX解决方案为例，在没有出现硬件支持的内存虚拟化技术之前，ESX/ESXi采用影子页表来实现虚拟机的虚拟地址到物理机物理地址的快速转换。当Intel和AMD公司分别推出了EPT与RIV技术之后，ESX/ESXi很快转向硬件支持来提高内存虚拟化的性能。</p><p>在虚拟化内存管理 上，ESX/ESXi实现了主机内存超分配的目标：即<strong>多个虚拟机总的内存分配量大于物理机的实际内存容量</strong>。如下图所示，一个物理内存只有4GB的Host，可以同时运行三个内存配置为2GB的虚拟机。</p><p><img src="https://i.loli.net/2019/05/18/5cdf72f7358ee63929.jpg"></p><p>主机内存超分配功能意味着VMM必须能够有效地回收虚拟机中不断释放的内存，并在有限的内存容量中尽能 地提高内存利用率。因为，Host Memory与Guest Memory并不是一一对应的关系，通过Host Memory超配技术可以实现某一个Host上某一个虚拟机内存大于主机内存，这一点与CPU虚拟化不一样。但是，在执行超配技术时，需要考虑主机性能问题，不能过大。一般的超配限额是主机内存的50%。要实现主机内存超配，必须通过<strong>内存复用</strong>技术实现。目前常用的内存复用技术有：<strong>零页共享技术、内存气球回收技术</strong>和<strong>内存置换技术</strong>三种。</p><h3 id="零页（透明页）共享技术"><a href="#零页（透明页）共享技术" class="headerlink" title="零页（透明页）共享技术"></a>零页（透明页）共享技术</h3><p>当运行多个虚拟机时，有些内存页面的内容很可能是完全一样的，比如：什么数据都没有的零页。这就为虚拟机之间甚至在虚拟机内部提供了共享内存的可能。例如：当几个虚拟机都运行相同的操作系统、相同的应用程序或者包含相同的用户数据时，那些包含相同数据的内存页面完可以被共享。基于这个原理，VMM完全可通过回收冗余数据的内存页面，仅维持一个被多个虚拟机共享的内存拷贝来实现这个功能。</p><p><strong>如下图所示，是华为FusionCompute的零页共享技术示意图：</strong></p><p><img src="https://i.loli.net/2019/05/18/5cdf732c5c23754430.jpg"></p><p><strong>其基本原理是</strong>：用户进程定时扫描虚拟机的的内存数据，如果发现其数据内容全为零，则通过修改PA to MA映射的形式，把其指向一个特定的零页，从而做到在物理内存中只保留一份零页拷贝，虚拟机的所有零页均指向该页，从而达到节省内存资源的目的。当零页数据发生变动时，由Xen动态分配一页内存出来给虚拟机，使修改后的数据有内存页进行存放。因此，对GuestOS来说，整个零页共享技术是完全不感知的。</p><p>而在VMware的ESX解决方案中，也有同样的技术。在VMware ESX/ESXi中，检测页面数据是否冗余是通过<strong>散列</strong>的方法来实现的，如下图所示。</p><p><img src="https://i.loli.net/2019/05/18/5cdf734451c6887409.jpg"></p><p>首先VMM会维持一个全局散列表，其中<strong>每个表项都记录了一个物理页面数据的散列值与页号</strong>。当对某一个虚拟机进行页面共享扫描时，VMM会针对该虚拟机物理页面的数据计算散列值，并在全局散列表 中进行遍历及匹配是否有相同的散列值的表项。<strong>当找到了匹配的表项，还要对页面数据内容逐位比较，以避免由于散列冲突而导致的页面内容不一样的可能性。</strong>一旦确定页面数据完全一致，则会修改逻辑地址到物理地址的映射关系，即<strong>将从逻辑地址对应到包含冗余数据的物理地址的映射关系（上图中虚线所示）改为对应到要被共享物理地址的映射关系，并回收冗余的物理页面</strong>。这一过程对于虚拟机操作系统是完全透明的。因此，<strong>共享页面中含有敏感数据的部分不会在虚拟机之间泄露</strong>。</p><p>当虚拟机对共享页面发生写操作时，通过“写时拷贝”（ Copy-on-Write）技术来实现。 如下图所示：</p><p><img src="https://i.loli.net/2019/05/18/5cdf735c64aa688044.jpg"></p><p>具体来说，任何一个对共享页面的写操作都会引发页面错误（Minor Page Fault）。当VMM捕获到这个错误时，会给发起写操作的虚拟机创建一个该页面的私有拷贝，并将被写的逻辑地址映射到这个私有拷贝页面。这样虚拟机就可以安全地进行写操作，并且不会影响到其他共享该页面的虚拟机。相比于对非共享页面的写操作，尽管这种处理方法的确导致了一些额外的开销，但是却在一定程度上提高了内存页面的利用率。</p><h3 id="内存气球回收技术"><a href="#内存气球回收技术" class="headerlink" title="内存气球回收技术"></a>内存气球回收技术</h3><p><strong>内存气球回收技术也称为内存气泡技术，</strong>基于气球回收法的内存管理机制与页面共享完全不同。在虚拟化环境中，VMM会一次性在虚拟机启动后分配给虚拟机内存，由于虚拟机并没有意识到自己运行于 虚拟化平台上，之后它会一直运行在分配好的内存空间，而不主动释放分配的物理内存给其他虚拟机。因此VMM需要一种机制使得虚拟机能够主动释放空闲内存归还给物理机，再由VMM分配给其他有需求的虚拟机。并且，在内存资源需求紧张时还能从物理机中“拿回”自己释放的那部分内存。 </p><p><strong>如下所示，是华为FusionCompute内存气泡技术示意图：</strong></p><p><img src="https://i.loli.net/2019/05/18/5cdf73824ce0891613.jpg"></p><p><strong>原理如下：</strong>Hypervisor通过利用预装在用户虚拟机中的前端驱动程序，“偷取”Guest OS的内存贡献给VMM，以供其他虚拟机使用，反向时由VMM“偷取”气泡中的内存给特定虚拟机使用。内存气泡本质是将较为空闲的虚拟机内存释放给内存使用率较高的虚拟机，从而提升内存利用率。</p><p>在VMware的ESX解决方案中，也有类似的技术。下图给出了内存释放过程的原理图。</p><p><img src="https://i.loli.net/2019/05/18/5cdf7398dc3fa66352.jpg"></p><p>在上图（a）中，VMM有四个页面被映射到虚拟机的内存页面空间中，其中左侧两个页面被应用程序占用，而另两个被打上星号的页面则是在内存空闲列表中。当VMM要从虚拟机中回收内存时，比如要回收两个内存页面，VMM就会将Balloon驱动的目标膨胀大小设置为两个页面。Balloon驱动获得了目标膨胀值之后，就会在虚拟机内部申请两个页面空间的内存，并如上图（b）所示，调用虚拟机操系统的接口标示这两个页面被“ <strong>钉住</strong>”，即不能再被分配出去。</p><p>内存申请完毕后，Balloon驱动会通知VMM这两个页面的页号，这样VMM就可以找到相应的物理页号并进行回收。在上（b）中虚线就标示了这两个页面从虚拟机分配出去的状态。</p><p>由于被释放的页面在释放前已经在虚拟机的空闲列表中，因此没有进程会对该页面进行读写操作。如果虚拟机的进程接下来要重新访问这些页面，那么VMM可以像平常分配内存一样，再分配新的物理内存给这台虚拟机。当VMM决定收缩气球膨胀大小时，通过设置更小的目标膨胀值，balloon驱动会将已经被“<strong>钉住</strong>” 的页面归还给虚拟机。</p><p>通过气球回收法，尽管虚拟机的负载略微增加，但VMM却成功地将系统内存压力转移到各个虚拟机上。当balloon驱动发起申请内存的请求时，由虚拟机操作系统决定了是否要将虚拟机物理内存换出来满足balloon驱动的申请内存请求。如果虚拟机有充足的空闲内存，那么balloon驱动申请内存并不会对虚拟机的性能造成影响；如果虚拟机内存已经吃紧，那么就需要由虚拟机的操作系统决定换出哪些内存页面，满足balloon驱动的请求。因此，<strong>气球回收法巧妙地利用了各个虚拟机操作系统的内存换页机制来确定哪些页面要被释放给物理机，而不是由VMM来决定</strong>。 </p><p><strong>气球回收法要求虚拟机操作系统必须安装balloon驱动</strong>，在VMware的ESX/ESXi产品中，就是VMware Tool。另外，气球回收法回收内存需要一段时间，不能马上满足系统的需求。</p><h3 id="内存置换技术"><a href="#内存置换技术" class="headerlink" title="内存置换技术"></a>内存置换技术</h3><p>页面共享机制与气球回收法都从不同的角度尽可能地提高虚拟机的内存利用率，从虚拟机中收回可以复用或者空闲的内存。然而这两种方法都不能在短时间内满足系统内存回收的要求：<strong>页面共享依赖于页面的扫描速度，以及是否有页面可共享；气球回收法则取决于虚拟机操作系统对于balloon驱动申请内存的响应时间</strong>。如果这两种温和的方法都不能满足需求，<strong>VMM则会采取内存换出机制，即强制性地从虚拟机中夺回内存，这就是内存置换技术。</strong></p><p><strong>如下所示，是华为FusionCompute和VMware ESX/ESXI的内存置换技术示意图。</strong></p><p><img src="https://i.loli.net/2019/05/18/5cdf73c2b12e968100.jpg"></p><p><strong>原理如下：</strong>通过VMM实现请页功能，这时Guest OS类似进程一样在VMM缺少内存时，能被换出到宿主机磁盘上，也就是将虚拟机长时间未访问的内存内容被置换到存储中，并建立映射，当虚拟机再次访问该内存内容时再置换回来。该方法也对虚拟机透明，即虚拟机不感知。</p><p>具体来说，VMM会在每个虚拟机启动时创建一个单独的换页文件（Swap File）。在必要的时候，VMM会主动将虚拟机的物理内存页面换到这个换页文件上，释放给其他虚拟机使用。内存换出机制是VMM需要在短时间内缓解内存压力的一种有效方法，然而这种方法却很可能严重导致VMM的性能下降。由于VMM对于虚拟机的内存使用状态并不解，且该方法对虚拟机透明，强制内存换出可能触发虚拟机操作系统内部的一些换页机制。举例来说，虚拟机操作系统永远都不会将内核的内存页面换出，而VMM并不知道哪些页正在被内核使用，一旦这些页面被换出，会使得虚拟机性能严重受损。</p><h3 id="内存的回收"><a href="#内存的回收" class="headerlink" title="内存的回收"></a>内存的回收</h3><p>接下来以VMware ESX为例，结合上述三种内存复用技术，介绍内存回收机制。一般来说，ESX会对物理机的空闲内存状态按照空闲内存的百分比设置四种状态，分别是：<strong>高（6%）、平缓（4%）、繁重（2%）和低（1%）</strong>。ESX会按照这四种状态来选择前述三种内存回收机制。</p><p>缺省状态下，ESX会启用页面共享机制，因为页面共享机制能以较小的开销提高内存利用率。何时启用气球回收和换页则取决于当前系统的内存状态。当内存状态处于“高”，很显然此时总的虚拟机内存使用量要小于物理机的内存容量，因此不管虚拟机的内存是否已经被过载分配，VMM都不会使用气球 或者换页的方法回收内存。</p><p>然而，当物理机空闲内存状态下降到了“平缓” 状态，VMM则开始使用气球回收法。事实上，气球回收法是在空闲内存的百分比高于“平缓” 的阈值4%之前启动的，这是因为该方法总是需要一段时间才能在虚拟机内申请到一些内存。通常气球回收法都能够及时将空闲内存比的阈值控制在“平缓”状态之上。</p><p>一旦气球回收法不能够及时回收内存，并且空闲内存下降到“繁重”状态，即空闲内存比低于2%，那么VMM就会再启动内存换出机制强制从虚拟机回收内存。使用这种办法，VMM能够很快回收内存，并将空闲内存比控制回“平缓”状态。</p><p>在最坏的情况下，万一空闲内存状态低于“低”状态，即空闲内存比低于1%，那么VMM会继续使用内存换出法，同时将那些消耗内存值超过内存配置值的虚拟机挂起。</p><p>在某些情况下，VMM可能不会考虑物理机空闲内存状态，而仍然启动物理机内存回收机制。比如，即使整个系统的物理机空闲内存状态为“高”，如果某个虚拟机的内存使用量超过了其指定的内存上限，那么VMM会启动气球回收法，如有必要，也会启动内存换出机制从虚拟机回收内存，直到该虚拟机的内存低于指定的内存上限。</p><h3 id="内存QoS保障"><a href="#内存QoS保障" class="headerlink" title="内存QoS保障"></a>内存QoS保障</h3><p>在虚拟化系统中，内存虚拟化的QoS保障包括两个基本特征：<strong>预留</strong>和<strong>份额</strong>。</p><p><strong>内存预留：</strong>虚拟机预留的最低内存。预留的内存会被VM独占。即，一旦内存被某个虚拟机预留，即使虚拟机实际内存使用量不超过预留量，其它VM也无法抢占该VM的内存空闲资源。即，上述的三种内存复用技术对该虚拟机不生效。</p><p><strong>内存份额：</strong>适用上述三种资源复用场景，按比例分配内存资源。以6G内存规格的主机为例，假设其上运行有3台4G内存规格的虚拟机VMA，VMB，VMC。内存份额分别为20480，20480，40960，那么其内存分配比例为1：1：2。当三台VM内部逐步加压，策略会根据三个虚拟机的份额按比例分配调整内存资源，最终三台虚拟机获得的内存量稳定为1.5G/1.5G/3G。</p><p><strong>同样需要注意一点：内存份额只在各虚拟机发生资源竞争时生效。如没有竞争，则有需求的虚拟机可独占物理内存。</strong></p><p><strong>但是，内存QoS不像CPU QoS一样设置上限？，这是因为分配给虚拟机的内存大小就是其内存上限。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存虚拟化概述&quot;&gt;&lt;a href=&quot;#内存虚拟化概述&quot; class=&quot;headerlink&quot; title=&quot;内存虚拟化概述&quot;&gt;&lt;/a&gt;内存虚拟化概述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;所谓的内存虚拟化，即如何在多个虚拟机之间共享物理内存以及如何进行动态分配&lt;/strong&gt;。在《x86架构基础》一文中已经介绍操作系统对物理服务器内存管理的知识，它的本质就是将物理内存地址映射到一段线性地址空间，也有叫逻辑地址空间，应用程序访问内存物理地址是通过段页查询机制完成。而这个线性地址空间或逻辑地址空间本身就是物理内存的虚拟化呈现。在虚拟化环境中，分配给虚拟机内存非常类似于操作系统中关于线性地址空间的实现。操作系统负责维护虚页号到实页号的映射，并将这一 映射信息保存到页表（Page Table）。在 x86架构的CPU中，内存管理单元MMU与TLB这两个模块就负责实现并优化虚拟内存的性能。详见《DPDK技术在电信云中最佳实践》系列文章。
    
    </summary>
    
      <category term="NFV关键技术" scheme="https://kkutysllb.cn/categories/NFV%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="电信云" scheme="https://kkutysllb.cn/tags/%E7%94%B5%E4%BF%A1%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>2019-05-15-Linux系统命令-第八篇《进程管理命令》</title>
    <link href="https://kkutysllb.cn/2019/05/15/2019-05-15-Linux%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4-%E7%AC%AC%E5%85%AB%E7%AF%87%E3%80%8A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4%E3%80%8B/"/>
    <id>https://kkutysllb.cn/2019/05/15/2019-05-15-Linux系统命令-第八篇《进程管理命令》/</id>
    <published>2019-05-15T15:30:32.000Z</published>
    <updated>2019-05-15T15:52:48.726Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ps：查看进程"><a href="#ps：查看进程" class="headerlink" title="ps：查看进程"></a>ps：查看进程</h2><p>ps命令用于列出执行ps命令的那个时刻的进程快照，就像用手机给进程照了一张照片。如果想要动态地显示进程的信息，就需要使用top命令，该命令类似于把手机切换成录像模式。因为ps命令能够支持多种系统（Linux\UNIX等），所以选项较多。但是学习时只需要掌握常用的参数即可。而且由于ps命令的功能实在是太多了，26个字母已经满足不了，因此，在ps命令的参数中有类似于-a与a这2种写法，这2种写法的功能是不一样的。<a id="more"></a></p><p><strong>语法格式：ps [option]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/05/15/5cdc30fef395980814.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）PS命令不接任何参数</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ~]<span class="comment"># ps</span></span><br><span class="line">   PID TTY          TIME CMD</span><br><span class="line"> 11097 pts/1    00:00:00 bash</span><br><span class="line"> 40755 pts/1    00:00:00 ps</span><br></pre></td></tr></table></figure><p><strong>默认情况下，ps命令不接任何参数，显示的使用者当前所在终端的进程。</strong></p><p><strong>2）常用命令组合</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-e选项显示unix格式所有进程</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ps -e</span></span><br><span class="line">   PID TTY          TIME CMD</span><br><span class="line">     1 ?        00:00:01 systemd</span><br><span class="line">     2 ?        00:00:00 kthreadd</span><br><span class="line">     3 ?        00:00:00 ksoftirqd/0</span><br><span class="line">     5 ?        00:00:00 kworker/0:0H</span><br><span class="line">     7 ?        00:00:00 migration/0</span><br><span class="line">     8 ?        00:00:00 rcu_bh</span><br><span class="line">     9 ?        00:00:02 rcu_sched</span><br><span class="line">。。。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时加上-f选项，额外显示UID、PPID、C和TIME栏</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># C栏表示进程占用CPU的百分比</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TTY栏显示？表示该进程与终端无关，否则显示相应的终端</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ps -ef   # 常用组合</span></span><br><span class="line">UID         PID   PPID  C STIME TTY          TIME CMD</span><br><span class="line">root          1      0  0 17:12 ?        00:00:01 /usr/lib/systemd/systemd --system --deseriali</span><br><span class="line">root          2      0  0 17:12 ?        00:00:00 [kthreadd]</span><br><span class="line">root          3      2  0 17:12 ?        00:00:00 [ksoftirqd/0]</span><br><span class="line">root          5      2  0 17:12 ?        00:00:00 [kworker/0:0H]</span><br><span class="line">root          7      2  0 17:12 ?        00:00:00 [migration/0]</span><br><span class="line">root          8      2  0 17:12 ?        00:00:00 [rcu_bh]</span><br><span class="line">root          9      2  0 17:12 ?        00:00:02 [rcu_sched]</span><br><span class="line">root         10      2  0 17:12 ?        00:00:00 [lru-add-drain]</span><br><span class="line">。。。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找特定进程信息，常用ps -ef与grep结合使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示系统SSH进程的相关信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ps -ef|grep ssh</span></span><br><span class="line">root       1146      1  0 17:13 ?        00:00:00 /usr/sbin/sshd -D</span><br><span class="line">root      11093   1146  0 17:23 ?        00:00:02 sshd: root@pts/1</span><br><span class="line">root      40759  11097  0 22:42 pts/1    00:00:00 grep --color=auto ssh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用BSD格式显示每个进程信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所谓BSD格式就是选项前面不带“-”符号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># VSZ栏表示该进程使用掉的虚拟内存量（单位KB）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># RSS栏表示该进程占用的固定内存量（单位KB）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># STAT栏表示该进程目前的状态，具体状态解释详见最后</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ps aux</span></span><br><span class="line">USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root          1  0.0  0.0  46104  6396 ?        Ss   17:12   0:01 /usr/lib/systemd/systemd --sy</span><br><span class="line">root          2  0.0  0.0      0     0 ?        S    17:12   0:00 [kthreadd]</span><br><span class="line">root          3  0.0  0.0      0     0 ?        S    17:12   0:00 [ksoftirqd/0]</span><br><span class="line">root          5  0.0  0.0      0     0 ?        S&lt;   17:12   0:00 [kworker/0:0H]</span><br><span class="line">root          7  0.0  0.0      0     0 ?        S    17:12   0:00 [migration/0]</span><br><span class="line">root          8  0.0  0.0      0     0 ?        S    17:12   0:00 [rcu_bh]</span><br><span class="line">root          9  0.0  0.0      0     0 ?        S    17:12   0:02 [rcu_sched]</span><br><span class="line">root         10  0.0  0.0      0     0 ?        S&lt;   17:12   0:00 [lru-add-drain]</span><br><span class="line">root         11  0.0  0.0      0     0 ?        S    17:12   0:00 [watchdog/0]</span><br><span class="line">root         12  0.0  0.0      0     0 ?        S    17:12   0:00 [watchdog/1]</span><br><span class="line">。。。</span><br></pre></td></tr></table></figure><p><strong><em>STAT栏进程状态解释：</em></strong></p><ul><li>R：正在运行，或者是可以运行。</li><li>S：正在中断睡眠中，可以由某些信号量唤醒。</li><li>D：不可中断睡眠</li><li>T：正在侦测或停止了。</li><li>Z：已经终止，但是其父进程无法终止它，从而编程僵尸进程状态。</li><li>+：前台进程。</li><li>l：多线程进程</li><li>N：低优先级进程</li><li>&lt;：高优先级进程</li><li>s：进程领导者</li><li>L：已将页面锁定到内存中</li></ul><p><strong>3）显示指定用户相关的进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-u选项显示root'用户相关进程，注意-u和u的区别</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ps -u root</span></span><br><span class="line">PID TTY          TIME CMD</span><br><span class="line">1 ?        00:00:01 systemd</span><br><span class="line">2 ?        00:00:00 kthreadd</span><br><span class="line">3 ?        00:00:00 ksoftirqd/0</span><br><span class="line">5 ?        00:00:00 kworker/0:0H</span><br><span class="line">7 ?        00:00:00 migration/0</span><br><span class="line">8 ?        00:00:00 rcu_bh</span><br><span class="line">9 ?        00:00:02 rcu_sched</span><br><span class="line">10 ?        00:00:00 lru-add-drain</span><br></pre></td></tr></table></figure><p><strong>4）显示进程的详细信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># F：代表这个进程的标志（flag），4代表使用者为super user</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># S：代表这个进程的状态（STAT)，见前例说明</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># PPID：父进程号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># PID：本进程号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># NI：nice值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ADDR：表示进程在内存中的地址范围</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># WCHAN：表示这个进程是否在运行，若在运行，取值为“-”</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ps -l</span></span><br><span class="line">F S   UID    PID   PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">4 S     0  11097  11093  0  80   0 - 28859 do_wai pts/1    00:00:00 bash</span><br><span class="line">0 R     0  40780  11097  0  80   0 - 38300 -      pts/1    00:00:00 ps</span><br></pre></td></tr></table></figure><p><strong>5）显示进程树</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-H选项显示进程树，配合-e选项显示所有进程的进程树</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ps -eH</span></span><br><span class="line">PID TTY          TIME CMD</span><br><span class="line">2 ?        00:00:00 kthreadd</span><br><span class="line">3 ?        00:00:00   ksoftirqd/0</span><br><span class="line">5 ?        00:00:00   kworker/0:0H</span><br><span class="line">7 ?        00:00:00   migration/0</span><br><span class="line">8 ?        00:00:00   rcu_bh</span><br><span class="line">9 ?        00:00:02   rcu_sched</span><br><span class="line">10 ?        00:00:00   lru-add-drain</span><br><span class="line">11 ?        00:00:00   watchdog/0</span><br><span class="line">12 ?        00:00:00   watchdog/1</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 或者使用BSD格式axf组合选项也可达到同样效果</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ps axf</span></span><br><span class="line">PID TTY      STAT   TIME COMMAND</span><br><span class="line">2 ?        S      0:00 [kthreadd]</span><br><span class="line">3 ?        S      0:00  \_ [ksoftirqd/0]</span><br><span class="line">5 ?        S&lt;     0:00  \_ [kworker/0:0H]</span><br><span class="line">7 ?        S      0:00  \_ [migration/0]</span><br><span class="line">8 ?        S      0:00  \_ [rcu_bh]</span><br><span class="line">9 ?        S      0:02  \_ [rcu_sched]</span><br><span class="line">10 ?        S&lt;     0:00  \_ [lru-add-drain]</span><br><span class="line">11 ?        S      0:00  \_ [watchdog/0]</span><br><span class="line">12 ?        S      0:00  \_ [watchdog/1]</span><br><span class="line">13 ?        S      0:00  \_ [migration/1]</span><br><span class="line">。。。</span><br></pre></td></tr></table></figure><p><strong>6）查看系统进程，找出CPU占用率最高的进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-o选项自定义显示pcpu字段值，使用--sort选项进行排序，默认从小到大，前面加-号从大到小排序</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ps -eo pid,ppid,pcpu,args,comm --sort -pcpu</span></span><br><span class="line">PID   PPID %CPU COMMAND                     COMMAND</span><br><span class="line">30785      1  1.7 /usr/bin/dockerd --insecure dockerd</span><br><span class="line">11489      1  1.2 /usr/bin/containerd         containerd</span><br><span class="line">1      0  0.0 /usr/lib/systemd/systemd -- systemd</span><br><span class="line">2      0  0.0 [kthreadd]                  kthreadd</span><br><span class="line">3      2  0.0 [ksoftirqd/0]               ksoftirqd/0</span><br><span class="line">5      2  0.0 [kworker/0:0H]              kworker/0:0H</span><br><span class="line">7      2  0.0 [migration/0]               migration/0</span><br><span class="line">8      2  0.0 [rcu_bh]                    rcu_bh</span><br><span class="line">9      2  0.0 [rcu_sched]                 rcu_sched</span><br><span class="line">10      2  0.0 [lru-add-drain]             lru-add-drain</span><br><span class="line">。。。</span><br></pre></td></tr></table></figure><h2 id="pstree：显示进程状态树"><a href="#pstree：显示进程状态树" class="headerlink" title="pstree：显示进程状态树"></a>pstree：显示进程状态树</h2><p>pstree命令以树形结构显示进程和进程之间的关系。如果不指定进程的PID号，或者不指定用户名称，则会以init进程（CentOS 7为systemd进程）为根进程，显示系统的所有进程信息；若指定用户或PID，则将以用户或PID为根进程，显示用户或PID对应的所有进程。</p><p><strong>注意：CentOS 7中默认没有pstree命令，因此执行命令后会提示command not found，此时需要通过yum命令安装，执行以下命令即可</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y psmisc</span><br></pre></td></tr></table></figure><p><strong>语法格式：pstree [option] [<pid>/<user>]</user></pid></strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/05/15/5cdc32159287525588.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）显示进程树</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 若不指定PID号或者不指定用户，则会以init（CentOS7系统是systemd）进程为根进程，显示系统所有进程</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># pstree</span></span><br><span class="line">systemd─┬─VGAuthService</span><br><span class="line">├─agetty</span><br><span class="line">├─auditd───&#123;auditd&#125;</span><br><span class="line">├─chronyd</span><br><span class="line">├─containerd─┬─containerd-shim─┬─registry───7*[&#123;registry&#125;]</span><br><span class="line">│            │                 └─9*[&#123;containerd-shim&#125;]</span><br><span class="line">│            └─16*[&#123;containerd&#125;]</span><br><span class="line">├─crond</span><br><span class="line">├─dbus-daemon───&#123;dbus-daemon&#125;</span><br><span class="line">├─dockerd─┬─docker-proxy───7*[&#123;docker-proxy&#125;]</span><br><span class="line">│         └─15*[&#123;dockerd&#125;]</span><br><span class="line">├─irqbalance</span><br><span class="line">├─master─┬─pickup</span><br><span class="line">│        └─qmgr</span><br><span class="line">├─polkitd───5*[&#123;polkitd&#125;]</span><br><span class="line">├─rsyslogd───2*[&#123;rsyslogd&#125;]</span><br><span class="line">├─sshd───sshd───bash───pstree</span><br><span class="line">├─systemd-journal</span><br><span class="line">├─systemd-logind</span><br><span class="line">├─systemd-udevd</span><br><span class="line">├─tuned───4*[&#123;tuned&#125;]</span><br><span class="line">└─vmtoolsd───&#123;vmtoolsd&#125;</span><br></pre></td></tr></table></figure><p><strong>2）显示指定用户的进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示apache用户的所有进程，共有5个进程</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># pstree apache</span></span><br><span class="line">httpd</span><br><span class="line">httpd</span><br><span class="line">httpd</span><br><span class="line">httpd</span><br><span class="line">httpd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-c选项显示所有进程，包含父进程和子进程</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-p选项显示进程的pid</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># pstree -c -p apache</span></span><br><span class="line">httpd(40920)</span><br><span class="line">httpd(40921)</span><br><span class="line">httpd(40922)</span><br><span class="line">httpd(40923)</span><br><span class="line">httpd(40924)</span><br></pre></td></tr></table></figure><p><strong>3）显示进程归属的用户</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-u选项显示进程归属的用户</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进程后[&#123;...&#125;]中的内容就是进程归属的用户信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># pstree -u</span></span><br><span class="line">systemd─┬─VGAuthService</span><br><span class="line">├─agetty</span><br><span class="line">├─auditd───&#123;auditd&#125;</span><br><span class="line">├─chronyd(chrony)</span><br><span class="line">├─containerd─┬─containerd-shim─┬─registry───7*[&#123;registry&#125;]</span><br><span class="line">│            │                 └─9*[&#123;containerd-shim&#125;]</span><br><span class="line">│            └─16*[&#123;containerd&#125;]</span><br><span class="line">├─crond</span><br><span class="line">├─dbus-daemon(dbus)───&#123;dbus-daemon&#125;</span><br><span class="line">├─dockerd─┬─docker-proxy───7*[&#123;docker-proxy&#125;]</span><br><span class="line">│         └─15*[&#123;dockerd&#125;]</span><br><span class="line">├─httpd───5*[httpd(apache)]</span><br><span class="line">├─irqbalance</span><br><span class="line">├─master─┬─pickup(postfix)</span><br><span class="line">│        └─qmgr(postfix)</span><br><span class="line">├─polkitd(polkitd)───5*[&#123;polkitd&#125;]</span><br><span class="line">├─rsyslogd───2*[&#123;rsyslogd&#125;]</span><br><span class="line">├─sshd───sshd───bash───pstree</span><br><span class="line">├─systemd-journal</span><br><span class="line">├─systemd-logind</span><br><span class="line">├─systemd-udevd</span><br><span class="line">├─tuned───4*[&#123;tuned&#125;]</span><br><span class="line">└─vmtoolsd───&#123;vmtoolsd&#125;</span><br></pre></td></tr></table></figure><h2 id="pgrep：查找匹配条件的进程"><a href="#pgrep：查找匹配条件的进程" class="headerlink" title="pgrep：查找匹配条件的进程"></a>pgrep：查找匹配条件的进程</h2><p>pgrep命令可以查找匹配条件的进程号。</p><p><strong>语法格式：pgrep [option] [pattern]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/05/15/5cdc32916906552788.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）显示指定进程的pid</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示httpd进程进程号</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># pgrep httpd</span></span><br><span class="line">40919</span><br><span class="line">40920</span><br><span class="line">40921</span><br><span class="line">40922</span><br><span class="line">40923</span><br><span class="line">40924</span><br></pre></td></tr></table></figure><p><strong>2）显示指定用户的进程号</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-u选项显示指定用户postfix的进程号</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># pgrep -u postfix</span></span><br><span class="line">1737</span><br><span class="line">40931</span><br></pre></td></tr></table></figure><h2 id="kill：终止进程"><a href="#kill：终止进程" class="headerlink" title="kill：终止进程"></a>kill：终止进程</h2><p>kill命令能够终止你希望停止的进程。</p><p><strong>语法格式：kill [option] [pid]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/05/15/5cdc32dd9719b18900.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）列出所有信号的名称</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-l选项，显示所有信号</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># kill -l</span></span><br><span class="line">1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP</span><br><span class="line">6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL10) SIGUSR1</span><br><span class="line">11) SIGSEGV12) SIGUSR213) SIGPIPE14) SIGALRM15) SIGTERM</span><br><span class="line">16) SIGSTKFLT17) SIGCHLD18) SIGCONT19) SIGSTOP20) SIGTSTP</span><br><span class="line">21) SIGTTIN22) SIGTTOU23) SIGURG24) SIGXCPU25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM27) SIGPROF28) SIGWINCH29) SIGIO30) SIGPWR</span><br><span class="line">31) SIGSYS34) SIGRTMIN35) SIGRTMIN+136) SIGRTMIN+237) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+439) SIGRTMIN+540) SIGRTMIN+641) SIGRTMIN+742) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+944) SIGRTMIN+1045) SIGRTMIN+1146) SIGRTMIN+1247) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+1449) SIGRTMIN+1550) SIGRTMAX-1451) SIGRTMAX-1352) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-1154) SIGRTMAX-1055) SIGRTMAX-956) SIGRTMAX-857) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-659) SIGRTMAX-560) SIGRTMAX-461) SIGRTMAX-362) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-164) SIGRTMAX</span><br></pre></td></tr></table></figure><p><strong>常用信号说明：</strong></p><p><img src="https://i.loli.net/2019/05/15/5cdc33114511356436.jpg"></p><p><strong>2）终止进程说明</strong></p><p>kill指令默认使用的信号为15，用于结束进程。如果进程忽略此信号，则可以使用信号9强制终止进程。一般是先通过ps等命令获取到要终止进程的进程号，然后直接使用“kill进程号”就可以了。比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> 2203 <span class="comment">#&lt;==kill命令默认使用的信号为15，这种格式也是最常用的。</span></span><br><span class="line"><span class="built_in">kill</span> -s 15 2203 <span class="comment">#&lt;==这种格式使用-s参数明确指定发送值为15的信号，效果和kill 2203一样。</span></span><br><span class="line"><span class="built_in">kill</span> -15 2203 <span class="comment">#&lt;==上面的-s 15可以简写为-15。</span></span><br></pre></td></tr></table></figure><p>如果用上面的方法还是无法终止进程，那么我们就可以用KILL（9）信号强制终止进程。</p><p>kill -9 2203 #&lt;==<strong>信号9会强行终止进程，这会带来一些副作用，如数据丢失，或者终端无法恢复到正常状态等，因此应尽量避免使用，除非进程使用其他信号无法终止。</strong></p><p><strong>3）特殊信号0的作用</strong></p><p>在kill的所有信号中，有一个十分特殊的信号值0，使用格式为<strong>kill -0 $pid</strong>。其中的-0表示不发送任何信号给$pid对应的进程，但是仍然会对$pid是否存在对应的进程进行检査，如果$pid对应的进程已存在，则返回0，若不存在则返回1。因此，这个特殊信号通常用于系统管理shell脚本中判断某个进程是否运行的条件表达式。</p><h2 id="killall：通过进程名终止进程"><a href="#killall：通过进程名终止进程" class="headerlink" title="killall：通过进程名终止进程"></a>killall：通过进程名终止进程</h2><p>使用kill命令终止进程还需要先获取进程的pid进程号，这个过程有点繁琐，而使用killall命令就可以直接用“killall进程名”这种形式终止进程。</p><p><strong>语法格式：killall [option] [name]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/05/15/5cdc33bc0e31d24710.jpg"></p><p><img src="https://i.loli.net/2019/05/15/5cdc33cd04b8435545.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）终止定时任务服务进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ~]<span class="comment"># killall crond</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看crond进程状态，确认</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果什么输出也没有，则表示crond进程被终止</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ps -ef | grep crond | grep -v grep</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同样，也可使用BSD格式aux选项查看进程状态确认</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果进程的状态是S，则表示被终止</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ps aux | grep cornd</span></span><br><span class="line">root      40964  0.0  0.0 112704   972 pts/1    S+   00:14   0:00 grep --color=auto cornd</span><br></pre></td></tr></table></figure><p><strong>2）终止指定用户的所有进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 终止apache用户的所有httpd进程</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># killall -u apache httpd</span></span><br></pre></td></tr></table></figure><h2 id="pkill：通过进程名终止进程"><a href="#pkill：通过进程名终止进程" class="headerlink" title="pkill：通过进程名终止进程"></a>pkill：通过进程名终止进程</h2><p>pkill命令可通过进程名终止指定的进程。使用killall终止进程需要连续执行几次，而pkill可以杀死指定进程及其所有子进程。</p><p><strong>语法格式：pkill [option] [name]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/05/15/5cdc342e2eb4733234.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）通过进程名终止进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看定时任务crond当前状态</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># systemctl status crond</span></span><br><span class="line">● crond.service - Command Scheduler</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/crond.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: inactive (dead) since Sat 2019-05-04 00:11:34 CST; 11min ago</span><br><span class="line">  Process: 10272 ExecStart=/usr/sbin/crond -n <span class="variable">$CRONDARGS</span> (code=exited, status=0/SUCCESS)</span><br><span class="line"> Main PID: 10272 (code=exited, status=0/SUCCESS)</span><br><span class="line"></span><br><span class="line">May 03 17:19:56 C7-Server01 systemd[1]: Started Command Scheduler.</span><br><span class="line">May 03 17:19:56 C7-Server01 systemd[1]: Starting Command Scheduler...</span><br><span class="line">May 03 17:19:56 C7-Server01 crond[10272]: (CRON) INFO (RANDOM_DELAY will be scaled with f...d.)</span><br><span class="line">May 03 17:19:56 C7-Server01 crond[10272]: (CRON) INFO (running with inotify support)</span><br><span class="line">May 03 17:19:56 C7-Server01 crond[10272]: (CRON) INFO (@reboot <span class="built_in">jobs</span> will be run at comput...p.)</span><br><span class="line">May 04 00:11:34 C7-Server01 crond[10272]: (CRON) INFO (Shutting down)</span><br><span class="line">Hint: Some lines were ellipsized, use -l to show <span class="keyword">in</span> full.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动定时任务crond</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># systemctl start crond</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过进程名终止进程crond</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># pkill crond</span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># systemctl status crond</span></span><br><span class="line">● crond.service - Command Scheduler</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/crond.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: inactive (dead) since Sat 2019-05-04 00:24:03 CST; 9s ago</span><br><span class="line">  Process: 40980 ExecStart=/usr/sbin/crond -n <span class="variable">$CRONDARGS</span> (code=exited, status=0/SUCCESS)</span><br><span class="line"> Main PID: 40980 (code=exited, status=0/SUCCESS)</span><br><span class="line"></span><br><span class="line">May 04 00:23:29 C7-Server01 systemd[1]: Started Command Scheduler.</span><br><span class="line">May 04 00:23:29 C7-Server01 systemd[1]: Starting Command Scheduler...</span><br><span class="line">May 04 00:23:29 C7-Server01 crond[40980]: (CRON) INFO (RANDOM_DELAY will be scaled with f...d.)</span><br><span class="line">May 04 00:23:29 C7-Server01 crond[40980]: ((null)) No security context but SELinux <span class="keyword">in</span> per...ab)</span><br><span class="line">May 04 00:23:29 C7-Server01 crond[40980]: ((null)) No security context but SELinux <span class="keyword">in</span> per...ly)</span><br><span class="line">May 04 00:23:29 C7-Server01 crond[40980]: (CRON) INFO (running with inotify support)</span><br><span class="line">May 04 00:23:29 C7-Server01 crond[40980]: (CRON) INFO (@reboot <span class="built_in">jobs</span> will be run at comput...p.)</span><br><span class="line">Hint: Some lines were ellipsized, use -l to show <span class="keyword">in</span> full.</span><br></pre></td></tr></table></figure><p><strong>2）通过终端名终止进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前用户运行的终端信息，通过w指令实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TTY列就是当前用户终端类型</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># w</span></span><br><span class="line"> 00:29:17 up  7:16,  2 users,  load average: 0.00, 0.01, 0.05</span><br><span class="line">USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">kkutysll tty1                      00:27   13.00s  0.03s  0.01s vim /etc/ssh/ssh_config</span><br><span class="line">root     pts/1    192.168.101.1    17:23    5.00s  0.30s  0.01s w</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上述结果说明：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># kkutysllb用户正在服务器本地登录，且正在编辑ssh服务配置文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># root用户正在远程登录，且正在使用w命令查询服务器当前登录用户状态信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过终端名终止kkutysllb的进程</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># pkill -t tty1</span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># w</span></span><br><span class="line"> 00:31:48 up  7:18,  2 users,  load average: 0.00, 0.01, 0.05</span><br><span class="line">USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">kkutysll tty1                      00:27    2:44   0.03s  0.03s -bash</span><br><span class="line">root     pts/1    192.168.101.1    17:23    4.00s  0.29s  0.00s w</span><br></pre></td></tr></table></figure><p>本地登录用户kkutysllb编辑ssh配置文件的操作被终止了</p><p><img src="https://i.loli.net/2019/05/15/5cdc348a1ceed80249.jpg"></p><p><strong>3）通过用户名终止进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ~]<span class="comment"># w</span></span><br><span class="line"> 00:34:34 up  7:21,  2 users,  load average: 0.00, 0.01, 0.05</span><br><span class="line">USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">kkutysll tty1                      00:27   10.00s  0.26s  0.02s vim /etc/sysconfig/network-scr</span><br><span class="line">root     pts/1    192.168.101.1    17:23    2.00s  0.29s  0.00s w</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-u选项，终止kkutysllb用户编辑网卡配置文件操作</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># pkill -u kkutysllb</span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># w</span></span><br><span class="line"> 00:35:23 up  7:22,  2 users,  load average: 0.00, 0.01, 0.05</span><br><span class="line">USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">kkutysll tty1                      00:27   59.00s  0.24s  0.24s -bash</span><br><span class="line">root     pts/1    192.168.101.1    17:23    3.00s  0.29s  0.00s w</span><br></pre></td></tr></table></figure><p>用户kkutysllb编辑网卡配置文件的操作被root用户远程终止。</p><p><img src="https://i.loli.net/2019/05/15/5cdc34c0179d588853.jpg"></p><p><strong>如果kkutysllb不是通过本地登录服务器，而是远程登录，通过-u选项可以将kkutysllb踢下线，效果请大家自行练习。</strong></p><h2 id="nice：调整程序运行时的优先级"><a href="#nice：调整程序运行时的优先级" class="headerlink" title="nice：调整程序运行时的优先级"></a>nice：调整程序运行时的优先级</h2><p>nice命令是一个当程序启动时，修改程序运行优先级的命令。Linux的优先级范围是从-20（最大优先级）到19（最小优先级）。优先级越高的程序占用CPU的次数越多，反之亦然。</p><p><strong>语法格式：nice [option] [command]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/05/15/5cdc34e785e9542473.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）单独使用nice命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不接任何选项和程序时，显示出当前系统默认的nice程序运行优先级为0</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># nice</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure><p><strong>2）默认增加优先级10</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不加-n选项，直接跟程序名</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># nice nice</span></span><br><span class="line">10</span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># nice nice nice</span></span><br><span class="line">19</span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># nice nice nice nice</span></span><br><span class="line">19</span><br></pre></td></tr></table></figure><p>第1个nice命令以默认值10来调整第2个nice命令运行的优先级，即在系统默认的程序运行优先级0的基础之上增加10，得到新的程序运行优先级10，然后以优先级10来运行第2个nice命令，最后第2个nice命令显示当前程序运行的优先级为10。所以，再加一个nice就是19（因为最小优先级为19），再往后加nice一直都是19。</p><p><strong>3）查看进程优先级</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ~]<span class="comment"># ps -l</span></span><br><span class="line">F S   UID    PID   PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">4 S     0  11097  11093  0  80   0 - 28859 do_wai pts/1    00:00:00 bash</span><br><span class="line">0 R     0  41043  11097  0  80   0 - 38300 -      pts/1    00:00:00 ps</span><br></pre></td></tr></table></figure><p>在上面的输出结果中，需要重点关注以下两列。</p><ul><li>PRI：代表这个进程的优先级，通俗点说就是进程被CPU执行的先后顺序，此值越小进程的优先级别就越高，就能越早执行。</li><li>NI：代表这个进程的nice值，表示进程可被执行的优先级的修正数值，在加入nice值后，将会使得PRI变为：PRI（new）=80（PRI初始默认值）+nice。这样一来，如果nice值为负值，那么该进程的优先级值将变小，即其优先级会变高，也表示其越快被执行。</li></ul><p><strong>总结：NI是优先值，是用户层面的概念，PR是进程的实际优先级，是给内核（kernel）用的。进程的nice值不是进程的优先级，它们不是一个概念，但是进程的nice值会影响到进程的优先级变化。</strong></p><h2 id="renice：调整运行中的进程的优先级"><a href="#renice：调整运行中的进程的优先级" class="headerlink" title="renice：调整运行中的进程的优先级"></a>renice：调整运行中的进程的优先级</h2><p>nice命令常用于修改未运行的程序运行时的优先级，但是对于正在运行的进程，若想要修改其优先级，就需要用到renice命令。</p><p>在系统运行中，有时会发现某个不是很重要的进程占用了太多的CPU资源，因此会希望限制这个进程或者是希望某个进程优先运行。这些都是renice命令的使用场景。</p><p><strong>语法格式：renice [option]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/05/15/5cdc3559d1cef39479.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）修改指定进程号的优先级</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在当前进程后台创建一个vim命令进程</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># vim /etc/host &amp;</span></span><br><span class="line">[1] 1839</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前系统进程信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ps -l</span></span><br><span class="line">F S   UID    PID   PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">4 S     0   1770   1767  0  80   0 - 28858 do_wai pts/0    00:00:00 bash</span><br><span class="line">0 T     0   1839   1770  0  80   0 - 37284 do_sig pts/0    00:00:00 vim</span><br><span class="line">0 R     0   1840   1770  0  80   0 - 38300 -      pts/0    00:00:00 ps</span><br><span class="line"></span><br><span class="line">[1]+  Stopped                 vim /etc/host</span><br><span class="line"></span><br><span class="line"><span class="comment"># vim当前进程的优先级为80，NI为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用renice的-p选项指定进程1839，将其NI值调整为-5</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># renice -n -5 -p 1839</span></span><br><span class="line">1839 (process ID) old priority 0, new priority -5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次查看当前系统进程信息，发现vim的PRI变为75</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ps -l</span></span><br><span class="line">F S   UID    PID   PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">4 S     0   1770   1767  0  80   0 - 28859 do_wai pts/0    00:00:00 bash</span><br><span class="line">0 T     0   1839   1770  0  75  -5 - 37284 do_sig pts/0    00:00:00 vim</span><br><span class="line">0 R     0   1846   1770  0  80   0 - 38300 -      pts/0    00:00:00 ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仍然通过renice指令调整</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># renice -n -5 -p 1839</span></span><br><span class="line">1839 (process ID) old priority -5, new priority -5</span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ps -l</span></span><br><span class="line">F S   UID    PID   PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">4 S     0   1770   1767  0  80   0 - 28859 do_wai pts/0    00:00:00 bash</span><br><span class="line">0 T     0   1839   1770  0  75  -5 - 37284 do_sig pts/0    00:00:00 vim</span><br><span class="line">0 R     0   1848   1770  0  80   0 - 38300 -      pts/0    00:00:00 ps</span><br></pre></td></tr></table></figure><p><strong>结论：PRI值并不是在上一次的基础上进行变化，而是一直在初始默认值80这个值之上变动。</strong></p><h2 id="runlevel：输出当前运行级别"><a href="#runlevel：输出当前运行级别" class="headerlink" title="runlevel：输出当前运行级别"></a>runlevel：输出当前运行级别</h2><p>runlevel命令用于输出当前Linux系统的运行级别。</p><p><strong>语法格式：runlevel [option]</strong></p><p><strong>重要参数选项</strong></p><p><img src="https://i.loli.net/2019/05/15/5cdc359024f2a37179.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>查看当前系统的运行级别</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ~]<span class="comment"># runlevel </span></span><br><span class="line">N 3</span><br></pre></td></tr></table></figure><p><strong>上面的结果说明当前的运行级别为3。对于系统级别，不同的数字代表的意思不一样，具体如下。</strong></p><ul><li>0：停机</li><li>1：单用户模式</li><li>2：无网络的多用户模式</li><li>3：多用户模式</li><li>4：未使用</li><li>5：图形界面多用户模式</li><li>6：重启</li></ul><h2 id="init：初始化Linux进程"><a href="#init：初始化Linux进程" class="headerlink" title="init：初始化Linux进程"></a>init：初始化Linux进程</h2><p>init命令是Linux下的进程初始化工具，init进程是所有Linux进程的父进程，它的进程号为1。init命令的主要任务是依据配置文件“/etc/inittab”创建Linux进程。</p><p><strong>语法格式：init [option]</strong></p><p><strong>【使用示例】</strong></p><p><strong>切换系统运行级别</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关机</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># init 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># init 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 单用户</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># init 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多用户</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># init 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 图形模式</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># init 5</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ps：查看进程&quot;&gt;&lt;a href=&quot;#ps：查看进程&quot; class=&quot;headerlink&quot; title=&quot;ps：查看进程&quot;&gt;&lt;/a&gt;ps：查看进程&lt;/h2&gt;&lt;p&gt;ps命令用于列出执行ps命令的那个时刻的进程快照，就像用手机给进程照了一张照片。如果想要动态地显示进程的信息，就需要使用top命令，该命令类似于把手机切换成录像模式。因为ps命令能够支持多种系统（Linux\UNIX等），所以选项较多。但是学习时只需要掌握常用的参数即可。而且由于ps命令的功能实在是太多了，26个字母已经满足不了，因此，在ps命令的参数中有类似于-a与a这2种写法，这2种写法的功能是不一样的。
    
    </summary>
    
      <category term="Linux核心命令" scheme="https://kkutysllb.cn/categories/Linux%E6%A0%B8%E5%BF%83%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Linux" scheme="https://kkutysllb.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>2019-05-13-计算虚拟化之CPU虚拟化</title>
    <link href="https://kkutysllb.cn/2019/05/13/2019-05-13-%E8%AE%A1%E7%AE%97%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B9%8BCPU%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    <id>https://kkutysllb.cn/2019/05/13/2019-05-13-计算虚拟化之CPU虚拟化/</id>
    <published>2019-05-13T09:17:34.000Z</published>
    <updated>2019-05-13T09:29:57.886Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CPU虚拟化概述"><a href="#CPU虚拟化概述" class="headerlink" title="CPU虚拟化概述"></a>CPU虚拟化概述</h2><p><strong>CPU虚拟化的一个很大挑战就是要确保虚拟机发出CPU指令的隔离性。</strong>即为了能让多个虚拟机同时在一个主机上安全运行，VMM必须将各个虚拟机隔离，以确保不会相互干扰，同时也不会影响VMM内核的正常运行。尤其要注意的是：<strong>由于特权指令会影响到整个物理机，必须要使得虚拟机发出的特权指令仅作用于自身，而不会对整个系统造成影响。</strong>例如：当虚拟机发出重启命令时，并不是要重启整个物理机，而仅仅是重启所在的虚拟机。因此，VMM必须能够对来自于虚拟机操作硬件的特权指令 进行<strong>翻译</strong>并<strong>模拟</strong>，然后在对应的虚拟设备上执行，而不在整个物理机硬件设备上运行。<a id="more"></a></p><h3 id="软件方式实现的CPU虚拟化—二进制翻译技术"><a href="#软件方式实现的CPU虚拟化—二进制翻译技术" class="headerlink" title="软件方式实现的CPU虚拟化—二进制翻译技术"></a>软件方式实现的CPU虚拟化—二进制翻译技术</h3><p>二进制翻译（Binary Translation，BT）是一 种软件虚拟化技术，由VMware在Workstations和ESX产品中最早实现。在最初没有硬件虚拟化时代，是全虚拟化的唯一途径。由于BT最开始是用来虚拟化32位平台的，因此，也称为BT32。</p><p>二进制翻译，简单来说就是将那些不能直接执行的特权指令进行翻译后才能执行。具体来说，当虚拟机第一次要执行一段指令代码时，VMM会将要执行执行的代码段发给一个称为“Just-In-Time”的BT翻译器，它类似Java中的JVM虚拟机和Python的解释器，实时将代码翻译成机器指令。 翻译器将虚拟机的非特权指令翻译成可在该虚拟机上安全执行的指令子集， 而对于特权指令，则翻译为一组在虚拟机上可执行的特权指令，却不能运行在物理机上。这种机制实现了对虚拟机的<strong>隔离</strong>与<strong>封装</strong>，同时又使得x86指令的语义在虚拟机层次上得到保证。</p><p>在执行效率上，为了降低翻译指令的开销，VMM会将执行过的二进制指令翻译结果进行缓存。如果虚拟机再次执行同样的指令序列，那么之前被缓存的翻译结果可以被复用。这样就可以均衡整个VM执行指令集的翻译开销。为了进一步降低由翻译指令导致的内存开销，VMM还会将虚拟机的内核态代码 翻译结果和用户态代码直接绑定在一起。由于用户态代码不会执行特权指令，因此这种方法可以保证 安全性。<strong>采用BT机制的VMM必须要在虚拟机的地址空间和VMM的地址空间进行严格的边界控制。</strong>VMware VMM利用x86CPU中的段检查功能（Segmentation）来确保这一点。但是由于现代操作系统 Windows、Linux以及Solaris等都很少使用段检查功能，因此VMM可以使用段保护机制来限制虚拟机和VMM之间的地址空间边界控制。在极少数情况下，当虚拟机的确使用了段保护机制并且引发了 VMM冲突，VMM可以转而使用软件的段检查机制来解决这一问题。</p><h3 id="硬件方式实现的CPU虚拟化—VT-x和AMD-v"><a href="#硬件方式实现的CPU虚拟化—VT-x和AMD-v" class="headerlink" title="硬件方式实现的CPU虚拟化—VT-x和AMD-v"></a>硬件方式实现的CPU虚拟化—VT-x和AMD-v</h3><p>2003年，当AMD公司将x86从32位扩展到64位时，也将段检查功能从64位芯片上去除。同样的情况也 出现在Intel公司推出的64位芯片上。这一变化意味着基于BT的VMM无法在64位机上使用段保护机制保护VMM。尽管后来AMD公司为了支持虚拟化又恢复了64位芯片的段检查功能，并一直延续到目前所有的AMD 64位芯片，但是Intel公司却并没有简单恢复 ，而是研发了新的硬件虚拟化技术VT-x，AMD公司紧随后也推出了AMD-V技术来提供CPU指令集虚拟化的硬件支持。VT-x与AMD-V尽管在具体实现上有所不同，但其目的<strong>都是希望通过硬件的途径来限定某些特权指令操作的权限</strong>，而不是原先只能通过二进制动态翻译来解决这个问题。</p><p>如前所述，VT-x提供了2个运行环境：<strong>根（Root）环境</strong>和<strong>非根（Non-root）环境</strong>。根环境专门为VMM准备，就像没有使用VT-x技术的x86服务器，只是多了对VT-x支持的几条指令。非根环境作为一个受限环境用来运行多个虚拟机。</p><p><img src="https://i.loli.net/2019/05/13/5cd936cddfae743184.jpg"></p><p>根操作模式与非根操作模式都有相应的特权级0至特权级3。VMM运行在根模式的特权级0，Guest OS的内核运行在非根模式的特权级0，Guest OS的应用程序运行在非根模式的特权级3。运行环境之间相互转化，从根环境到非根环境叫VM Entry；从非根环境到根环境叫VM Exit。VT-x定义了VM Entry操作，使CPU由根模式切换到非根模式，运行客户机操作系统指令。若在非根模式执行了敏感指令或发生了中断等，会执行VM Exit操作，切换回根模式运行VMM。此外，VT-x还引入了一组新的命令：<strong>VMLanch/ VMResume用于调度Guest OS，发起VM Entry；</strong>VMRead/ VMWrite则用于配置VMCS。</p><p><strong>根模式与非根模式之问的相互转换是通过VMX操作实现的。</strong>VMM可以通过VMX ON 和VMX OFF打开或关闭VT-x。如下图所示：</p><p><img src="https://i.loli.net/2019/05/13/5cd936ea46c3c16573.jpg"></p><p><strong>VMX操作模式流程：</strong></p><ol><li>VMM执行VMX ON指令进入VMX操作模式。</li><li>VMM可执行VMLAUNCH指令或VMRESUME指令产生VM Entry操作，进入到Guest OS，此时CPU处于非根模式。</li><li>Guest OS执行特权指令等情况导致VM Exit的发生，此时将陷入VMM，CPU切换为根模式。VMM根据VM Exit的原因作出相应处理，处理完成后将转到第2步，继续运行GuestOS。</li><li>VMM可决定是否退出VMX操作模式，通过执行VMXOFF指令来完成。</li></ol><p>这样，就无需二进制翻译和半虚拟化来处理这些指令。同时，VT-x与AMD-V都提供了存放虚拟机状态的模块，这样做的的目的就是将虚拟机上 下文切换状态进行缓存，降低频模式繁切换引入的大量开销。 还是以VT-x解决方案为例，VMX新定义了虚拟机控制结构VMCS(Virtual Machine ControlStructure)。VMCS是保存在内存中的数据结构，其包括虚拟CPU的相关寄存器的内容及相关的控制信息。CPU在发生VM Entry或VM Exit时，都会查询和更新VMCS。VMM也可通过指令来配置VMCS，达到对虚拟处理器的管理。VMCS架构图如下图所示：</p><p><img src="https://i.loli.net/2019/05/13/5cd93705adbec22425.jpg"></p><p><strong>每个vCPU都需将VMCS与内存中的一块区域关联起来，此区域称为VMCS区域。</strong>对VMCS区域的操纵是通过VMCS指针来实现的，这个指针是一个指向VMCS的64位的地址值。VMCS区域是一个<strong>最大不超过4KB的内存块，且需4KB对齐</strong>。</p><p>VMCS区域分为三个部分：<strong>偏移地址0起始存放VMCS版本标识，通过不同的版本号，CPU可维护不同的VMCS数据格式</strong>；<strong>偏移地址4起始存放VMX终止指示器，在VMX终止发生时，CPU会在此处存入终止的原因；偏移地址8起始存放VMCS数据区，这一部分控制VMX非根操作及VMX切换。</strong></p><p>VMCS 的数据区包含了VMX配置信息：<strong>VMM在启动虚拟机前配置其哪些操作会触发VM Exit</strong>。VMExit 产生后，处理器把执行权交给VMM 以完成控制，然后VMM 通过指令触发VM Entry 返回原来的虚拟机或调度到另一个虚拟机。<strong>。</strong></p><p>VMCS 的数据结构中，每个虚拟机一个，加上虚拟机的各种状态信息，共由3个部分组成：</p><ul><li><p><strong>Gueststate：</strong>该区域保存了虚拟机运行时的状态，在VM Entry 时由处理器装载；在VM Exit时由处理器保存。它又由两部分组成：</p></li><li><ul><li><strong>Guest OS寄存器状态</strong>：包括控制寄存器、调试寄存器、段寄存器等各类寄存器的值。</li><li><strong>Guest OS非寄存器状态</strong>：记录当前处理器所处状态，是活跃、停机（HLT）、关机（Shutdown）还是等待启动处理器间中断（Startup-IPI）。</li></ul></li><li><p><strong>Hoststate：</strong>该区域保存了VMM 运行时的状态，主要是一些寄存器值，在VM Exit时由处理器装载。</p></li><li><p><strong>Control data：</strong>该区域包含虚拟机执行控制域、VM Exit控制域、VM Entry控制域、VM Exit信息域和VM Entry信息域。</p></li></ul><p>有了VMCS结构后，对虚拟机的控制就是读写VMCS结构。比如：对vCPU设置中断，检查状态实际上都是在读写VMCS数据结构。</p><h2 id="CPU虚拟化管理"><a href="#CPU虚拟化管理" class="headerlink" title="CPU虚拟化管理"></a>CPU虚拟化管理</h2><p>为了保证电信云/NFV中关键业务虚机运行的性能，就要求同一台物理机上的多个业务虚机实例所获取的资源既能满足其运行的需要，同时不互相产生干扰，这就需要对CPU资源进行精细化的调优和管理，也就是CPU QoS保障技术。在介绍CPU QoS保障技术之前，我们首先来看下CPU虚拟化的本质和超配技术。</p><h3 id="CPU虚拟化的本质和超配"><a href="#CPU虚拟化的本质和超配" class="headerlink" title="CPU虚拟化的本质和超配"></a>CPU虚拟化的本质和超配</h3><p><img src="https://i.loli.net/2019/05/13/5cd937364346e91496.jpg"></p><p>vCPU数量和物理CPU对应关系如上图所示，以华为RH2288H V3服务器使用2.6GHz主频CPU为例，单台服务器有2个物理CPU，每颗CPU有8核，又因为超线程技术，每个物理内核可以提供两个处理线程，因此每颗CPU有16线程，总vCPU数量为2<em>8</em>2=32个vCPU。总资源为32*2.6GHz=83.2GHz。</p><p><strong>虚拟机vCPU数量不能超过单台物理服务器节点可用vCPU数量</strong>。但是，由于多个虚拟机间可以复用同一个物理CPU，因此单物理服务器节点上运行的虚拟机vCPU数量总和可以超过实际vCPU数量，这就叫做<strong>CPU超配技术</strong>。</p><p>例如，以华为的FusionCompute为例，查询显示的服务器可用CPU的物理个数为2个，每个主频2.4GHz。</p><p><img src="https://i.loli.net/2019/05/13/5cd9375b03d0624108.jpg"></p><p>这是特权虚机中占用CPU资源，占用了4个vCPU</p><p><img src="https://i.loli.net/2019/05/13/5cd9378993cc569946.jpg"></p><p>在资源池性能页，可以查看每个物理CPU有6个核，并且开启了超线程，也就是每个物理CPU有12个核的资源，一台服务器总共vCPU数量为：12<em>2=24个。由于在华为的FUSinCompute中CPU的资源统计单位不是逻辑核数，而是频率HZ。因此，可用资源（12</em>2-4）*2.4=48GHz（为什么减4个？因为系统DM0占用了4个vCPU，因此单个客户机最多只能使用20个vCPU）。如下所示，当前已经使用了19.15GHZ，占用率为39.39%。</p><p><img src="https://i.loli.net/2019/05/13/5cd937a72be2962794.jpg"></p><h3 id="CPU的QoS保障"><a href="#CPU的QoS保障" class="headerlink" title="CPU的QoS保障"></a>CPU的QoS保障</h3><p>了解了CPU虚拟化的本质和超配，前文提到的CPU的QoS保障技术主要指的是<strong>CPU上下限配额</strong>及<strong>优先级调度</strong>技术。</p><p><strong>CPU的上下限配额主要指的是vCPU资源管理层面的解决方案。</strong>在CPU虚拟化后，根据虚拟化的资源—频率HZ，来对虚拟机进行分配时，为了保证虚拟机的正常运行，特地定义了三种vCPU资源的划分方式，这就是CPU资源的QoS管理。可以按照限额、份额和预留三种方式进行vCPU资源划分，三者之间是有一定依赖和互斥关系的，其定义具体如下：</p><ul><li><strong>CPU资源限额：</strong>控制虚拟机占用物理资源的上限。</li><li><strong>CPU资源份额：</strong>CPU份额定义多个虚拟机在竞争物理CPU资源的时候按比例分配计算资源。</li><li><strong>CPU资源预留：</strong>CPU预留定义了多个虚拟机竞争物理CPU资源的时候分配的最低计算资源。</li></ul><p>为了描述上述三种vCPU资源划分方式的关系，我们还是举例来说明。比如：单核CPU主频为3GHz，该资源供两个虚拟机VM1和VM2使用。</p><p><strong>场景一：当</strong>VM1资源限额为2GHz，VM1可用的CPU资源最多为2GHz，也就意味着如果VM2没有设定CPU QoS，那么VM2最多只有1GHZ的vCPU可以使用。</p><p><strong>场景二：当</strong>VM1和VM2的资源份额分别是1000和2000，在资源紧张场景下发生竞争时，VM1最多可获得1GHz的vCPU，VM2最多可获得2GHz的vCPU。</p><p><strong>场景三：当给虚拟机</strong>VM1资源预留2GHz的vCPU资源，VM2资源预留为0，在资源紧张发生竞争时，VM1最少可获得2GHz的vCPU，最多可获得3GHZ的vCPU（在没有超配时），而VM2最多可获得1GHz（3-2=1）的vCPU资源，最少为0。</p><p>上例只是简单描述了各种vCPU划分方式单独生效时的场景，也是在实际中较常用的场景。同时，在实际中还有一些场景是多种vCPU划分方式共同作用的，虽然不常用，但是却是实实在在有意义的。比如：以一个主频为2.8GHz的单核物理机为例，如果运行有三台单CPU的虚拟机A、B、C，份额分别为1000、2000、4000，预留值分别为700MHz、0MHz、0MHz。当三个虚拟机满CPU负载运行时，每台虚拟机应分配到资源计算如下：</p><p>虚拟机A按照份额分配本应得400MHz，由于其预留值大于400MHz，最终计算能力按照预留值700MHz算，剩余的2100MHz资源按照2000:4000也就是1:2的比例在B和C之间进行划分，因此虚拟机B得到700MHz计算资源，虚拟机C得到1400MHz计算资源。</p><p><strong>这里有一点需要注意：CPU的份额和预留只在多个虚拟机竞争物理CPU资源时发生，如果没有竞争发生，有需求的虚拟机可以独占物理CPU的资源。</strong></p><p><strong>而CPU的优先级调度技术主要指的的服务器虚拟化后资源的重分配机制。</strong>从上述虚拟化的结构可以看出，虚拟机和VMM共同构成虚拟机系统vCPU资源的两极调度框架。如下图所示，是一个多核环境下的虚拟机vCPU资源的两级调度框架。</p><p><img src="https://i.loli.net/2019/05/13/5cd937d8e362836269.jpg"></p><p><strong>虚拟机操作系统负责第2级调</strong>度，即<strong>线程或进程在vCPU上的调度</strong>（将核心线程映射到相应的vCPU 上）。VMM负责第1级调度，即<strong>vCPU在物理处理单元上的调度</strong>。<strong>两级调度的策略和机制不存在依赖关系。</strong> vCPU调度器负责物理处理器资源在各个虚拟机之间的分配与调度，本质上把各个虚拟机中的vCPU按照一定的策略和机制调度在物理处理单元上，可以采用任意的策略（如上面资源管理方案）来分配物理资源，满足虚拟机的不同需求。vCPU可以调度在一个或多个物理处理单元执行（分时复用或空间复用物理处理单元），也可以与物理处理单元建立一对一绑定关系（限制访问指定的物理理单元）。</p><h2 id="NUMA架构感知的调度技术"><a href="#NUMA架构感知的调度技术" class="headerlink" title="NUMA架构感知的调度技术"></a>NUMA架构感知的调度技术</h2><p>除了基础的两级调度技术外，还有基于NUMA架构的精细化调度技术。在<a href>《DPDK技术栈在电信云中的最佳实践（一）》</a>一文中，我们介绍过服务器的NUMA架构，其产生的主要原因就是解决服务器SMP架构扩展性能的问题。同样，在计算虚拟化中的CPU资源调度方面，也有基于服务器NUMA架构的调度技术，这就是<strong>Host NUMA</strong>和<strong>Guest NUMA</strong>技术，<strong>它们都是虚拟化软件技术。</strong></p><p>Host NUMA主要提供CPU负载均衡机制，解决CPU资源分配不平衡引起的VM性能瓶颈问题，当启动VM时，Host NUMA根据当时主机内存和CPU负载，选择一个负载较轻的node放置该VM，使VM的CPU和内存资源分配在同一个node上。</p><p><img src="https://i.loli.net/2019/05/13/5cd93848b9b3e66204.jpg"></p><p>如上图左边所示，Host NUMA把VM的物理内存放置在一个node上，对VM的vCPU调度范围限制在同一个node的物理CPU上，并将VM的vCPU亲和性绑定在该node的物理CPU上。考虑到VM的CPU负载是动态变化，在初始放置的node上，node的CPU资源负载也会随之变化，这会导致某个node的CPU资源不足，而另一个node的CPU资源充足，在此情况下，Host NUMA会从CPU资源不足的node上选择VM，把VM的CPU资源分配在CPU资源充足的node上，从而动态实现node间的CPU负载均衡。 Host NUMA保证VM访问本地物理内存，减少了内存访问延迟，可以提升VM性能，性能提升的幅度与VM虚拟机访问内存大小和频率相关。对于VM的vCPU个数超过node中CPU的核数时，如上图右边所示，Host NUMA把该VM的vCPU和内存均匀地放置在每个node 上，vCPU的调度范围为所有node的CPU。</p><p>如果用户绑定了VM的vCPU亲和性，Host NUMA特性根据用户的vCPU亲和性设置决定VM的放置，若绑定在一个node的CPU上，Host NUMA把VM的内存和CPU放置在一个node上，若绑定在多个node的CPU上，Host NUMA把VM的内存均匀分布在多个node 上，VM的vCPU在多个node的CPU上均衡调度。</p><p><strong>Host NUMA技术的本质保证了VM访问本地物理内存，减少了内存访问延迟，可以提升VM性能，性能提升的幅度与VM访问内存大小和频率相关。Host NUMA主要应用于针对大规格、高性能虚拟机场景，适用Oracle、 SQL Server等关键应用。</strong></p><p><img src="https://i.loli.net/2019/05/13/5cd9386a8ed5914424.jpg"></p><p>Guest NUMA如上图所示，能够使得虚拟机内部程序运行时针对NUMA结构进行优化，CPU会优先使用同一个Node上的内存，从而减小内存访问延时、提高访问效率，以此达到提升应用性能的目的。目前OS和应用都会有针对NUMA的优化，<strong>VMM通过向虚拟机呈现NUMA结构，使Guest OS及其内部应用识别Numa结构， CPU会优先使用同一个Node上的内存，减小内存访问延时、提高访问效率。</strong></p><p><strong>Guest NUMA的本质就是VMM保证NUMNA结构的透传，使虚拟机中的关键应用在NUMA方面的优化生效，减少了内存访问延迟，可以提升VM性能。Guest NUMA主要应用于虚拟机中应用程序减小内存访问延时、提高访问效率，以此达到提升应用性能的目的。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CPU虚拟化概述&quot;&gt;&lt;a href=&quot;#CPU虚拟化概述&quot; class=&quot;headerlink&quot; title=&quot;CPU虚拟化概述&quot;&gt;&lt;/a&gt;CPU虚拟化概述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;CPU虚拟化的一个很大挑战就是要确保虚拟机发出CPU指令的隔离性。&lt;/strong&gt;即为了能让多个虚拟机同时在一个主机上安全运行，VMM必须将各个虚拟机隔离，以确保不会相互干扰，同时也不会影响VMM内核的正常运行。尤其要注意的是：&lt;strong&gt;由于特权指令会影响到整个物理机，必须要使得虚拟机发出的特权指令仅作用于自身，而不会对整个系统造成影响。&lt;/strong&gt;例如：当虚拟机发出重启命令时，并不是要重启整个物理机，而仅仅是重启所在的虚拟机。因此，VMM必须能够对来自于虚拟机操作硬件的特权指令 进行&lt;strong&gt;翻译&lt;/strong&gt;并&lt;strong&gt;模拟&lt;/strong&gt;，然后在对应的虚拟设备上执行，而不在整个物理机硬件设备上运行。
    
    </summary>
    
      <category term="NFV关键技术" scheme="https://kkutysllb.cn/categories/NFV%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="电信云" scheme="https://kkutysllb.cn/tags/%E7%94%B5%E4%BF%A1%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>2019-05-11-计算虚拟化概述</title>
    <link href="https://kkutysllb.cn/2019/05/11/2019-05-11-%E8%AE%A1%E7%AE%97%E8%99%9A%E6%8B%9F%E5%8C%96%E6%A6%82%E8%BF%B0/"/>
    <id>https://kkutysllb.cn/2019/05/11/2019-05-11-计算虚拟化概述/</id>
    <published>2019-05-11T02:36:29.000Z</published>
    <updated>2019-05-11T10:59:17.750Z</updated>
    
    <content type="html"><![CDATA[<p>所谓计算虚拟化，从狭义角度可理解为对单个物理服务器的虚拟化，主要包括对服务器上的CPU、内存、I/O设备进行虚拟化，目的就是实现多个虚拟机能各自独立、相互隔离地运行于一个服务器之上。从广义角度还可延伸到云资源池下，各类资源池组网场景下的CPU、内存、I/O设备等资源进行<strong>整合、抽象</strong>和<strong>虚拟化。</strong><a id="more"></a></p><h2 id="服务器虚拟化平台概念回顾"><a href="#服务器虚拟化平台概念回顾" class="headerlink" title="服务器虚拟化平台概念回顾"></a>服务器虚拟化平台概念回顾</h2><p>在上一篇文章<a href="https://kkutysllb.cn/2019/05/03/2019-05-03-%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/">《虚拟化基础》</a>中，我们介绍虚拟化基础的一些基本概念，这里我们按照服务器平台虚拟化后的一个分层结构来简单回顾下。如下：</p><p><img src="https://i.loli.net/2019/05/11/5cd635e4d8024.jpg"></p><p> 一个完整的服务器虚拟化平台从下到上包括以下几个部分：</p><ul><li><strong>底层物理资源：</strong>包括网卡、CPU、内存、存储设备等硬件资源，一般将包含物理资源的物理机称为 宿主机（Host）。</li><li><strong>虚拟机监控器（Virtual Machine Monitor，VMM）：</strong>VMM是位于虚拟机与底层硬件设备之间的虚拟层，直接运行于硬件设备之上，负责对硬件资源进行抽象，为上层虚拟机提供运行环境所需资源，并使每个虚拟机都能够互不干扰、相互独立地运行于同一个系统中。</li><li><strong>抽象化的虚拟机硬件：</strong>即虚拟层呈现的虚拟化的硬件设备。虚拟机能够发现哪种硬件设施，完全由VMM决定。虚拟设备可以是模拟的真实设备，也可以是现实中并不存在的虚拟设备，如VMware的vmxnet网卡。</li><li><strong>虚拟机：</strong>相对于底层提物理机，也称为客户机（Guest）。运行在其上的操作系统则称为客户机操作系统（Guest OS）。每个虚拟机操作系统都拥有自己的虚拟硬件，并在一个独立的虚拟环境中执行。通过VMM的隔离机制，每个虚拟机都认为自己作为一个独立的系统在运行。</li></ul><p>同时，在上一篇文章<a href>《虚拟化基础》</a>中，我们提到过<strong>Hypervisor就是VMM。其实，这个说法并不准确，至少在VMware的虚拟化解决方案中不准确</strong>，在VMware的ESX产品架构中，VMM和Hypervisor还是有一定区别的，如下图所示。</p><p><img src="https://i.loli.net/2019/05/11/5cd636306da7a.jpg"></p><p>Hypervisor是位于虚拟机和底层物理硬件之间的虚拟 层，包括boot loader、x86 平台硬件的抽象层，以及内存与CPU调度器，<strong>负责对运行在其上的多个虚拟机进行资源调度。</strong>而VMM则是与上层的虚机 一一对应 的进程，<strong>负责对指令集、内存、中断与基本的I/O设备进行虚拟化。</strong>当运行一个虚拟机时，Hypervisor中的vmkernel会装载VMM，虚拟机直接运行于VMM之上，并通过VMM的接口与Hypervisor进行通信。而<strong>在KVM和Xen架构中，虚拟层都称为Hypervisor，也就是**</strong>VMM=Hypervisor**。</p><p><strong>判断一个VMM能否有效确保服务器系统实现虚拟化功能，必须具备以下三个基本特征：</strong></p><ul><li><strong><em>等价性（Equivalence Property）：</em></strong>一个 运行于VMM控制 之下的程序（虚拟机），除了时序和资源可用性可能不一致外， 其行为应该与相同条件下运行在物理服务器上的行为一致。 </li><li><strong><em>资源可控 性（Resource Control Property）：</em></strong>VMM必须能够完全控制虚拟化的资源。 </li><li><strong><em>效率性（Efficiency Property）：</em></strong>除了特权指令，绝大部分机器指令都可以直接由硬件执行，而无需VMM干涉控制。</li></ul><p><strong>上述三个基本特征也是服务器虚拟化实现方案的指导思想。</strong></p><h2 id="x86平台虚拟化面临的问题与挑战"><a href="#x86平台虚拟化面临的问题与挑战" class="headerlink" title="x86平台虚拟化面临的问题与挑战"></a>x86平台虚拟化面临的问题与挑战</h2><p>基于x86的操作系统在一开始就被设计为能够直接运行在裸机硬件环境之上，所以自然拥有整个机器硬件的控制权限。为确保操作系统能够安全地操作底层硬件，x86平台使用了特权模式和用户模式的概念对内核程序与用户应用程序进行隔离。 在这个模型下，CPU提供了4个特权级别，分别是Ring0、1、2和3。如下图所示：</p><p><img src="https://i.loli.net/2019/05/11/5cd6367646f12.jpg"></p><p>Ring 0是最高特权级别，拥有对内存和硬件的直接访问控制权。Ring 1、2和3权限依次降低， 无法执行操作讷河系统级别的指令集合。相应的，运行于Ring 0的指令称为“特权指令”；运行于其他级别的称为“非特权指令”。常见的操作系统如Linux与Windows都运行于Ring 0，而用户级应用程序运行于Ring 3。如果低特权级别的程序执行了特权指令，会引起<strong>“ 陷入”（Trap）</strong>内核态，并抛出一个异常。</p><p>当这种分层隔离机制应用于虚拟化平台 ，为了满足 VMM的“资源可控” 特征，VMM必须处于Ring 0级别控制所有的硬件资源，并且执行最高特权系统调用。而虚拟机操作系统Guest OS则要被降级运行在Ring 1级别，故Guest OS在执行特权指令时都会引起”<strong>陷入</strong>“。如果VMM能够正常捕获异常，模拟Guest OS发出的指令并执行，就达到了目的。这就是IBM的Power系列所采用的<strong>特权解除</strong>和<strong>陷入模拟</strong>的机制，支持这种特性的指令集合通常被认为是“ <strong>可虚拟化的</strong>”。</p><p>但是。。。但是。。。但是。。。<strong>x86平台的指令集是不虚拟化的</strong>。为什么这么说？首先我们来看下x86平台指令集分类，x86平台的指令集大致分为以下4类：</p><ol><li>访问或修改机器状态的指令。 </li><li>访问或修改敏感寄存器或存储单元的指令， 比如访问时钟寄存器和中断寄存器。</li><li>访问存储保护系统或内存、地址分配系统的指令（段页之类）。</li><li>所有I/O指令。</li></ol><p>其中，1~4在x86平台都属于敏感指令，第1、4类指令属于敏感指令中的特权指令，由操作系统内核执行，Guest OS在执行两类指令时，因为不处于Ring 0级别，所以会陷入，并抛出异常，这个异常会被VMM捕获，然后模拟Gust OS去执行，并将执行结果返回给Guest OS。到此为止，一切都OK。但是，第2、3类指令属于非特权指令，可以由应用程序调用，也就是可以在Ring 3级别执行，并调用Guest OS内核进程来完成。当应用程序调用这些指令时，由于要修改内存和内部寄存器，这些状态修改需要由Guest OS完成，而Guse OS此时运行在Ring 1级别，虽然也会发生陷入，但是不会抛出异常，这样VMM就捕获不到，也就无法模拟完成。因此，当Guest OS执行这些指令就会导致虚拟机状态异常，甚至影响服务器的状态。在x86平台下，这类指令共有19个，我自己称之为x86平台敏感指令中的边界指令。</p><p>就是因为x86平台指令集有上述缺陷，所以为了计算虚拟化技术在x86平台应用，各大虚拟化厂商推出了五花八门的虚拟化技术，其目的都是围绕“<strong>如何捕获模拟这19条边界指令</strong>”这一命题来设计。在很长一段时间，都是通过软件的方式来解决这个问题，其中包括无需修改内核的<strong>全虚拟化</strong>与需要修改内核的半虚拟化。尽管半虚拟化要求修改Guest OS内核的方式在一定程度上并不满足“ 等价性”要求，但是在性能上却明显优于全虚拟化。直到2005年Intel与AMD公司分别推出了VT-d与AMD-V，能够在芯片级别支持全虚拟化时，虚拟化技术才得到彻底完善，这就是现在称之为的<strong>硬件辅助虚拟化技术</strong>。</p><h2 id="x86平台计算虚拟化解决方案"><a href="#x86平台计算虚拟化解决方案" class="headerlink" title="x86平台计算虚拟化解决方案"></a>x86平台计算虚拟化解决方案</h2><h3 id="全虚拟化"><a href="#全虚拟化" class="headerlink" title="全虚拟化"></a>全虚拟化</h3><p><strong>全虚拟化（Full Virtualization）与半虚拟化（Para- Virtualization）的划分，是相对于是否修改Guest OS而言的。</strong>如下图所示，全虚拟化通过一层能够完整模拟物理硬件环境的虚拟软件，使得Guest OS与底层物理硬件彻底解耦。因此，Guest OS无需任何修改，虚拟化的环境对其完全透明，也就是说在全虚方案中，虚拟机感知不到自己处于虚拟化环境中，认为自己一直运行在物理硬件上。如下图所示： </p><p><img src="https://i.loli.net/2019/05/11/5cd6aa1bb4122.jpg"></p><p>在实现上，通常是结合特权指令的二进制翻译机制与一般指令的直接执行的方式。具体来说， 对于Guest OS发出的特权指令和边界指令，VMM会进行实时翻译，并缓存结果（目的是提高虚拟化性能），而对于一般级别的指令，则无需VMM干涉，可以直接在硬件上执行。异常-捕获-模拟的过程如下图所示：</p><p><img src="https://i.loli.net/2019/05/11/5cd6aa3574064.jpg"></p><p>由于虚拟化环境对Guest OS是完全透明的，全虚拟化模式对于虚拟机的迁移以及可移植性是最佳解决方案，虚拟机可以无缝地从虚拟环境迁移到物理环境中。但是，软件模拟实现的全虚拟化无疑会增加VMM的上下文切换，因为这种方案实现的虚拟机性能不如半虚拟化方案。 VMware的ESX系列产品 和Workstations系列产品是全虚拟化技术的典型产品。</p><h3 id="半虚拟化"><a href="#半虚拟化" class="headerlink" title="半虚拟化"></a>半虚拟化</h3><p>如前所述，x86平台上一直存在一些Ring 3级别可以执行的边界指令，尽管全虚拟化模式通过实时译 这些特殊指令解决了这一问题，但是实现开销较大，性能并不如在实际物理机上运行。为了改善能，半虚拟化技术应运而生， “Para-Virtualization” 可理解为通过某种辅助的方式实现虚拟化。半虚拟化的解决方案如下图所示。</p><p><img src="https://i.loli.net/2019/05/11/5cd6aa688f432.jpg"></p><p>半虚拟化在Guest OS和虚拟层之间增加了一个特殊指令的过渡模块，通过<strong>修改Guest OS内核</strong>，<strong>将执行特权指令和边界指令替换为对虚拟层进行hypercall的调用方式来达到目的</strong>。同时，虚拟层也对内存管理、中断处理、时间同步提供了hypercall的调用接口。Hypercall调用过程如下图所示：</p><p><img src="https://i.loli.net/2019/05/11/5cd6aa85ecc26.jpg"></p><p>通过这种方式，虚拟机运行的性能得以显著提升。但是，对于某些无法修改内核的操作系统，比如：Windows，则不能使其运行于半虚拟化环境中。而且，由于需要修改Guest OS内核，无法保证虚拟机在物理环境与虚拟环境之间的透明切换。开源项目Xen和华为6.3版本之前的虚拟化解决方案Fusion Compute就是通过修改Linux内核以及提供I/O虚拟化操作的Domain 0的特殊虚拟机，使得运行于虚拟化环境上的虚拟机性能可以接近运行于物理环境的性能，属于半虚拟化技术方案的典型产品。但是，随着业务规模的增大，特殊虚机Domain 0是这种解决方案扩展性和性能方面的瓶颈。</p><h3 id="硬件辅助虚拟化"><a href="#硬件辅助虚拟化" class="headerlink" title="硬件辅助虚拟化"></a>硬件辅助虚拟化</h3><p>所谓“解铃还须系铃人”，针对敏感指令引发的一系列虚拟化问题，处理器硬件厂商最终给出了自己的解决方案。2005年Intel与AMD公司都效法IBM大型机虚拟化技术分别推出VT-x和AMD-V技术。如下图所示：</p><p><img src="https://i.loli.net/2019/05/11/5cd6aaa75cc20.jpg"></p><p>第一代VT-x与AMD-V都试图通过定义新的运行模式，使Guest OS恢复到Ring 0，而让VMM运行在比 Ring 0低的级别（可以理解为Ring -1）。比如： Intel公司的VT-x解决方案中，运行于非根模式下的Guest OS可以像在非虚拟化平台下一样运行于Ring 0级别，无论是Ring 0发出的特权指令还是Ring 3发出的敏感指令都会被陷入到根模式的虚拟层。VT-x解决方案具体如下图所示：</p><p><img src="https://i.loli.net/2019/05/11/5cd6aacadcc7a.jpg"></p><p>VT-x与AMD-V推出之后，完美解决解决x86平台虚拟化的缺陷，且提升了性能，所以各个虚拟化厂商均快速开发出对应的产品版本，用于支持这种技术。比如：KVM-x86、Xen 3.0与VMware ESX 3.0之后的虚拟化产品。随后Intel和AMD在第二代硬件辅助虚拟化技术中均推出了针对I/O的硬件辅助虚拟化技术VT-d和IOMMU。</p><p><strong>总结：x86平台下的三种虚拟化技术，都是围绕x86在虚拟化上的一些缺陷产生的。</strong>下图对三种虚拟 化技术进行了比较。</p><p><img src="https://i.loli.net/2019/05/11/5cd6aae286ad4.jpg"></p><p><strong>从图中可以看出，全虚拟化与半虚拟化的Guest OS的特权级别都被压缩在Ring 1中，而硬件虚拟化则将Guest OS恢复到了Ring 0级别。 在半虚拟化中，Guest OS的内核经过修改，所有敏感指令和特权指令都以Hypercall的方式进行调用，而在全虚拟化与硬件虚拟化中，则无需对Guest OS 进行修改。全虚拟化中对于特权指令和敏感指令采用了动态二进制翻译的方式，而硬件虚拟化由于在芯片中增加了根模式的支持，并修改 了敏感指令的语义，所有特权指令与敏感指令都能够自动陷入到根模式的VMM中。</strong></p><table><thead><tr><th></th><th><strong>利用二进制翻译的全虚拟化</strong></th><th><strong>硬件辅助虚拟化</strong></th><th><strong>操作系统协助/半虚拟化</strong></th></tr></thead><tbody><tr><td><strong>实现技术</strong></td><td>BT和直接执行</td><td>遇到特权指令转到root模式执行</td><td>Hypercall</td></tr><tr><td><strong>客户操作系统修改/兼容性</strong></td><td>无需修改客户操作系统，最佳兼容性</td><td>无需修改客户操作系统，最佳兼容性</td><td>客户操作系统需要修改来支持hypercall，因此它不能运行在物理硬件本身或其他的hypervisor上，兼容性差，不支持Windows</td></tr><tr><td><strong>性能</strong></td><td>差</td><td>全虚拟化下，CPU需要在两种模式之间切换，带来性能开销；但是，其性能在逐渐逼近半虚拟化。</td><td>好。半虚拟化下CPU性能开销几乎为0，虚机的性能接近于物理机。</td></tr><tr><td><strong>应用厂商</strong></td><td>VMware Workstation/QEMU/Virtual PC</td><td>VMware ESXi/Microsoft Hyper-V/Xen 3.0/KVM</td><td>Xen</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;所谓计算虚拟化，从狭义角度可理解为对单个物理服务器的虚拟化，主要包括对服务器上的CPU、内存、I/O设备进行虚拟化，目的就是实现多个虚拟机能各自独立、相互隔离地运行于一个服务器之上。从广义角度还可延伸到云资源池下，各类资源池组网场景下的CPU、内存、I/O设备等资源进行&lt;strong&gt;整合、抽象&lt;/strong&gt;和&lt;strong&gt;虚拟化。&lt;/strong&gt;
    
    </summary>
    
      <category term="NFV关键技术" scheme="https://kkutysllb.cn/categories/NFV%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="电信云" scheme="https://kkutysllb.cn/tags/%E7%94%B5%E4%BF%A1%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>2019-05-03-虚拟化技术基础</title>
    <link href="https://kkutysllb.cn/2019/05/03/2019-05-03-%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"/>
    <id>https://kkutysllb.cn/2019/05/03/2019-05-03-虚拟化技术基础/</id>
    <published>2019-05-03T06:02:14.000Z</published>
    <updated>2019-05-07T13:19:12.926Z</updated>
    
    <content type="html"><![CDATA[<p>DPDK技术奠定了NFV领域数据包转发性能提升的基础，那么软硬件解耦后，在通用服务器上实现各功能网元，资源层面的隔离和共生问题就需要虚拟化技术来解决。虚拟化使用软件的方法重新定义划分IT资源，可以实现IT资源的动态分配、灵活调度、跨域共享，提高IT资源利用率，使IT资源能够真正成为社会基础设施，服务于各行各业中灵活多变的应用需求。<a id="more"></a></p><p><img src="https://i.loli.net/2019/05/03/5ccbd9e108847.jpg"></p><h2 id="什么是虚拟化"><a href="#什么是虚拟化" class="headerlink" title="什么是虚拟化"></a>什么是虚拟化</h2><p><strong>坦白地说，虚拟化就是欺骗。</strong>随着个人计算机的普及，“虚拟化”这个广泛使用的术语已经脱离了其技术本身，成为一种共同语言、流行文化和理念。自20世纪90年代互联网热潮的早期，任何与Web相关的活动均被称为“虚拟”。通过菲利浦•狄克的科幻小说、让•鲍德里亚的后现代主义研究，以及电影（如《黑客帝国》和《盗梦空间》）的影响，<strong>模拟现实</strong>的概念已经深入人心。</p><p>在技术领域，虚拟化是指利用“欺骗”技术将一台计算机虚拟为多台逻辑计算机。在一台计算机上同时运行多个逻辑计算机，每个逻辑计算机可运行不同的操作系统，并且应用程序都可以在相互独立的空间内运行而互不影响，从而显著提高计算机的工作效率。</p><p><img src="https://i.loli.net/2019/05/03/5ccbda2bdfa98.jpg"></p><p>传统构架是在每台物理机器上仅能拥有一个操作系统，而且多数情况下仅有一个负载。很难在服务器上运行多个主应用程序，否则可能会产生冲突和性能问题（上世纪90年代前，服务器一直面临的问题）。要解决上述冲突，最佳做法是每个服务器仅运行一个应用程序以避免这些问题。但是，这么做的结果是大部分时间资源利用率很低，且成本很高。因此，必须在加大投资和降低风险间寻找平衡。但是，随着业务的增长，随之而来的成本压力也变化，相关管理效率也会变低，需消耗的资源也会变大。</p><p>企业实施虚拟化战略的核心目的就是提高IT部门作为业务支撑部门的工作效率，达到节约成本与提高效率并重的目的。<strong>虚拟化的重要使命之一就是提高管理效率</strong>，从而<strong>降低成本</strong>、提高硬件使用率，把管理变得更加轻松。虚拟化的主攻方向集中在减少实体服务器的部署数量，并将实体机器上的操作系统及应用程序，无缝转移至虚拟机器上，以便集中管理这些不同平台的虚拟环境。</p><p>传统构架下，APP:OS:Phy = 1:1:1。这样子就造成资源利用率低，为不造成资源浪费，会增加APP部署。进而产生的影响就是不同应用之间的资源抢占，隔离性差。而OS主要提供应用运行的环境，在资源调度方面相对薄弱，不能完全有效解决以上问题。</p><p>为在不造成冲突的前提下提高资源利用率，最好是在一个OS上部署一个APP，于是就出现了虚拟化的技术的雏形。在一台主机上部署多个虚拟客户机并安装OS，每个OS安装一个APP，这样就解决了问题，达到的效果是APP:OS:Phy = n:n:1。</p><p>虚拟化之后实现了上层操作系统与下层硬件的解耦，就是说操作系统不再依赖物理的硬件，而是在VMM层上建立OS，由VMM层来实现OS对硬件的需求。</p><p><strong>虚拟化的几个重要概念</strong></p><p><img src="https://i.loli.net/2019/05/03/5ccbdf9299a83.jpg"></p><ol><li><strong>宿主机（Host Machine）：</strong>指物理机资源，被Hypervisor用来执行一个或多个虚拟机器的电脑称为主机。</li><li><strong>客户机（Guest Machine）：</strong>指虚拟机资源，在Hypervisor之上运行多个虚拟机器则称为客户机。</li><li><strong>Guest OS和Host OS：</strong>如果将一个物理机虚拟成多个虚拟机，则称物理机为Host Machine，运行在其上的OS为Host OS；多个虚拟机称为Guest Machine，运行在其上的OS为Guest OS。</li><li><strong>Hypervisor：</strong>通过虚拟化层的模拟，虚拟机在上层软件看来就是一个真实的机器，这个虚拟化层一般称为虚拟机监控机（Virtual Machine Monitor，VMM）。<strong>需要注意一点：在VMware的ESX虚拟化架构中VMM只是Hypervisor中一个进程，因此在这种场景下VMM不等于Hypervisor。</strong></li></ol><h2 id="什么是Hypervisor（VMM）"><a href="#什么是Hypervisor（VMM）" class="headerlink" title="什么是Hypervisor（VMM）"></a>什么是Hypervisor（VMM）</h2><blockquote><p>维基百科的定义如下：Hypervisor，又称虚拟机器监视器（英语：virtual machine monitor，缩写为 VMM），是用来建立与执行虚拟机器的软件、固件或硬件。</p></blockquote><p>通俗的讲：hypervisor是一种运行在物理服务器和操作系统之间的中间层软件，可以允许多个操作系统和应用共享一套基础物理硬件。可以将hypervisor看做是虚拟环境中的“元”操作系统，可以协调访问服务器上的所有物理设备和虚拟机，所以又称为虚拟机监视器（virtual machine monitor）。</p><p>hypervisor是所有虚拟化技术的核心，非中断的支持多工作负载迁移是hypervisor的基本功能。当服务器启动并执行hypervisor时，会给每一台虚拟机分配适量的内存，cpu，网络和磁盘资源，并且加载所有虚拟机的客户操作系统。当前主流的Hypervisor有微软的Hyper-V，VMware、Xen和KVM，但在电信云NFV领域主要用到的就是KVM，在后续虚拟化技术分类中，会专门讲解KVM的相关部署和优化，同时为加深大家对KVM的理解，也会讲 一点Xen的知识，毕竟在KVM广泛应用之前，云架构底层的虚拟化技术都是Xen。</p><p><strong>虚拟化和hypervisor到底什么关系？</strong></p><p>虚拟化就是通过某种方式隐藏底层物理硬件的过程，从而让多个操作系统可以透明地使用和共享它。这种架构的另一个更常见的名称是平台虚拟化。在典型的分层架构中，提供平台虚拟化的层称为 hypervisor （有时称为虚拟机管理程序 或 VMM）。来宾操作系统称为虚拟机（VM），因为对这些 VM 而言，硬件是专门针对它们虚拟化的。如下图示：</p><p><img src="https://i.loli.net/2019/05/03/5ccbdf268869a.jpg"></p><p>在上图中可以看到，hypervisor 是提供底层机器虚拟化的软件层（在某些情况下需要处理器支持）。并不是所有虚拟化解决方案都是一样的（详见Hypervisor分类部分）。客户机操作系统（GuestOS）对机器的底层资源的访问通过VMM来实现。hypervisor 面对的对象不是客户机中的进程，而是整个客户操作系统（GuestOS）。</p><p><strong>hypervisor主要可以划分为两大类：类型1和类型2，以及在此基础上衍生出来的混合类型和操作系统类型。</strong></p><p><strong>类型1这种hypervisor是可以直接运行在物理硬件之上的</strong>。如下图所示，也就是说它不需要宿主机操作系统（HostOS）的支持，本身就可以管理底层硬件的资源，其本质是在Hypervisor中嵌入了一个精简的Linux操作系统内核。Xen 和 VMWare 的 ESXi 都属于这个类型，这种虚拟化类型的模型如下图所示，其特点就是需要硬件的支持，转发性能强（因为少了HostOS这一层转发），VMM就是HostOS。</p><p><img src="https://i.loli.net/2019/05/03/5ccbdf4674cf0.jpg"></p><p><strong>类型2这种hypervisor运行在另一个操作系统（运行在物理硬件之上）中</strong>。如下图所示，也就是说这种类型的Hypervisor是部署在HostOS之上的，从HostOS角度来看，其上层的所有VM都对应Hypervisor这一个进程。从VM的角度来看，其访问底层硬件资源需要Hypervisor和HostOS共同配合完成。KVM、VirtualBox 和 VMWare Workstation 都属于这个类型。这种虚拟化类型的模型如下图所示，其特点就是比较灵活，比如支持虚拟机嵌套（嵌套意味着可以在虚拟机中再运行hypervisor），但是转发性能明显不如类型1。</p><p><img src="https://i.loli.net/2019/05/03/5ccbdf70cc6c3.jpg"></p><p>目前，随着转发性能提升需求和应用的微服务化架构需求，在类型2的基础上又演进出混合类型虚拟化和基于HostOS的操作系统虚拟化。</p><p><strong>混合虚拟化：通过在主机的操作系统中增加虚拟硬件管理模块，通过虚拟硬件管理模块来生成各个虚拟机。</strong>属于类型2虚拟化的一种增强模型。特点是相对于类型2虚拟化，没有冗余，性能高，可支持多种操作系统。但是，需要底层硬件支持虚拟化扩展功能。现阶段的KVM和Hyper-V都属于这种增强型类型2虚拟化技术。</p><p><img src="https://i.loli.net/2019/05/03/5ccbdfbf1fc4b.jpg"></p><p><strong>操作系统虚拟化：没有独立的hypervisor层。相反，主机操作系统本身就负责在多个虚拟服务器之间分配硬件资源，并且让这些服务器彼此独立。</strong>最重要的前提是：<strong>如果使用操作系统层虚拟化，所有虚拟服务器必须运行同一操作系统(不过每个实例有各自的应用程序和用户账户)，其本质就是操作系统上面应用程序的一个进程，主要在应用的微服务化架构场景中使用。</strong>特点是：简单、易于实现，管理成本非常低。但是，隔离性差，多个虚拟化实例共享同一个操作系统。最典型就是目前炙手可热的容器技术Docker和Virtuozzo。</p><p><img src="https://i.loli.net/2019/05/03/5ccbdfdab15e6.jpg"></p><h2 id="虚拟化的特征和优势"><a href="#虚拟化的特征和优势" class="headerlink" title="虚拟化的特征和优势"></a>虚拟化的特征和优势</h2><p>从前面描述可知，虚拟化技术就是一个“大块的资源”逻辑分割成“具有独立功能的小块资源”，这个功能通过Hypervisor来实现。对于服务器领域而言，通过Hypervisor将一个物理服务器虚拟化成若干个小的逻辑服务器，每个逻辑服务器具有与物理服务器相同的功能，所有逻辑服务器的资源总和等于物理服务器的全部资源。</p><p>因此，运行在Hypervisor上的<strong>逻辑服务器</strong>，其本质就是由物理服务器上一个个文件组成。相对物理服务器，天生具备<strong>分区、隔离、封装</strong>和<strong>相对硬件独立</strong>四大特征。</p><p><img src="https://i.loli.net/2019/05/03/5ccbe0005eb06.jpg"></p><p><strong>1）分区：在单一物理服务器同时运行多个虚拟机。</strong>分区意味着虚拟化层为多个虚拟机划分服务器资源的能力；每个虚拟机可以同时运行一个单独的操作系统（相同或不同的操作系统），使您能够在一台服务器上运行多个应用程序。每个操作系统只能看到虚拟化层为其提供的“虚拟硬件”（虚拟网卡、CPU、内存等），以使它认为运行在自己的专用服务器上。</p><p><strong>2）隔离：在同一服务器虚拟机之间相互隔离。</strong>虚拟机是互相隔离的。例如：一个虚拟机的崩溃或故障（例如，操作系统故障、应用程序崩溃、驱动程序故障，等等）不会影响同一服务器上的其它虚拟机；一个虚拟机中的病毒、蠕虫等与其它虚拟机相隔离，就像每个虚拟机都位于单独的物理机器上一样。可以通过资源控制以提供性能隔离，比如：可以为每个虚拟机指定最小和最大资源使用量，以确保某个虚拟机不会占用所有的资源而使得同一系统中的其它虚拟机无资源可用；可以在单一机器上同时运行多个负载/应用程序/操作系统，而不会出现因为传统 x86 服务器体系结构的局限性发生DLL冲突等问题。</p><p><strong>3）封装：整个虚拟机都保存在文件中，可以通过移动文件的方式来迁移虚拟机。</strong>封装意味着将整个虚拟机（硬件配置、BIOS 配置、内存状态、磁盘状态、CPU 状态）储存在独立于物理硬件的一小组文件中。这样，只需复制几个文件就可以随时随地根据需要复制、保存和移动虚拟机。</p><p><strong>4）相对硬件独立：无需修改即可在任意服务器上运行（主要基于全虚技术的虚拟机，半虚技术的虚拟机只支持开源操作系统，如Linux）。</strong>因为虚拟机运行于虚拟化层之上，所以只能看到虚拟化层提供的虚拟硬件，无需关注物理服务器的情况。这样，虚拟机就可以在任何 x86 服务器（IBM、Dell、HP等）上运行而无需进行任何修改。这打破了操作系统和硬件以及应用程序和操作系统/硬件之间的约束。</p><p>物理资源在经过Hypervisor虚拟化后，在<strong>资源利用率、独立性、运行效率</strong>和<strong>安全性</strong>等方面与传统物理服务器相比均有不同的优势。</p><p><img src="https://i.loli.net/2019/05/03/5ccbe01b6cf2a.jpg"></p><p><strong>1）资源利用率：</strong>虚拟化前每台主机一个操作系统，系统的资源利用率低。虚拟化后，主机与操作系统不一一对应，按需分配使用，系统的资源利用率高。</p><p><strong>2）独立性：</strong>虚拟化前软硬件紧密结合，硬件成本高昂且不够灵活。虚拟化后，操作系统和硬件不相互依赖，虚拟机独立于硬件，能在任何硬件上运行。</p><p><strong>3）程序运行效率：</strong>虚拟化前同一台主机上同时运行多个程序容易产生冲突，运行效率较低。虚拟化后，操作系统和应用程序被封装成单一个体，不同个体间不冲突。同一台机器上运行多个程序，效率高。</p><p><strong>4）安全性：</strong>虚拟化前，故障影响范围大，安全性较差。虚拟化后，通过资源的池化，有强大的安全和故障隔离机制。</p><h2 id="虚拟化技术的发展"><a href="#虚拟化技术的发展" class="headerlink" title="虚拟化技术的发展"></a>虚拟化技术的发展</h2><p>最近几年，随着云计算技术广泛应用，虚拟化技术也被大家所关注。其实，虚拟化技术的出现要早于云计算技术约半个世纪。在上世纪60年代，虚拟化技术就已经在大型机上有所应用，在1999年小型机上出现逻辑分区的概念，这就是存储虚拟化的雏形。而到了2000年，在x86平台上VMware首先提出了平台虚拟化技术的概念，以及后续随着CPU速度越来越快，Intel和AMD分别在CPU指令架构中引入虚拟化指令，在服务器领域和数据中心范围内虚拟化技术得到的极大发展，从而催生了云计算技术的出现。可以说，<strong>虚拟化技术是云计算技术得以实现并推广落地的重要基石</strong>，同时，随着云计算技术的演进，虚拟化技术也同样在不断演进，从最早的计算虚拟化发展到目前的应用虚拟化，两者是一种相辅相成，螺旋式推进的关系。</p><p>云计算技术从诞生到当前，共经历了3个阶段，分别称为云计算1.0、云计算2.0和云计算3.0，在不同的阶段，虚拟化技术的表现形式和关注点也不相同，两者关系如下图所示：</p><p><img src="https://i.loli.net/2019/05/03/5ccbe03388332.jpg"></p><p><strong>在云计算1.0时代，主要是将传统IT硬件基础设施转换为虚拟化基础设施，来提升资源利用率。</strong>该阶段的关键特征体现为：<strong>通过计算虚拟化技术的引入</strong>，将企业IT应用与底层的基础设施彻底分离解耦，将多个企业IT应用实例及运行环境(客户机操作系统，GuestOS)复用在相同的物理服务器上，并通过虚拟化集群调度软件，将更多的IT应用复用在更少的服务器节点上，从而实现资源利用效率的提升。</p><p><strong>在云计算2.0时代，主要是向云租户提供池化资源服务和精细化自动管理，推动企业业务的云化演进。</strong>该阶段的关键特征体现为：<strong>不仅通过计算虚拟化完成CPU、内存、裸金属服务器等池化资源的集中管理和自动调度，同时引入存储虚拟化和网络虚拟化技术，实现数据中心内部存储资源和网络资源的池化集中管理和统一调度。</strong>面向内部和外部的租户，将原本需要通过数据中心管理员人工干预的基础设施资源复杂低效的申请、释放与配置过程，转变为一键式全自动化资源发放服务过程。这个阶段大幅提升了企业基础设施资源的快速敏捷发放能力，缩短了基础设施资源准备周期，实现资源的按需弹性供给。为企业核心业务走向敏捷，更好地应对瞬息万变的竞争与发展奠定了基础。云计算2.0阶段面向云租户的基础设施资源服务供给，可以是虚拟机形式，可以是容器(轻量化虚拟机)，也可以是物理机形式。该阶段的企业云化演进，暂时还不涉及基础设施层之上的IT应用与中间件、数据库软件架构的变化。</p><p><strong>在云计算3.0时代，面向应用开发者及管理维护者提供分布式微服务化应用架构和大数据智能化服务。</strong></p><p>该阶段的关键特征体现为：<strong>企业IT应用架构逐步开始去IOE化，依托开源增强、跨不同业务应用领域高度共享的数据库、中间件平台服务层以及功能更加轻量化解耦、数据与应用逻辑彻底分离的分布式无状态化架构</strong>，从而实现支撑企业业务敏捷化、智能化以及资源利用效率提升。</p><h2 id="数据中心内部虚拟化技术分类"><a href="#数据中心内部虚拟化技术分类" class="headerlink" title="数据中心内部虚拟化技术分类"></a>数据中心内部虚拟化技术分类</h2><p>目前，在数据中心内虚拟服务器、虚拟网络、虚拟存储、虚拟设备和其他“虚拟技术”等已对传统基础设施产生了逆袭。<strong>在上述云计算的三个阶段，使得虚拟化技术和云计算技术得到极大发展的关键就是2.0时代，主要的特征就是从计算虚拟化走向存储虚拟化和网络虚拟化。</strong></p><p><img src="https://i.loli.net/2019/05/03/5ccbe05131c70.jpg"></p><p>从支撑云计算按需、弹性分配资源，与硬件解耦的虚拟化技术的角度来看，云计算早期阶段主要聚焦在计算虚拟化领域。事实上，计算虚拟化技术早在IBM 370时代就已经在其大型机操作系统上诞生。技术原理是通过在OS与裸机硬件之间插入虚拟化层，来在裸机硬件指令系统之上仿真模拟出多个370大型机的“运行环境”，使得上层“误认为”自己运行在一个独占系统之上，实际上是由计算虚拟化引擎在多个虚拟机之间进行CPU分时调度，同时对内存、I/O、网络等访问也进行访问屏蔽。</p><p>后来，当x86平台演进成为在IT领域硬件平台的主流之后，VMware ESX、XEN、KVM等依托于单机OS的计算虚拟化技术才将IBM 370的虚拟化机制在x86服务器的硬件体系架构下实现，并且在单机/单服务器虚拟化的基础上引入了具备虚拟机动态迁移和HA调度能力的中小集群管理软件，比如：VMware的vCenter/vSphere、Citrix的XEN Center和华为的FusionSphere等，从而形成当前的计算虚拟化主体。</p><p><img src="https://i.loli.net/2019/05/03/5ccbe06505e42.jpg"></p><p>与此同时，作为数据信息持久化载体的存储已经逐步从服务器计算中剥离出来，与必不可少的CPU计算能力一样，在数据中心发挥着至关重要的作用。现在数据中心内部不再封闭，内部服务器互访和对外部互联网访问需求，使得存储和网络也同计算一样，成为数据中心IT基础设施不可或缺的“<strong>三大要素</strong>”。就数据中心端到端基础设施解决方案而言，不仅需要计算资源的按需分配、弹性伸缩、与硬件解耦的需求，对存储资源和网络资源需求同样如此，因此，存储虚拟化和网络虚拟化技术应运而生。</p><p>对于普通x86服务器来说，CPU和内存资源虚拟化后再将其以vCPU/vMemory的方式，按需供给用户/租户使用。计算虚拟化中仅存在资源池的“大分小”的问题。然而对于存储来说，由于硬盘的容量有限，客户/租户对数据容量的需求越来越大，因此必须对数据中心内多个分布式服务器存储资源，比如：服务器内的存储资源、外置SAN/NAS等进行“小聚大”的整合，组成<strong>存储资源池</strong>。</p><p>这个存储资源池，可能是单一厂家提供的同构资源池，也可以是被<strong>存储虚拟化层</strong>整合成为跨多厂家异构的统一资源池。各种存储资源池均能以统一的<strong>块存储、对象存储</strong>或者<strong>文件存储格式</strong>进行访问。数据存储虚拟化示意图如下所示：</p><p><img src="https://i.loli.net/2019/05/03/5ccbe07957b2d.jpg"></p><p>对于数据中心网络来说，网络对于业务应用，作为连接服务器节点的计算和存储资源是一种实实在在的资源需求。传统数据中心内部，网络交换功能都是在物理交换机和路由器设备上完成的，网络功能对上层业务应用而言仅仅体现为一个一个被通信链路连接起来的孤立的“盒子”，无法动态感知来自上层业务的网络功能需求，完全需要人工配置的方式来实现对业务层网络组网与安全隔离策略的需要。</p><p>在云时代多租户虚拟化的环境下，不同租户对于边缘的路由及网关设备的配置管理需求也存在极大的差异化，即使物理路由器和防火墙自身的多实例能力也无法满足云环境下租户数量的要求，如果采用与租户数量等量的路由器与防火墙设备，成本上无法接受。于是，伯克利大学的Nick Mckeown教授提出将网络自身的功能从专用封闭平台迁移到服务器通用x86平台上来，SDN概念从此诞生。</p><p>网络资源虚拟化后，服务器节点的应用VM连接差异化，就可由云操作系统来自动化地创建和销毁，并通过一次性建立起来的物理网络连接矩阵，进行任意两个网络端节点之间的虚拟通讯链路建立，以及必要的安全隔离保障，从而实现业务驱动的网络自动化管理配置，大幅度降低数据中心网络管理的复杂度。从资源利用率来看，任意两个虚拟网络节点之间的流量带宽，都需要通过物理网络来交换和承载，只要不超过物理网络的资源配额上限（一般建议物理网络按照无阻塞的CLOS模式来设计实施)，一旦虚拟节点被释放，其所对应的网络带宽占用也将被同步释放，因此也就相当于实现对物理网络资源的<strong>最大限度的“网络资源动态共享”</strong>。通俗点讲，网络虚拟化让多个盒子式的网络实体第一次以一个统一整合的“<strong>网络资源池</strong>”的形态，出现在业务应用层面前，同时与计算和存储资源之间，也有了统一协同机制。网络虚拟化示意图如下图所示：</p><p><img src="https://i.loli.net/2019/05/03/5ccbe090e8fd7.jpg"></p><p><strong>上面基础设施虚拟化技术的“三要素”是电信云领域需要重点关注的三个分类，属于云计算中IaaS服务部分的内容。</strong></p><p><strong><em>除此之外，还有基于PaaS和SaaS的桌面虚拟化技术，这部分内容因电信云领域目前不涉及，因此在本站的云计算分类中会有相关介绍，这里不再赘述。后续，会在NFV关键技术分类中按照计算虚拟化、存储虚拟化和网络虚拟化三大部分逐一介绍，并会重点KVM的部署和性能调优。</em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;DPDK技术奠定了NFV领域数据包转发性能提升的基础，那么软硬件解耦后，在通用服务器上实现各功能网元，资源层面的隔离和共生问题就需要虚拟化技术来解决。虚拟化使用软件的方法重新定义划分IT资源，可以实现IT资源的动态分配、灵活调度、跨域共享，提高IT资源利用率，使IT资源能够真正成为社会基础设施，服务于各行各业中灵活多变的应用需求。
    
    </summary>
    
      <category term="NFV关键技术" scheme="https://kkutysllb.cn/categories/NFV%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="电信云" scheme="https://kkutysllb.cn/tags/%E7%94%B5%E4%BF%A1%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>2019-05-02-Linux系统命令-第七篇《磁盘和文件系统管理命令》</title>
    <link href="https://kkutysllb.cn/2019/05/02/2019-05-02-Linux%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4-%E7%AC%AC%E4%B8%83%E7%AF%87%E3%80%8A%E7%A3%81%E7%9B%98%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4%E3%80%8B/"/>
    <id>https://kkutysllb.cn/2019/05/02/2019-05-02-Linux系统命令-第七篇《磁盘和文件系统管理命令》/</id>
    <published>2019-05-02T12:27:07.000Z</published>
    <updated>2019-05-02T12:56:05.995Z</updated>
    
    <content type="html"><![CDATA[<h2 id="fdisk：磁盘分区工具"><a href="#fdisk：磁盘分区工具" class="headerlink" title="fdisk：磁盘分区工具"></a>fdisk：磁盘分区工具</h2><p>fdisk是Linux下常用的磁盘分区工具。受mbr分区表的限制，fdisk工具只能给小于2TB的磁盘划分分区。如果使用fdisk对大于2TB的磁盘进行分区，虽然可以分区，但其仅识别2TB的空间，所以磁盘容量若超过2TB，就要使用parted分区工具（后面会讲）进行分区。<a id="more"></a></p><p><strong>语法格式：fdisk [option] [device]</strong></p><p><strong>重要参数选项</strong></p><p><img src="https://i.loli.net/2019/05/02/5ccae26095c66.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）显示系统磁盘分区列表</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ~]<span class="comment"># fdisk -l</span></span><br><span class="line">Disk /dev/sda: 53.7 GB, 53687091200 bytes, 104857600 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label <span class="built_in">type</span>: dos</span><br><span class="line">Disk identifier: 0x000d2190</span><br><span class="line">Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sda1   *        2048      821247      409600   83  Linux</span><br><span class="line">/dev/sda2          821248    17598463     8388608   82  Linux swap / Solaris</span><br><span class="line">/dev/sda3        17598464   104857599    43629568   83  Linux</span><br></pre></td></tr></table></figure><p>上述信息每列功能说明具体如下：</p><ul><li>Device：分区，这里有三个分区；</li><li>Boot：启动分区，用*表示的是启动分区；</li><li>Start：表示开始的柱面；</li><li>End：表示结束的柱面；</li><li>Blocks：block块数量；</li><li>Id：分区类型Id；</li><li>System：分区类型</li></ul><p><strong>2）模拟添加第二块磁盘</strong></p><p>#给C7 Server01再挂载一块20G的磁盘</p><p><img src="https://i.loli.net/2019/05/02/5ccae29766516.jpg"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重启系统检查磁盘分区状态</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># fdisk -l</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新添加的磁盘为/devsdb，表示sata接口的第二块磁盘</span></span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line"></span><br><span class="line">Disk /dev/sda: 53.7 GB, 53687091200 bytes, 104857600 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label <span class="built_in">type</span>: dos</span><br><span class="line">Disk identifier: 0x000d2190</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sda1   *        2048      821247      409600   83  Linux</span><br><span class="line">/dev/sda2          821248    17598463     8388608   82  Linux swap / Solaris</span><br><span class="line">/dev/sda3        17598464   104857599    43629568   83  Linux</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不想显示其他分区，还可以指定分区查看</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># fdisk -l /dev/sdb</span></span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br></pre></td></tr></table></figure><p><strong>3）交互式分区实战</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前系统的分区设备信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ls -l /dev/sd*</span></span><br><span class="line">brw-rw---- 1 root disk 8,  0 May  2 09:41 /dev/sda</span><br><span class="line">brw-rw---- 1 root disk 8,  1 May  2 09:41 /dev/sda1</span><br><span class="line">brw-rw---- 1 root disk 8,  2 May  2 09:41 /dev/sda2</span><br><span class="line">brw-rw---- 1 root disk 8,  3 May  2 09:41 /dev/sda3</span><br><span class="line">brw-rw---- 1 root disk 8, 16 May  2 09:41 /dev/sdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对/dev/sdb进行交互式分区</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># fdisk /dev/sdb</span></span><br><span class="line">Welcome to fdisk (util-linux 2.23.2).</span><br><span class="line"></span><br><span class="line">Changes will remain <span class="keyword">in</span> memory only, until you decide to write them.</span><br><span class="line">Be careful before using the write <span class="built_in">command</span>.</span><br><span class="line"></span><br><span class="line">Device does not contain a recognized partition table</span><br><span class="line">Building a new DOS disklabel with disk identifier 0xc0a89c6e.</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): m     <span class="comment"># 输入m，打印帮助信息</span></span><br><span class="line">Command action</span><br><span class="line">   a   toggle a bootable flag    <span class="comment"># 设置引导扇区</span></span><br><span class="line">   b   edit bsd disklabel     <span class="comment"># 编辑bsd卷标</span></span><br><span class="line">   c   toggle the dos compatibility flag   <span class="comment"># 设置dos兼容分区</span></span><br><span class="line">   d   delete a partition    <span class="comment"># 删除一个分区</span></span><br><span class="line">   g   create a new empty GPT partition table    <span class="comment"># 创建一个新的且为空的GPT分区表</span></span><br><span class="line">   G   create an IRIX (SGI) partition table   <span class="comment"># 创建一些IRIX分区表</span></span><br><span class="line">   l   list known partition types    <span class="comment"># 查看分区类型对应的编号列表</span></span><br><span class="line">   m   <span class="built_in">print</span> this menu   <span class="comment"># 打印帮助菜单</span></span><br><span class="line">   n   add a new partition   <span class="comment"># 新建一个分区</span></span><br><span class="line">   o   create a new empty DOS partition table    <span class="comment"># 创建一个新的空的DOS分区表</span></span><br><span class="line">   p   <span class="built_in">print</span> the partition table   <span class="comment"># 打印分区表</span></span><br><span class="line">   q   quit without saving changes    <span class="comment"># 退出且不保存更改</span></span><br><span class="line">   s   create a new empty Sun disklabel  <span class="comment"># 创建一个新的空的sun卷标</span></span><br><span class="line">   t   change a partition<span class="string">'s system id  # 更改分区系统的id</span></span><br><span class="line"><span class="string">   u   change display/entry units  # 改变/显示条目的单位</span></span><br><span class="line"><span class="string">   v   verify the partition table   # 验证分区表</span></span><br><span class="line"><span class="string">   w   write table to disk and exit  # 将操作写入分区表并退出程序</span></span><br><span class="line"><span class="string">   x   extra functionality (experts only)   # 额外的功能</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Command (m for help): n   # 输入n，创建一个分区</span></span><br><span class="line"><span class="string">Partition type:</span></span><br><span class="line"><span class="string">   p   primary (0 primary, 0 extended, 4 free)  # 创建主分区，编号1-4</span></span><br><span class="line"><span class="string">   e   extended   # 创建扩展分区</span></span><br><span class="line"><span class="string">Select (default p): p   # 输入p，创建主分区</span></span><br><span class="line"><span class="string">Partition number (1-4, default 1): 1  # 输入1，设置第一个主分区编号为1</span></span><br><span class="line"><span class="string">First sector (2048-41943039, default 2048):   # 直接回车，默认采用2048作为起始柱面</span></span><br><span class="line"><span class="string">Using default value 2048</span></span><br><span class="line"><span class="string">Last sector, +sectors or +size&#123;K,M,G&#125; (2048-41943039, default 41943039): +5G     # 设置结束柱面，一般情况下如果整个磁盘采用一个分区，这里就直接回车就行，否则，采用+size的方式进行分区大小设置，我们这里给第一个分区设置5G的空间    </span></span><br><span class="line"><span class="string">Partition 1 of type Linux and of size 5 GiB is set</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Command (m for help): p   # 输入p，打印刚创建的分区信息</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Disk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectors</span></span><br><span class="line"><span class="string">Units = sectors of 1 * 512 = 512 bytes</span></span><br><span class="line"><span class="string">Sector size (logical/physical): 512 bytes / 512 bytes</span></span><br><span class="line"><span class="string">I/O size (minimum/optimal): 512 bytes / 512 bytes</span></span><br><span class="line"><span class="string">Disk label type: dos</span></span><br><span class="line"><span class="string">Disk identifier: 0xc0a89c6e</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   Device Boot      Start         End      Blocks   Id  System</span></span><br><span class="line"><span class="string">/dev/sdb1            2048    10487807     5242880   83  Linux</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Command (m for help):  # 重复上述步骤再次创建三个主分区，大家自己练习，注意全部完成后要按w保存，否则分区信息丢失</span></span><br><span class="line"><span class="string">。。。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 打印最终的分区信息</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[root@C7-Server01 ~]# fdisk -l /dev/sdb</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Disk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectors</span></span><br><span class="line"><span class="string">Units = sectors of 1 * 512 = 512 bytes</span></span><br><span class="line"><span class="string">Sector size (logical/physical): 512 bytes / 512 bytes</span></span><br><span class="line"><span class="string">I/O size (minimum/optimal): 512 bytes / 512 bytes</span></span><br><span class="line"><span class="string">Disk label type: dos</span></span><br><span class="line"><span class="string">Disk identifier: 0xc0a89c6e</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   Device Boot      Start         End      Blocks   Id  System</span></span><br><span class="line"><span class="string">/dev/sdb1            2048    10487807     5242880   83  Linux</span></span><br><span class="line"><span class="string">/dev/sdb2        10487808    20973567     5242880   83  Linux</span></span><br><span class="line"><span class="string">/dev/sdb3        20973568    31459327     5242880   83  Linux</span></span><br><span class="line"><span class="string">/dev/sdb4        31459328    41943039     5241856   83  Linux</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 不重启情况下通知内核新的分区表已生效</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[root@C7-Server01 ~]# partprobe /dev/sdb</span></span><br></pre></td></tr></table></figure><p><strong>需要注意一点：用交互指令d删除分区时要小心，要注意分区的序号，如果删除了扩展分区，那么扩展分区之下的逻辑分区都会删除，所以操作时一定要小心。如果不小心操作错了，直接使用交互指令q不保存退出，这样先前的操作就会无效。如果输入w（保存指令）则会保存所有修改。</strong></p><p><strong>4）非交互式分区</strong></p><p>上面的示例是交互式分区，有时需要在脚本中自动执行分区，这时需要非交互式分区。如果使用fdisk分区工具来完成，可以使用如下两种办法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先备份/dev/sdb分区表信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># dd if=/dev/sdb of=sdb-partb.info bs=1 count=512</span></span><br><span class="line">512+0 records <span class="keyword">in</span></span><br><span class="line">512+0 records out</span><br><span class="line">512 bytes (512 B) copied, 0.00159899 s, 320 kB/s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后清除分区数据</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># dd if=/dev/zero of=/dev/sdb bs=1 count=512</span></span><br><span class="line">512+0 records <span class="keyword">in</span></span><br><span class="line">512+0 records out</span><br><span class="line">512 bytes (512 B) copied, 0.0017926 s, 286 kB/s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看/dev/sdb分区信息，确认是否被清除</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># fdisk -l /dev/sdb</span></span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法一：使用echo指令模拟交互式分区输入过程，自动执行分区</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此方法需要注意最后一次分区时不要输入+size大小，直接回车即可（虚拟机虚拟磁盘原因，在物理机上无此限制）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 脚本中p就是指主分区，如果要分扩展分区，将p改为m</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># echo -e "n\np\n1\n\n+5G\nw\n" | fdisk /dev/sdb</span></span><br><span class="line">...</span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># echo -e "n\np\n2\n\n+5G\nw\n" | fdisk /dev/sdb</span></span><br><span class="line">...</span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># echo -e "n\np\n3\n\n+5G\nw\n" | fdisk /dev/sdb</span></span><br><span class="line">...</span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># echo -e "n\np\n4\n\n\nw\n" | fdisk /dev/sdb</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看分区信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># fdisk -l /dev/sdb</span></span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label <span class="built_in">type</span>: dos</span><br><span class="line">Disk identifier: 0xd0b6c715</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sdb1            2048    10487807     5242880   83  Linux</span><br><span class="line">/dev/sdb2        10487808    20973567     5242880   83  Linux</span><br><span class="line">/dev/sdb3        20973568    31459327     5242880   83  Linux</span><br><span class="line">/dev/sdb4        31459328    41943039     5241856   83  Linux</span><br></pre></td></tr></table></figure><p><strong>方法二：也是模拟交互式分区的过程，将输入的交互式指令写入一个文本文件，然后通过标准输入的方式传递给fdisk /dev/sdb指令，其中交互式指令中回车在文本中用换行替代。与上面的实现方式类似，请大家自行练习。</strong></p><h2 id="partprobe：更新内核的硬盘分区表信息"><a href="#partprobe：更新内核的硬盘分区表信息" class="headerlink" title="partprobe：更新内核的硬盘分区表信息"></a>partprobe：更新内核的硬盘分区表信息</h2><p>partprobe命令用于在硬盘分区发生改变时，更新Linux内核中的硬盘分区表数据。有时在使用fdisk、part命令对硬盘进行分区后，会发现找不到新分区，此时需要重启系统才能使修改生效，但使用partprobe可以不重启系统就让修改的分区表生效。</p><p><strong>语法格式：partprobe [option]</strong> </p><p><strong>重要参数选项</strong></p><p><img src="https://i.loli.net/2019/05/02/5ccae336aa7df.jpg"></p><p><strong>【使用示例】</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新分区表信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最好加上具体的磁盘，否则可能会报错，那就只能重启系统</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># partprobe /dev/sdb</span></span><br></pre></td></tr></table></figure><h2 id="parted：磁盘分区工具"><a href="#parted：磁盘分区工具" class="headerlink" title="parted：磁盘分区工具"></a>parted：磁盘分区工具</h2><p>对于小于2TB的磁盘可以用fdisk和parted命令进行分区，这种情况一般采用fdisk命令，但对于大于2TB的磁盘则只能用parted分区，且需要将磁盘转换为GPT格式。</p><p><strong>语法格式：parted [option] [device]</strong></p><p><strong>重要参数选项</strong></p><p><img src="https://i.loli.net/2019/05/02/5ccae373158e0.jpg"></p><p><strong>【分区命令】</strong></p><p><strong>通过parted -h或直接parted进入交互模式后，输入h查看帮助信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ~]<span class="comment"># parted -h</span></span><br><span class="line">Usage: parted [OPTION]... [DEVICE [COMMAND [PARAMETERS]...]...]</span><br><span class="line">Apply COMMANDs with PARAMETERS to DEVICE.  If no COMMAND(s) are given, run <span class="keyword">in</span></span><br><span class="line">interactive mode.</span><br><span class="line">OPTIONs:</span><br><span class="line">-h, --<span class="built_in">help</span>                      displays this <span class="built_in">help</span> message</span><br><span class="line">-l, --list                      lists partition layout on all block devices</span><br><span class="line">-m, --machine                   displays machine parseable output</span><br><span class="line">-s, --script                    never prompts <span class="keyword">for</span> user intervention</span><br><span class="line">-v, --version                   displays the version</span><br><span class="line">-a, --align=[none|cyl|min|opt]  alignment <span class="keyword">for</span> new partitions</span><br><span class="line">COMMANDs:</span><br><span class="line">align-check TYPE N                        check partition N <span class="keyword">for</span> TYPE(min|opt)</span><br><span class="line">alignment</span><br><span class="line"><span class="built_in">help</span> [COMMAND]                           <span class="built_in">print</span> general <span class="built_in">help</span>, or <span class="built_in">help</span> on</span><br><span class="line">COMMAND</span><br><span class="line">mklabel,mktable LABEL-TYPE               create a new disklabel (partition</span><br><span class="line">table)</span><br><span class="line">mkpart PART-TYPE [FS-TYPE] START END     make a partition</span><br><span class="line">name NUMBER NAME                         name partition NUMBER as NAME</span><br><span class="line"><span class="built_in">print</span> [devices|free|list,all|NUMBER]     display the partition table,</span><br><span class="line">available devices, free space, all found partitions, or a particular</span><br><span class="line">partition</span><br><span class="line">quit                                     <span class="built_in">exit</span> program</span><br><span class="line">rescue START END                         rescue a lost partition near START</span><br><span class="line">and END</span><br><span class="line">resizepart NUMBER END                    resize partition NUMBER</span><br><span class="line">rm NUMBER                                delete partition NUMBER</span><br><span class="line">select DEVICE                            choose the device to edit</span><br><span class="line">disk_set FLAG STATE                      change the FLAG on selected device</span><br><span class="line">disk_toggle [FLAG]                       toggle the state of FLAG on selected</span><br><span class="line">device</span><br><span class="line"><span class="built_in">set</span> NUMBER FLAG STATE                    change the FLAG on partition NUMBER</span><br><span class="line">toggle [NUMBER [FLAG]]                   toggle the state of FLAG on partition</span><br><span class="line">NUMBER</span><br><span class="line">unit UNIT                                <span class="built_in">set</span> the default unit to UNIT</span><br><span class="line">version                                  display the version number and</span><br><span class="line">copyright information of GNU Parted</span><br><span class="line">Report bugs to bug-parted@gnu.org</span><br></pre></td></tr></table></figure><p><strong>【使用示例】</strong></p><p><strong>1）显示分区的情况</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ~]<span class="comment"># parted -l</span></span><br><span class="line">Model: ATA VMware Virtual S (scsi)</span><br><span class="line">Disk /dev/sda: 53.7GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: msdos</span><br><span class="line">Disk Flags: </span><br><span class="line">Number  Start   End     Size    Type     File system     Flags</span><br><span class="line">1      1049kB  420MB   419MB   primary  xfs             boot</span><br><span class="line">2      420MB   9010MB  8590MB  primary  linux-swap(v1)</span><br><span class="line">3      9010MB  53.7GB  44.7GB  primary  xfs</span><br><span class="line">Model: ATA VMware Virtual S (scsi)</span><br><span class="line">Disk /dev/sdb: 21.5GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: msdos</span><br><span class="line">Disk Flags: </span><br><span class="line">Number  Start   End     Size    Type     File system  Flags</span><br><span class="line">1      1049kB  5370MB  5369MB  primary</span><br><span class="line">2      5370MB  10.7GB  5369MB  primary</span><br><span class="line">3      10.7GB  16.1GB  5369MB  primary</span><br><span class="line">4      16.1GB  21.5GB  5368MB  primary</span><br></pre></td></tr></table></figure><p>上述信息显示系统两块磁盘的分区信息，包括大小，起始，终止柱面，类型，文件系统类型等。磁盘/dev/sda为系统盘，有3个主分区，其中2个位xfs文件系统，1个位swap分区。磁盘/dev/sdb为刚添加的数据盘，有4个主分区，每个大小5G，因为还没有格式化，所以没有文件系统格式。</p><p><strong>2）通过给虚拟机再挂载一块100G的磁盘/dev/sdc，来模拟2TB磁盘用parted分区工具进行分区</strong></p><p><img src="https://i.loli.net/2019/05/02/5ccae3c2d6d94.jpg"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过交互式方式完成分区</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># parted /dev/sdc</span></span><br><span class="line">GNU Parted 3.1</span><br><span class="line">Using /dev/sdc</span><br><span class="line">Welcome to GNU Parted! Type <span class="string">'help'</span> to view a list of commands.</span><br><span class="line">(parted) mklabel gpt           <span class="comment"># 为/dev/sdc磁盘创建GPT分区，大于2T的磁盘必须进行这一步</span></span><br><span class="line">(parted) mkpart primary 0 40G  <span class="comment"># 创建主分区，大小为40G</span></span><br><span class="line">Warning: The resulting partition is not properly aligned <span class="keyword">for</span> best performance.</span><br><span class="line">Ignore/Cancel? Ignore            <span class="comment"># 输入Ignore，忽略告警信息</span></span><br><span class="line">(parted) p                 <span class="comment"># 输入p，显示分区表信息                                               </span></span><br><span class="line">Model: ATA VMware Virtual S (scsi)</span><br><span class="line">Disk /dev/sdc: 107GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line">Disk Flags: </span><br><span class="line"></span><br><span class="line">Number  Start   End     Size    File system  Name     Flags</span><br><span class="line"> 1      17.4kB  40.0GB  40.0GB               primary                  <span class="comment"># 第一个主分区已经创建完毕</span></span><br><span class="line">(parted) mkpart logical 40G 50G    <span class="comment"># 创建第一个逻辑分区，大小为10G</span></span><br><span class="line">(parted) p                          <span class="comment">#  打印分区表信息                                      </span></span><br><span class="line">Model: ATA VMware Virtual S (scsi)</span><br><span class="line">Disk /dev/sdc: 107GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line">Disk Flags: </span><br><span class="line"></span><br><span class="line">Number  Start   End     Size    File system  Name     Flags</span><br><span class="line"> 1      17.4kB  40.0GB  40.0GB               primary</span><br><span class="line"> 2      40.0GB  50.0GB  10.0GB               logical                        <span class="comment"># 第一个逻辑分区创建完毕</span></span><br><span class="line">(parted) mkpart logical 50G 70G    <span class="comment"># 创建第二个逻辑分区，大小为20G</span></span><br><span class="line">(parted) mkpart logical 70G 100G   <span class="comment"># 创建第三个逻辑分区，大小为30G                                       </span></span><br><span class="line">(parted) p                       <span class="comment"># 打印分区表信息                                         </span></span><br><span class="line">Model: ATA VMware Virtual S (scsi)</span><br><span class="line">Disk /dev/sdc: 107GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line">Disk Flags: </span><br><span class="line"></span><br><span class="line">Number  Start   End     Size    File system  Name     Flags</span><br><span class="line"> 1      17.4kB  40.0GB  40.0GB               primary</span><br><span class="line"> 2      40.0GB  50.0GB  10.0GB               logical</span><br><span class="line"> 3      50.0GB  70.0GB  20.0GB               logical</span><br><span class="line"> 4      70.0GB  100GB   30.0GB               logical</span><br><span class="line">(parted) quit                                          <span class="comment"># 退出                   </span></span><br><span class="line">Information: You may need to update /etc/fstab.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看系统设备信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ll -h /dev/sd*</span></span><br><span class="line">brw-rw---- 1 root disk 8,  0 May  2 11:51 /dev/sda</span><br><span class="line">brw-rw---- 1 root disk 8,  1 May  2 11:51 /dev/sda1</span><br><span class="line">brw-rw---- 1 root disk 8,  2 May  2 11:51 /dev/sda2</span><br><span class="line">brw-rw---- 1 root disk 8,  3 May  2 11:51 /dev/sda3</span><br><span class="line">brw-rw---- 1 root disk 8, 16 May  2 11:51 /dev/sdb</span><br><span class="line">brw-rw---- 1 root disk 8, 17 May  2 11:51 /dev/sdb1</span><br><span class="line">brw-rw---- 1 root disk 8, 18 May  2 11:51 /dev/sdb2</span><br><span class="line">brw-rw---- 1 root disk 8, 19 May  2 11:51 /dev/sdb3</span><br><span class="line">brw-rw---- 1 root disk 8, 20 May  2 11:51 /dev/sdb4</span><br><span class="line">brw-rw---- 1 root disk 8, 32 May  2 12:01 /dev/sdc</span><br><span class="line">brw-rw---- 1 root disk 8, 33 May  2 12:01 /dev/sdc1</span><br><span class="line">brw-rw---- 1 root disk 8, 34 May  2 12:01 /dev/sdc2</span><br><span class="line">brw-rw---- 1 root disk 8, 35 May  2 12:01 /dev/sdc3</span><br><span class="line">brw-rw---- 1 root disk 8, 36 May  2 12:01 /dev/sdc4</span><br></pre></td></tr></table></figure><p><strong><em>用parted磁盘分区工具非交互式创建分区的方法类似fdisk，唯一区别就是将交互式下输入的命令作为参数传递parted工具，比如：将交互执行的命令直接放在parted /dev/sdb后面就实现非交互分区了。整体上实现其实比fdisk工具简单，请大家自行练习。</em></strong> </p><h2 id="mkfs：创建Linux文件系统-（格式化）"><a href="#mkfs：创建Linux文件系统-（格式化）" class="headerlink" title="mkfs：创建Linux文件系统 （格式化）"></a>mkfs：创建Linux文件系统 （格式化）</h2><p>mkfs命令用于在指定的设备（或硬盘分区等）上格式化并创建文件系统，fdisk和parted等分区工具相当于建房的人，把房子（硬盘），分成几居室（分区），mkfs就相当于对不同的居室装修（创建文件系统）了，只有装修好的房子（有文件系统）才能入住，分区也是一样，只有格式化创建文件系统（存取数据的机制）后，才能用来存取数据。</p><p><strong>mkfs只是一个前端命令，它通过-t参数指定文件系统类型后会调用相应的命令mkfs.fstype。因此，也可以直接使用mkfs.ext4、mkfs.xfs这类命令创建相应的文件系统。</strong></p><p><strong>语法格式：mkfs [option] [filesys]</strong></p><p><strong>重要参数选项</strong></p><p><img src="https://i.loli.net/2019/05/02/5ccae3fee7aba.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>通过-t选项创建xfs文件系统和ext4文件系统</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建/dev/sdb1分区的文件系统为xfs</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># mkfs -t xfs /dev/sdb1</span></span><br><span class="line">meta-data=/dev/sdb1              isize=512    agcount=4, agsize=327680 blks</span><br><span class="line">=                       sectsz=512   attr=2, projid32bit=1</span><br><span class="line">=                       crc=1        finobt=0, sparse=0</span><br><span class="line">data     =                       bsize=4096   blocks=1310720, imaxpct=25</span><br><span class="line">=                       sunit=0      swidth=0 blks</span><br><span class="line">naming   =version 2              bsize=4096   ascii-ci=0 ftype=1</span><br><span class="line"><span class="built_in">log</span>      =internal <span class="built_in">log</span>           bsize=4096   blocks=2560, version=2</span><br><span class="line">=                       sectsz=512   sunit=0 blks, lazy-count=1</span><br><span class="line">realtime =none                   extsz=4096   blocks=0, rtextents=0</span><br></pre></td></tr></table></figure><p><strong><em>确认是否创建成功</em></strong></p><p><img src="https://i.loli.net/2019/05/02/5ccae42a1b479.jpg"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用mkfs.xfs创建/dev/sdb2的文件系统为xfs</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># mkfs.xfs /dev/sdb2</span></span><br><span class="line">meta-data=/dev/sdb2              isize=512    agcount=4, agsize=327680 blks</span><br><span class="line">=                       sectsz=512   attr=2, projid32bit=1</span><br><span class="line">=                       crc=1        finobt=0, sparse=0</span><br><span class="line">data     =                       bsize=4096   blocks=1310720, imaxpct=25</span><br><span class="line">=                       sunit=0      swidth=0 blks</span><br><span class="line">naming   =version 2              bsize=4096   ascii-ci=0 ftype=1</span><br><span class="line"><span class="built_in">log</span>      =internal <span class="built_in">log</span>           bsize=4096   blocks=2560, version=2</span><br><span class="line">=                       sectsz=512   sunit=0 blks, lazy-count=1</span><br><span class="line">realtime =none                   extsz=4096   blocks=0, rtextents=0</span><br></pre></td></tr></table></figure><p><strong><em>再次确认</em></strong></p><p><img src="https://i.loli.net/2019/05/02/5ccae4502e412.jpg"></p><p><strong>创建ext4文件系统的方法类似，请大家自行练习。</strong> </p><h2 id="dumpe2fs：导出ext2-ext3-ext4文件系统信息"><a href="#dumpe2fs：导出ext2-ext3-ext4文件系统信息" class="headerlink" title="dumpe2fs：导出ext2/ext3/ext4文件系统信息"></a>dumpe2fs：导出ext2/ext3/ext4文件系统信息</h2><p>dumpe2fs命令用于导出ext2/ext3/ext4文件系统内部的相关信息，例如：文件系统的组成包含超级快、块组、inode、block等信息。<strong>如果要导出xfs文件系统的信息，需要使用xfs_info指令</strong>。</p><p><strong>语法格式：dumpe2fs [option] [device]</strong></p><p><strong>重要参数选项</strong></p><p><img src="https://i.loli.net/2019/05/02/5ccae470c6349.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）查看分区文件系统的inode信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建/dev/sdb3分区为ext4文件系统格式</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># mkfs.ext4 /dev/sdb3</span></span><br><span class="line">mke2fs 1.42.9 (28-Dec-2013)</span><br><span class="line">Filesystem label=</span><br><span class="line">OS <span class="built_in">type</span>: Linux</span><br><span class="line">Block size=4096 (<span class="built_in">log</span>=2)</span><br><span class="line">Fragment size=4096 (<span class="built_in">log</span>=2)</span><br><span class="line">Stride=0 blocks, Stripe width=0 blocks</span><br><span class="line">327680 inodes, 1310720 blocks</span><br><span class="line">65536 blocks (5.00%) reserved <span class="keyword">for</span> the super user</span><br><span class="line">First data block=0</span><br><span class="line">Maximum filesystem blocks=1342177280</span><br><span class="line">40 block groups</span><br><span class="line">32768 blocks per group, 32768 fragments per group</span><br><span class="line">8192 inodes per group</span><br><span class="line">Superblock backups stored on blocks: </span><br><span class="line">32768, 98304, 163840, 229376, 294912, 819200, 884736</span><br><span class="line"></span><br><span class="line">Allocating group tables: <span class="keyword">done</span>                            </span><br><span class="line">Writing inode tables: <span class="keyword">done</span>                            </span><br><span class="line">Creating journal (32768 blocks): <span class="keyword">done</span></span><br><span class="line">Writing superblocks and filesystem accounting information: <span class="keyword">done</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出/dev/sdb3分区的中inode相关信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># dumpe2fs /dev/sdb3 | egrep -i "inode size|inode count"</span></span><br><span class="line">dumpe2fs 1.42.9 (28-Dec-2013)</span><br><span class="line">Inode count:              327680</span><br><span class="line">Inode size:          256</span><br></pre></td></tr></table></figure><p><strong>2）在xfs文件系统下，使用xfs_info指令查看/dev/sdb1的inode信息和block信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先需要个/dev/sdb1分区设置一个挂载点，然后使用xfs_info + 挂载点的方式进行查看</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># mount /dev/sdb1 ~/mydata/</span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># xfs_info ~/mydata/</span></span><br><span class="line">meta-data=/dev/sdb1              isize=512    agcount=4, agsize=327680 blks</span><br><span class="line">=                       sectsz=512   attr=2, projid32bit=1</span><br><span class="line">=                       crc=1        finobt=0 spinodes=0</span><br><span class="line">data     =                       bsize=4096   blocks=1310720, imaxpct=25</span><br><span class="line">=                       sunit=0      swidth=0 blks</span><br><span class="line">naming   =version 2              bsize=4096   ascii-ci=0 ftype=1</span><br><span class="line"><span class="built_in">log</span>      =internal               bsize=4096   blocks=2560, version=2</span><br><span class="line">=                       sectsz=512   sunit=0 blks, lazy-count=1</span><br><span class="line">realtime =none                   extsz=4096   blocks=0, rtextents=0</span><br></pre></td></tr></table></figure><h2 id="fsck：检查并修复Linux文件系统"><a href="#fsck：检查并修复Linux文件系统" class="headerlink" title="fsck：检查并修复Linux文件系统"></a>fsck：检查并修复Linux文件系统</h2><p>fsck命令用于检查并修复文件系统中的错误，即针对有问题的系统或磁盘进行修复，类似的命令还有e2fsck命令。有关fsck的使用需要特别注意的是：1）文件系统必须是卸载状态，否则可能会出现故障。2）不要对正常的分区使用fsck，在不加参数的情况下，fsck会根据/etc/fstab进行文件系统检查，这相当于fsck-As参数的功能。</p><p><strong>注意：必须卸载文件系统后才能对其进行检查，否则可能会出现错误。平时没有必要使用这个命令检查磁盘，只有当系统开机显示磁盘错误时，才需要执行。</strong></p><p><strong>语法格式：fsck [option] [filesys]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/05/02/5ccae4da09a97.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）系统开机通过fsck自检</strong></p><p>Linux在开机过程中系统会自动调用fsck命令对需要自检的磁盘进行自检，如下图：</p><p><img src="https://i.loli.net/2019/05/02/5ccae4f632933.jpg"></p><p>这是因为系统开机过程中会优先读取/etc/fstab文件，当最后一列设置为1或2时，这个磁盘在开机时就会调用fsck进行自检，fstab的文件（man fstab看帮助）信息如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ~]<span class="comment"># cat /etc/fstab </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># /etc/fstab</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Created by anaconda on Sun Apr  7 20:32:53 2019</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Accessible filesystems, by reference, are maintained under '/dev/disk'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">UUID=0887567f-1df6-425f-ba3d-ce58584279e0 /                       xfs     defaults        0 0</span><br><span class="line">UUID=26954b3f-dd29-4a25-85ba-471cdbbf82df /boot                   xfs     defaults        0 0</span><br><span class="line">UUID=1f9ad06d-860c-4166-b142-6b633ee82851 swap                    swap    defaults        0 0</span><br></pre></td></tr></table></figure><p><strong>在CentOS6系统中，系统分区的根分区最后一列一般是1，boot分区最后一列是2，其余是0。但是在CentOS7系统中，为了不影响系统启动，把系统分区最后1列均设为0，即开机不自检。</strong></p><p><strong>需要提醒一下：有时我们自己增加硬盘规划分区，一般最后一列都设置为0，即开机过程中不对磁盘检查，否则，一旦自定义挂载的磁盘有问题，会影响系统启动。 如果真有问题，可以在启动系统后人为进行检查。</strong></p><p><strong>2）Linux断电后重启故障修复</strong></p><p>当Linux系统遭遇突然断电等非正常关机操作时，很容易导致文件系统数据损坏，造成系统不能重新启动，此时，屏幕出现的提示可能是如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* AN error occurred during the file system check</span><br><span class="line">*** xxx</span><br><span class="line">*** xxx</span><br><span class="line">Give root password <span class="keyword">for</span> maintenance</span><br><span class="line">(or <span class="built_in">type</span> Control-D to <span class="built_in">continue</span>):</span><br></pre></td></tr></table></figure><p>此时根据系统提示输入root用户的密码，注意而不是直接按Control-D继续，会再重启。</p><p>当输入正确的密码之后，正常会出现下面的提示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Repair filesystem) 1 <span class="comment">#</span></span><br></pre></td></tr></table></figure><p>此时就可以输入fsck或者fsck-A对磁盘进行修复检查，执行后可能出现一堆询问，按yes即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(Repair filesystem) 1 <span class="comment"># fsck -A #&lt;==可能会等待一段时间或fsck。</span></span><br><span class="line">(Repair filesystem) 2 <span class="comment"># #&lt;==修复完毕会返回到这个提示符，此时就可以试着重启系统看故障是否修复了。</span></span><br></pre></td></tr></table></figure><p><strong>除了按照开机的提示进行修复外，也可以利用系统盘进入救援模式或单用户模式对系统故障进行修复。千万不要在开机正常工作的情况下执行fsck来检查磁盘，因为这样有可能会导致正常的磁盘发生故障。</strong></p><h2 id="mount：挂载文件系统"><a href="#mount：挂载文件系统" class="headerlink" title="mount：挂载文件系统"></a>mount：挂载文件系统</h2><p>mount命令可以将指定的文件系统挂载到指定目录（挂载点），在Linux系统下必须先挂载所有的设备，然后才能被访问，挂载其实就是为要访问的设置开个门（开门才能访问）。挂载的目录必须事先存在且最好为空，如果目录不为空，那么挂载设备后会掩盖以前的目录内容，但原目录下的内容不会受损，所以，如果卸载了相应的设备，那么此前的目录内容又可以访问了。</p><p><strong>语法格式：mount [option] [device] [dir]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/05/02/5ccae591533e9.jpg"></p><p>其中，-o选项后接的挂载参数如下：</p><p><img src="https://i.loli.net/2019/05/02/5ccae5a7e7b0e.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）显示系统已挂载的信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不加参数或加-l选项</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># mount</span></span><br><span class="line">sysfs on /sys <span class="built_in">type</span> sysfs (rw,nosuid,nodev,noexec,relatime)</span><br><span class="line">proc on /proc <span class="built_in">type</span> proc (rw,nosuid,nodev,noexec,relatime)</span><br><span class="line">devtmpfs on /dev <span class="built_in">type</span> devtmpfs (rw,nosuid,size=3984384k,nr_inodes=996096,mode=755)</span><br><span class="line">securityfs on /sys/kernel/security <span class="built_in">type</span> securityfs (rw,nosuid,nodev,noexec,relatime)</span><br><span class="line">tmpfs on /dev/shm <span class="built_in">type</span> tmpfs (rw,nosuid,nodev)</span><br><span class="line">devpts on /dev/pts <span class="built_in">type</span> devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000)</span><br><span class="line">tmpfs on /run <span class="built_in">type</span> tmpfs (rw,nosuid,nodev,mode=755)</span><br><span class="line">tmpfs on /sys/fs/cgroup <span class="built_in">type</span> tmpfs (ro,nosuid,nodev,noexec,mode=755)</span><br><span class="line">cgroup on /sys/fs/cgroup/systemd <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,xattr,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd)</span><br><span class="line">pstore on /sys/fs/pstore <span class="built_in">type</span> pstore (rw,nosuid,nodev,noexec,relatime)</span><br><span class="line">cgroup on /sys/fs/cgroup/perf_event <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,perf_event)</span><br><span class="line">cgroup on /sys/fs/cgroup/memory <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,memory)</span><br><span class="line">cgroup on /sys/fs/cgroup/blkio <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,blkio)</span><br><span class="line">cgroup on /sys/fs/cgroup/net_cls,net_prio <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,net_prio,net_cls)</span><br><span class="line">cgroup on /sys/fs/cgroup/devices <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,devices)</span><br><span class="line">cgroup on /sys/fs/cgroup/pids <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,pids)</span><br><span class="line">cgroup on /sys/fs/cgroup/hugetlb <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb)</span><br><span class="line">cgroup on /sys/fs/cgroup/cpu,cpuacct <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,cpuacct,cpu)</span><br><span class="line">cgroup on /sys/fs/cgroup/cpuset <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)</span><br><span class="line">cgroup on /sys/fs/cgroup/freezer <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,freezer)</span><br><span class="line">configfs on /sys/kernel/config <span class="built_in">type</span> configfs (rw,relatime)</span><br><span class="line">/dev/sda3 on / <span class="built_in">type</span> xfs (rw,relatime,attr2,inode64,noquota)</span><br><span class="line">debugfs on /sys/kernel/debug <span class="built_in">type</span> debugfs (rw,relatime)</span><br><span class="line">hugetlbfs on /dev/hugepages <span class="built_in">type</span> hugetlbfs (rw,relatime)</span><br><span class="line">systemd-1 on /proc/sys/fs/binfmt_misc <span class="built_in">type</span> autofs (rw,relatime,fd=32,pgrp=1,timeout=0,minproto=5,maxproto=5,direct,pipe_ino=24337)</span><br><span class="line">mqueue on /dev/mqueue <span class="built_in">type</span> mqueue (rw,relatime)</span><br><span class="line">/dev/sda1 on /boot <span class="built_in">type</span> xfs (rw,relatime,attr2,inode64,noquota)</span><br><span class="line">tmpfs on /run/user/0 <span class="built_in">type</span> tmpfs (rw,nosuid,nodev,relatime,size=799032k,mode=700)</span><br><span class="line">/dev/sdb1 on /root/mydata <span class="built_in">type</span> xfs (rw,relatime,attr2,inode64,noquota)</span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># mount -l</span></span><br><span class="line">sysfs on /sys <span class="built_in">type</span> sysfs (rw,nosuid,nodev,noexec,relatime)</span><br><span class="line">proc on /proc <span class="built_in">type</span> proc (rw,nosuid,nodev,noexec,relatime)</span><br><span class="line">devtmpfs on /dev <span class="built_in">type</span> devtmpfs (rw,nosuid,size=3984384k,nr_inodes=996096,mode=755)</span><br><span class="line">securityfs on /sys/kernel/security <span class="built_in">type</span> securityfs (rw,nosuid,nodev,noexec,relatime)</span><br><span class="line">tmpfs on /dev/shm <span class="built_in">type</span> tmpfs (rw,nosuid,nodev)</span><br><span class="line">devpts on /dev/pts <span class="built_in">type</span> devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000)</span><br><span class="line">tmpfs on /run <span class="built_in">type</span> tmpfs (rw,nosuid,nodev,mode=755)</span><br><span class="line">tmpfs on /sys/fs/cgroup <span class="built_in">type</span> tmpfs (ro,nosuid,nodev,noexec,mode=755)</span><br><span class="line">cgroup on /sys/fs/cgroup/systemd <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,xattr,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd)</span><br><span class="line">pstore on /sys/fs/pstore <span class="built_in">type</span> pstore (rw,nosuid,nodev,noexec,relatime)</span><br><span class="line">cgroup on /sys/fs/cgroup/perf_event <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,perf_event)</span><br><span class="line">cgroup on /sys/fs/cgroup/memory <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,memory)</span><br><span class="line">cgroup on /sys/fs/cgroup/blkio <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,blkio)</span><br><span class="line">cgroup on /sys/fs/cgroup/net_cls,net_prio <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,net_prio,net_cls)</span><br><span class="line">cgroup on /sys/fs/cgroup/devices <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,devices)</span><br><span class="line">cgroup on /sys/fs/cgroup/pids <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,pids)</span><br><span class="line">cgroup on /sys/fs/cgroup/hugetlb <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb)</span><br><span class="line">cgroup on /sys/fs/cgroup/cpu,cpuacct <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,cpuacct,cpu)</span><br><span class="line">cgroup on /sys/fs/cgroup/cpuset <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)</span><br><span class="line">cgroup on /sys/fs/cgroup/freezer <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,freezer)</span><br><span class="line">configfs on /sys/kernel/config <span class="built_in">type</span> configfs (rw,relatime)</span><br><span class="line">/dev/sda3 on / <span class="built_in">type</span> xfs (rw,relatime,attr2,inode64,noquota)</span><br><span class="line">debugfs on /sys/kernel/debug <span class="built_in">type</span> debugfs (rw,relatime)</span><br><span class="line">hugetlbfs on /dev/hugepages <span class="built_in">type</span> hugetlbfs (rw,relatime)</span><br><span class="line">systemd-1 on /proc/sys/fs/binfmt_misc <span class="built_in">type</span> autofs (rw,relatime,fd=32,pgrp=1,timeout=0,minproto=5,maxproto=5,direct,pipe_ino=24337)</span><br><span class="line">mqueue on /dev/mqueue <span class="built_in">type</span> mqueue (rw,relatime)</span><br><span class="line">/dev/sda1 on /boot <span class="built_in">type</span> xfs (rw,relatime,attr2,inode64,noquota)</span><br><span class="line">tmpfs on /run/user/0 <span class="built_in">type</span> tmpfs (rw,nosuid,nodev,relatime,size=799032k,mode=700)</span><br><span class="line">/dev/sdb1 on /root/mydata <span class="built_in">type</span> xfs (rw,relatime,attr2,inode64,noquota)</span><br></pre></td></tr></table></figure><p><strong>2）对系统的光驱进行挂载</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不使用-t选项指定类型为 iso9660，但mount命令可以自动识别</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># mount /dev/cdrom /mnt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提示为只读挂载</span></span><br><span class="line"></span><br><span class="line">mount: /dev/sr0 is write-protected, mounting <span class="built_in">read</span>-only</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看/dev/cdrom文件，发现设备cdrom是sr0的一个软链接</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ll -h /dev/cdrom</span></span><br><span class="line">lrwxrwxrwx 1 root root 3 May  2 18:10 /dev/cdrom -&gt; sr0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看是否挂载</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># df -h</span></span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/sda3        42G  2.6G   40G   7% /</span><br><span class="line">devtmpfs        3.8G     0  3.8G   0% /dev</span><br><span class="line">tmpfs           3.9G     0  3.9G   0% /dev/shm</span><br><span class="line">tmpfs           3.9G   12M  3.8G   1% /run</span><br><span class="line">tmpfs           3.9G     0  3.9G   0% /sys/fs/cgroup</span><br><span class="line">/dev/sda1       397M  162M  236M  41% /boot</span><br><span class="line">tmpfs           781M     0  781M   0% /run/user/0</span><br><span class="line">/dev/sdb1       5.0G   33M  5.0G   1% /root/mydata</span><br><span class="line">/dev/sr0        4.3G  4.3G     0 100% /mnt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看挂载点内容</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ll -h /mnt</span></span><br><span class="line">total 686K</span><br><span class="line">-rw-rw-r-- 1 root root   14 Nov 26 00:01 CentOS_BuildTag</span><br><span class="line">drwxr-xr-x 3 root root 2.0K Nov 26 00:20 EFI</span><br><span class="line">-rw-rw-r-- 1 root root  227 Aug 30  2017 EULA</span><br><span class="line">-rw-rw-r-- 1 root root  18K Dec 10  2015 GPL</span><br><span class="line">drwxr-xr-x 3 root root 2.0K Nov 26 00:21 images</span><br><span class="line">drwxr-xr-x 2 root root 2.0K Nov 26 00:20 isolinux</span><br><span class="line">drwxr-xr-x 2 root root 2.0K Nov 26 00:20 LiveOS</span><br><span class="line">drwxrwxr-x 2 root root 648K Nov 26 07:52 Packages</span><br><span class="line">drwxrwxr-x 2 root root 4.0K Nov 26 07:53 repodata</span><br><span class="line">-rw-rw-r-- 1 root root 1.7K Dec 10  2015 RPM-GPG-KEY-CentOS-7</span><br><span class="line">-rw-rw-r-- 1 root root 1.7K Dec 10  2015 RPM-GPG-KEY-CentOS-Testing-7</span><br><span class="line">-r--r--r-- 1 root root 2.9K Nov 26 07:54 TRANS.TBL</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载挂载点</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># umount /mnt/</span></span><br></pre></td></tr></table></figure><p>在实际中，我们经常会挂载NFS（网络文件系统），这就要用到mount命令的-o选项，来保证性能和安全性。具体的说明，请参见本站Linux常用工具分类中的NFS文件系统一文。</p><h2 id="umount：卸载文件系统"><a href="#umount：卸载文件系统" class="headerlink" title="umount：卸载文件系统"></a>umount：卸载文件系统</h2><p>umount命令可以卸载已经挂载的文件系统，如上文中示例2的卸载挂载点。<strong>umount卸载可以接挂载点目录，也可以接设备文件。</strong></p><p><strong>语法格式：umount [option] [dir|device]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/05/02/5ccae65d205b3.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）卸载光驱挂载</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先挂载光驱</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># mount -t iso9660 /dev/cdrom /mnt</span></span><br><span class="line">mount: /dev/sr0 is write-protected, mounting <span class="built_in">read</span>-only</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看系统挂载信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># df -h</span></span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/sda3        42G  2.6G   40G   7% /</span><br><span class="line">devtmpfs        3.8G     0  3.8G   0% /dev</span><br><span class="line">tmpfs           3.9G     0  3.9G   0% /dev/shm</span><br><span class="line">tmpfs           3.9G   12M  3.8G   1% /run</span><br><span class="line">tmpfs           3.9G     0  3.9G   0% /sys/fs/cgroup</span><br><span class="line">/dev/sda1       397M  162M  236M  41% /boot</span><br><span class="line">tmpfs           781M     0  781M   0% /run/user/0</span><br><span class="line">/dev/sdb1       5.0G   33M  5.0G   1% /root/mydata</span><br><span class="line">/dev/sr0        4.3G  4.3G     0 100% /mnt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用设备文件卸载</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># umount /dev/cdrom</span></span><br></pre></td></tr></table></figure><p><strong>2）强制卸载</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 挂载光驱，并进入挂载点</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># mount /dev/cdrom /mnt &amp;&amp; cd /mnt</span></span><br><span class="line">mount: /dev/sr0 is write-protected, mounting <span class="built_in">read</span>-only</span><br><span class="line">[root@C7-Server01 mnt]<span class="comment"># </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时尝试卸载光驱，会提示设备忙，无法卸载</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 mnt]<span class="comment"># umount /mnt</span></span><br><span class="line">umount: /mnt: target is busy.</span><br><span class="line">        (In some cases useful info about processes that use</span><br><span class="line">         the device is found by lsof(8) or fuser(1))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-lf选项强制卸载</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 mnt]<span class="comment"># umount -lf /mnt</span></span><br><span class="line">[root@C7-Server01 mnt]<span class="comment"># df -h</span></span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/sda3        42G  2.6G   40G   7% /</span><br><span class="line">devtmpfs        3.8G     0  3.8G   0% /dev</span><br><span class="line">tmpfs           3.9G     0  3.9G   0% /dev/shm</span><br><span class="line">tmpfs           3.9G   12M  3.8G   1% /run</span><br><span class="line">tmpfs           3.9G     0  3.9G   0% /sys/fs/cgroup</span><br><span class="line">/dev/sda1       397M  162M  236M  41% /boot</span><br><span class="line">tmpfs           781M     0  781M   0% /run/user/0</span><br><span class="line">/dev/sdb1       5.0G   33M  5.0G   1% /root/mydata</span><br></pre></td></tr></table></figure><h2 id="sync：刷新文件系统缓冲区"><a href="#sync：刷新文件系统缓冲区" class="headerlink" title="sync：刷新文件系统缓冲区"></a>sync：刷新文件系统缓冲区</h2><p>sync命令会将内存缓冲区内的数据强制刷新到磁盘。Linux内核为了达到最佳的磁盘操作效率，默认会先在内存中将需要写入到磁盘的数据缓存起来，然后等待合适的时机将它们真正写入到磁盘中，这在绝大多数情况下都是没有任何问题的，而且还提高了系统的效率，但是如果系统出现宕机、掉电等情况，就可能会导致有些文件内容没能保存下来。当然，在Linux系统正常关机或者重启时，会将缓冲区中的内容自动同步到磁盘中。我们也可以手工执行sync命令，将内存中的文件缓冲内容强制写到磁盘中。</p><p>但是通常情况下没有必要执行这个命令，一是Linux内核会尽快让内存中的数据自动同步到磁盘上去，二是我们也无法预计什么时候会宕机、掉电。</p><p><strong>语法格式：sync [option]</strong> </p><p><strong>【使用示例】</strong></p><p><strong>手动将数据从缓冲区刷到磁盘中并重启系统</strong></p><p>**</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写一个测试循环脚本来完成三次同步，每次间隔1秒，然后重启系统**</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 mnt]<span class="comment"># for i in `seq 3`;do sync;sleep 1; done &amp;&amp; reboot;</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/05/02/5ccae6c094551.jpg"></p><h2 id="dd：转换或复制文件"><a href="#dd：转换或复制文件" class="headerlink" title="dd：转换或复制文件"></a>dd：转换或复制文件</h2><p>dd命令具有复制文件、转换文件和格式化文本的功能。</p><p><strong>语法格式：dd [option]</strong> </p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/05/02/5ccae8ce512d2.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）将/dev/sda1分区复制（备份）到文件中</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看磁盘使用情况</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># df -h</span></span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/sda3        42G  2.6G   40G   7% /</span><br><span class="line">devtmpfs        3.8G     0  3.8G   0% /dev</span><br><span class="line">tmpfs           3.9G     0  3.9G   0% /dev/shm</span><br><span class="line">tmpfs           3.9G   12M  3.8G   1% /run</span><br><span class="line">tmpfs           3.9G     0  3.9G   0% /sys/fs/cgroup</span><br><span class="line">/dev/sda1       397M  162M  236M  41% /boot</span><br><span class="line">tmpfs           781M     0  781M   0% /run/user/0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 备份分区表信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># dd if=/dev/sda1 of=sda1-partb.info</span></span><br><span class="line">819200+0 records <span class="keyword">in</span></span><br><span class="line">819200+0 records out</span><br><span class="line">419430400 bytes (419 MB) copied, 5.68928 s, 73.7 MB/s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看输出文件的信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ll -h sda1-partb.info </span></span><br><span class="line">-rw-r--r-- 1 root root 400M May  2 19:48 sda1-partb.info</span><br></pre></td></tr></table></figure><p><strong>2）删除/dev/sdb1分区数据</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 挂载/dev/sdb1分区到root用户家目录下的mydata/目录</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># mount /dev/sdb1 mydata/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在mydata/目录下创建1000个文件</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># touch mydata/file&#123;01..1000&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看系统挂载信息，发现/dev/sdb1已使用33M，占比1%</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># df -h</span></span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/sda3        42G  3.0G   39G   8% /</span><br><span class="line">devtmpfs        3.8G     0  3.8G   0% /dev</span><br><span class="line">tmpfs           3.9G     0  3.9G   0% /dev/shm</span><br><span class="line">tmpfs           3.9G   12M  3.8G   1% /run</span><br><span class="line">tmpfs           3.9G     0  3.9G   0% /sys/fs/cgroup</span><br><span class="line">/dev/sda1       397M  162M  236M  41% /boot</span><br><span class="line">tmpfs           781M     0  781M   0% /run/user/0</span><br><span class="line">/dev/sdb1       5.0G   33M  5.0G   1% /root/mydata</span><br><span class="line"></span><br><span class="line"><span class="comment"># /dev/zero设备读取数据，写入到/dev/sdb1中，就会清空/dev/sdb1分区的数据</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># dd if=/dev/zero of=/dev/sdb1</span></span><br><span class="line">dd: writing to ‘/dev/sdb1’: No space left on device  <span class="comment"># 提示磁盘被写满</span></span><br><span class="line">10485761+0 records <span class="keyword">in</span></span><br><span class="line">10485760+0 records out</span><br><span class="line">5368709120 bytes (5.4 GB) copied, 73.561 s, 73.0 MB/s</span><br></pre></td></tr></table></figure><p><strong><em>/dev/zero是0字符设备，可产生连续不断的特殊数据流，生成的文件为特殊格式的数据文件（二进制）。</em></strong></p><p><strong>3）生成任意大小的文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成一个大小为10M的测试文件test01</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># dd if=/dev/zero of=test01 bs=1M count=10</span></span><br><span class="line">10+0 records <span class="keyword">in</span></span><br><span class="line">10+0 records out</span><br><span class="line">10485760 bytes (10 MB) copied, 0.136475 s, 76.8 MB/s</span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ll -h test01 </span></span><br><span class="line">-rw-r--r-- 1 root root 10M May  2 20:11 test01</span><br></pre></td></tr></table></figure><p><strong>生成文件test01的大小为bs*count=1M*10=10M。</strong></p><p><strong>4）生成CentOS7的镜像文件</strong></p><p>在Windows系统里制作光盘的ISO镜像，还需要安装其他软件。但在Linux系统中只需要dd命令就足够了，可以使用dd命令，将从光驱读取的镜像复制到系统中，相当于光驱与磁盘对拷。使用此类防范可以不用ftp工具或lrzsz工具对镜像文件进行上传。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ~]<span class="comment"># dd if=/dev/cdrom of=CentOS74.img</span></span><br><span class="line">8962048+0 records <span class="keyword">in</span></span><br><span class="line">8962048+0 records out</span><br><span class="line">4588568576 bytes (4.6 GB) copied, 30.8377 s, 149 MB/s</span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ll -h CentOS74.img </span></span><br><span class="line">-rw-r--r-- 1 root root 4.3G May  2 20:16 CentOS74.img</span><br></pre></td></tr></table></figure><p>这样我们就创建了一个用于KVM或OpenStack的母版镜像文件CentOS74.img。</p><p><strong>5）使用dd复制文件，并转换大小写</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在当前目录下创建测试文件，内容随便编辑</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># cat &gt; file01 &lt;&lt; EOF</span></span><br><span class="line">WWW.sn.Chinamobile.com</span><br><span class="line">我爱北京天安门！！！1234</span><br><span class="line">www.sina.com.CN</span><br><span class="line"><span class="comment">###!www.openstack.org</span></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用dd复制文件，并将原文件中所有大写字母转换为小写字母</span></span><br><span class="line"></span><br><span class="line">&gt; EOF</span><br><span class="line">&gt; [root@C7-Server01 ~]<span class="comment"># dd if=file01 of=file01_new conv=lcase</span></span><br><span class="line">&gt; 0+1 records <span class="keyword">in</span></span><br><span class="line">&gt; 0+1 records out</span><br><span class="line">&gt; 96 bytes (96 B) copied, 0.000108961 s, 881 kB/s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 产看file01_new文件内容</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># cat file01_new</span></span><br><span class="line">www.sn.chinamobile.com</span><br><span class="line">我爱北京天安门！！！1234</span><br><span class="line">www.sina.com.cn</span><br><span class="line"><span class="comment">###!www.openstack.org</span></span><br></pre></td></tr></table></figure><p><strong><em>Linux磁盘与文件系统管理命令掌握上述命令即可，还有三个用于交换分区管理的命令mkswap（创建交换分区）、swapon（激活交换分区）和swapoff（关闭交换分区）很少会被使用到，大家知道即可。如果在实际运维中需要，到时再通过man查询帮助即可。</em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;fdisk：磁盘分区工具&quot;&gt;&lt;a href=&quot;#fdisk：磁盘分区工具&quot; class=&quot;headerlink&quot; title=&quot;fdisk：磁盘分区工具&quot;&gt;&lt;/a&gt;fdisk：磁盘分区工具&lt;/h2&gt;&lt;p&gt;fdisk是Linux下常用的磁盘分区工具。受mbr分区表的限制，fdisk工具只能给小于2TB的磁盘划分分区。如果使用fdisk对大于2TB的磁盘进行分区，虽然可以分区，但其仅识别2TB的空间，所以磁盘容量若超过2TB，就要使用parted分区工具（后面会讲）进行分区。
    
    </summary>
    
      <category term="Linux核心命令" scheme="https://kkutysllb.cn/categories/Linux%E6%A0%B8%E5%BF%83%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Linux" scheme="https://kkutysllb.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>2019-05-01-Linux系统命令-第六篇《用户和权限管理命令》</title>
    <link href="https://kkutysllb.cn/2019/05/02/2019-05-01-Linux%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4-%E7%AC%AC%E5%85%AD%E7%AF%87%E3%80%8A%E7%94%A8%E6%88%B7%E5%92%8C%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4%E3%80%8B/"/>
    <id>https://kkutysllb.cn/2019/05/02/2019-05-01-Linux系统命令-第六篇《用户和权限管理命令》/</id>
    <published>2019-05-01T16:28:02.000Z</published>
    <updated>2019-05-01T17:02:36.871Z</updated>
    
    <content type="html"><![CDATA[<h2 id="useradd：创建用户"><a href="#useradd：创建用户" class="headerlink" title="useradd：创建用户"></a>useradd：创建用户</h2><p>useradd命令可用于创建新的用户或者更改用户的信息。在使用useradd命令时，若不加任何参数选项，后面直接跟所添加的用户名，那么系统首先会读取/etc/login.defs（用户定义文件）和/etc/default/useradd（用户默认配置文件）文件中所定义的参数和规则，然后根据所设置的规则添加用户，同时还会向/etc/passwd（用户文件）和/etc/group（组文件）文件内添加新用户和新用户组记录，向/etc/shadow（用户密码文件）和/etc/gshadow（组密码文件）文件里添加新用户和组对应的密码信息的相关记录。最后，系统还会根据/etc/default/useradd文件所配置的信息建立用户的家目录，并将/etc/skel中的所有文件（包括隐藏的环境配置文件）都复制到新用户的家目录中。<a id="more"></a></p><p>当执行useradd带-D参数时，可以更改新建用户的默认配置值（/etc/default/useradd）或者由命令行编辑文件更改预设值。可简单理解该参数（-D）就是用于修改/etc/default/useradduseradd配置文件的内容的，若这个文件的内容被修改，则添加新用户不加参数时默认值就会从该/etc/default/useradd中读取。</p><p><strong>语法格式：useradd [options] [login] 或 useradd -D [options]</strong></p><p><strong>重要选项参数</strong></p><p>useradd不加选项-D的参数选项及说明</p><p><img src="https://i.loli.net/2019/05/02/5cc9c976415d5.jpg"></p><p>useradd加-D选项参数说明：改变新建用户的预设值</p><p><img src="https://i.loli.net/2019/05/02/5cc9c9996c12d.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）不加任何参数添加用户的例子</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不带任何参数创建一个名为ett的用户</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># useradd ett</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看/home目录下，发现多个一个ett的目录</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ls -l /home/</span></span><br><span class="line">total 4</span><br><span class="line">drwx------ 2 ett       ett         62 May  1 16:35 ett</span><br><span class="line">drwx------ 7 kkutysllb kkutysllb 4096 Apr 28 00:00 kkutysllb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看/etc/passwd文件关于新建用户ett的记录</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># cat /etc/passwd | grep -w ett</span></span><br><span class="line">ett:x:1001:1001::/home/ett:/bin/bash   <span class="comment"># 这里设置根据文件/etc/login.defs里面预设内容设置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看/etc/shadow文件关于新建用户ett的记录</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># cat /etc/shadow | grep -w ett</span></span><br><span class="line">ett:!!:18017:0:99999:7:::  <span class="comment"># 虽然没有设置密码，但是还有相关一行记录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看/etc/group文件中关于新建ett的记录</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># cat /etc/group | grep -w ett</span></span><br><span class="line">ett:x:1001:</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看/etc/gshadow文件中关于新建用户ett的记录</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># cat /etc/gshadow | grep -w ett</span></span><br><span class="line">ett:!::</span><br></pre></td></tr></table></figure><p>根据上面的结果，我们将会发现/etc/shadow、/etc/group和/etc/gshadow几个文件都存在与ett用户相关的记录。</p><p><strong>2）useradd的-g、-u参数，执行useradd[参数]username添加用户</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先创建一个用户组sa，并设置组id为801（创建用户组的命令groupadd后面会将）</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># groupadd -g 801 sa</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建用户user01，使其属于sa用户组，uid为901</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># useradd -g sa -u 901 user01</span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># id user01</span></span><br><span class="line">uid=901(user01) gid=801(sa) groups=801(sa)</span><br></pre></td></tr></table></figure><p><strong>3）useradd的-M、-s参数的例子</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个虚拟化vuser01，不自动创建其家目录，并禁止其登录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># /sbin/nologin参数可以设置某个用户没有登录权限</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># useradd -M -s /sbin/nologin vuser01</span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ls -ld /home/vuser01</span></span><br><span class="line">ls: cannot access /home/vuser01: No such file or directory  <span class="comment"># 家目录不存在，-M选项作用</span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># cat /etc/passwd | grep -w vuser01</span></span><br><span class="line">vuser01:x:1002:1002::/home/vuser01:/sbin/nologin  <span class="comment"># 该用户没有登录权限，-s选项作用</span></span><br></pre></td></tr></table></figure><p><strong>4）useradd的-c、-u、-G、-s、-d、-m、-e、-f等多个参数组合的综合例子</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建用户user02，并设置用户注释信息为“SysUser”</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># UID指定为806，同时归属root和sa用户组，登录shell使用/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置其家目录为/tmp/user02，用户过期时限为2019-10-31，过期后2天停权</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># useradd -u 801 -s /bin/sh -c SysUser -d /tmp/user02 -G root,sa -e "2019-10-31" -f 2 user02</span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># tail -1 /etc/passwd   # 查看user02的家目录，注释信息，登录shell等信息</span></span><br><span class="line">user02:x:801:1003:SysUser:/tmp/user02:/bin/sh</span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># id user02   # 查看user02的uid和gid，所属用户组信息</span></span><br><span class="line">uid=801(user02) gid=1003(user02) groups=1003(user02),0(root),801(sa)</span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># chage -l user02  # 查看user02的账号期限信息</span></span><br><span class="line">Last password change: May 01, 2019</span><br><span class="line">Password expires: never</span><br><span class="line">Password inactive: never</span><br><span class="line">Account expires: Oct 31, 2019</span><br><span class="line">Minimum number of days between password change: 0</span><br><span class="line">Maximum number of days between password change: 99999</span><br><span class="line">Number of days of warning before password expires: 7</span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># tail -1 /etc/shadow  # 查询用户超期停权时限</span></span><br><span class="line">user02:!!:18017:0:99999:7:2:18200:</span><br></pre></td></tr></table></figure><p><strong>5）useradd-D参数的使用说明及案例实践</strong></p><p>使用useradd-D参数的结果实际上就是修改用户的初始配置文件/etc/default/useradd，我们首先看下用户初始配置文件内容，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ~]<span class="comment"># cat /etc/default/useradd </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># useradd defaults file</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 依赖于/etc/login.defs的USERGROUP_ENAB参数，如果参数值为no，则组设置由此处控制</span></span><br><span class="line"></span><br><span class="line">GROUP=100  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认把用户家目录创建在/home/目录下</span></span><br><span class="line"></span><br><span class="line">HOME=/home </span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否启用用户过期停权，-1表示不使用</span></span><br><span class="line"></span><br><span class="line">INACTIVE=-1  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户终止日期设置，默认不设置</span></span><br><span class="line"></span><br><span class="line">EXPIRE=   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建用户默认使用shell类型</span></span><br><span class="line"></span><br><span class="line">SHELL=/bin/bash  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置新建用户家目录的默认文件存放路径。/etc/skell就是在这里配置生效的，即当我们使用useradd创建用户时，用户家目录下的文件（主要是隐藏文件）都是从这里配置的目录下复制过去的</span></span><br><span class="line"></span><br><span class="line">SKEL=/etc/skel </span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否创建mail文件</span></span><br><span class="line"></span><br><span class="line">CREATE_MAIL_SPOOL=yes</span><br></pre></td></tr></table></figure><p><strong><em>修改实践：</em></strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 良好习惯，一般修改系统配置文件，首先创建好备份</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># cp /etc/default/useradd&#123;,.bak&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改默认登录的shell为/bin/sh</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># useradd -D -s /bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 比对修改前后的两个文件</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># diff /etc/default/useradd&#123;,.bak&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 表示前后两个文件第6行不同，新文件已经修改成为/bin/sh</span></span><br><span class="line"></span><br><span class="line">6c6</span><br><span class="line"></span><br><span class="line"><span class="comment">## &lt; SHELL=/bin/sh</span></span><br><span class="line"></span><br><span class="line">&gt; SHELL=/bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加新建用户失效时限为2039-12-31</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># useradd -D -e "2039-12-31"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 比对前后两个文件区别</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># diff /etc/default/useradd&#123;,.bak&#125;</span></span><br><span class="line">5,6c5,6</span><br><span class="line">&lt; EXPIRE=2039-12-31</span><br><span class="line"></span><br><span class="line"><span class="comment">## &lt; SHELL=/bin/sh</span></span><br><span class="line"></span><br><span class="line">&gt; EXPIRE=</span><br><span class="line">&gt; SHELL=/bin/bash</span><br><span class="line">&gt;</span><br><span class="line">&gt; <span class="comment"># 新建一个用户user03</span></span><br><span class="line">&gt;</span><br><span class="line">&gt; [root@C7-Server01 ~]<span class="comment"># useradd user03</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看新建用户user03的配置信息，发现登陆后默认使用/bin/sh作为shell解释器</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># tail -1 /etc/passwd</span></span><br><span class="line">user03:x:1003:1004::/home/user03:/bin/sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看新建用户user03的账号期限，发现为2039年12月31日</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># chage -l user03</span></span><br><span class="line">Last password change: May 01, 2019</span><br><span class="line">Password expires: never</span><br><span class="line">Password inactive: never</span><br><span class="line">Account expires: Dec 31, 2039</span><br><span class="line">Minimum number of days between password change: 0</span><br><span class="line">Maximum number of days between password change: 99999</span><br><span class="line">Number of days of warning before password expires: 7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 完成上述验证后，需要恢复现场</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># cp /etc/default/useradd&#123;.bak,&#125;</span></span><br><span class="line">cp: overwrite ‘/etc/default/useradd’? y    <span class="comment"># 输入y确认</span></span><br></pre></td></tr></table></figure><h2 id="usermod：修改用户信息"><a href="#usermod：修改用户信息" class="headerlink" title="usermod：修改用户信息"></a>usermod：修改用户信息</h2><p>usermod命令用于修改系统已经存在的用户的账号信息。usermod的作用是修改用户，而useradd的作用是添加用户，本质上都是对用户进行操作，因此，参数作用大部分都是类似的，只不过命令不同，就是添加和修改的区别。</p><p><strong>语法格式：usermod [options] [login]</strong></p><p><strong>重要参数选项</strong></p><p><img src="https://i.loli.net/2019/05/02/5cc9cabf31410.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>usermod的-c、-u、-G、-s、-d、-m、-e、-f等多个参数组合的例子</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改上面例子创建的user02用户，注释信息修改为TmpUser</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># UID修改为1999，归属用户组修改为只归属sa用户组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># shell类型修改为/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 家目录修改为/home/user02</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户过期时限修改为2020-01-01，过期后30天停权</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># usermod -u 1999 -s /bin/sh -d /home/user02 -G sa -c TmpUser -e "2020-01-01" -f 30 user02</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询用户登录shell和注释信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># cat /etc/passwd | grep -w user02</span></span><br><span class="line">user02:x:1999:1003:TmpUser:/home/user02:/bin/sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询用户uid ,gid和归属用户组信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># id user02</span></span><br><span class="line">uid=1999(user02) gid=1003(user02) groups=1003(user02),801(sa)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询用户user02的过期时限</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># chage -l user02</span></span><br><span class="line">Last password change: May 01, 2019</span><br><span class="line">Password expires: never</span><br><span class="line">Password inactive: never</span><br><span class="line">Account expires: Jan 01, 2020</span><br><span class="line">Minimum number of days between password change: 0</span><br><span class="line">Maximum number of days between password change: 99999</span><br><span class="line">Number of days of warning before password expires: 7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询用户停权的时限</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># cat /etc/shadow | grep -e user02</span></span><br><span class="line">user02:!!:18017:0:99999:7:30:18262:</span><br></pre></td></tr></table></figure><h2 id="userdel：删除用户"><a href="#userdel：删除用户" class="headerlink" title="userdel：删除用户"></a>userdel：删除用户</h2><p>userdel命令用于删除指定的用户及与该用户相关的文件。</p><p><strong>语法格式：userdel [options] [login]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/05/02/5cc9cb1030b42.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）不加参数删除用户</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询刚才添加的虚拟用户vuser01的信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># grep -e vuser01 /etc/passwd</span></span><br><span class="line">vuser01:x:1002:1002::/home/vuser01:/sbin/nologin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不带任何选项参数删除虚拟用户vuser01</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># userdel vuser01</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次查看vuser01在系统配置文件/etc/passwd中的信息，结果什么也没有输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为显示效果，在后面追加wc -l命令用于统计屏幕输出行数信息，结果为0</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># grep -e vuser01 /etc/passwd | wc -l</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure><p><strong>2） 加-r参数删除用户及家目录</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在不加任何选项删除用户时，用户信息虽然从/etc/passwd文件删除，但是创建的家目录仍然存在</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加-r选项删除用户user01，可以同步删除用户家目录信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># userdel -r user01</span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># grep -w user01 /etc/passwd | wc -l</span></span><br><span class="line">0</span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># grep -w user01 /home/user01 | wc -l</span></span><br><span class="line">grep: /home/user01: No such file or directory</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p><strong>3）强制删除用户示例（此命令请谨慎使用）</strong></p><p>我们复制一个终端，在宿主机使用kkutysllb用户登录，如下：</p><p><img src="https://i.loli.net/2019/05/02/5cc9cb64a8fb9.jpg"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们在老的终端下，使用root用户删除kkutysllb用户</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用who命令查询当前登录的用户</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># who</span></span><br><span class="line">root     pts/0        2019-05-01 16:35 (192.168.101.1)</span><br><span class="line">kkutysllb pts/1        2019-05-01 18:17 (192.168.101.1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为本机/home/kkutysllb/目录下有私有配置文件，所以本次演示不使用-r选项</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-f选项强制删除已登录用户kkutysllb</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># userdel -f kkutysllb</span></span><br><span class="line">userdel: user kkutysllb is currently used by process 10633</span><br><span class="line"></span><br><span class="line"><span class="comment"># 虽然上面提示用户正在登录，但其实用户信息已被删除，当退出后查询/etc/passwd文件已经没有kkutysllb用户的配置信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># grep -w kkutysllb /etc/passwd | wc -l</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="groupadd：创建新的用户组"><a href="#groupadd：创建新的用户组" class="headerlink" title="groupadd：创建新的用户组"></a>groupadd：创建新的用户组</h2><p>groupadd命令用于创建新的用户组。但groupadd命令的用途一般不大，因为useradd命令在创建用户的同时还会创建与用户同名的用户组。</p><p><strong>语法格式：groupadd [options] [group]</strong></p><p><strong>重要参数选项</strong></p><p>groupadd命令用于创建新的用户组。但groupadd命令的用途一般不大，因为useradd命令在创建用户的同时还会创建与用户同名的用户组。</p><p><strong>语法格式：groupadd [options] [group]</strong></p><p><strong>重要参数选项</strong></p><p><img src="https://i.loli.net/2019/05/02/5cc9cb989a510.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>指定gid添加用户组的例子</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-g选项指定新增用户组的gid为1024</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># groupadd -g 1024 kkutysllb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看新增用户组在/etc/group配置文件的信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># tail -1 /etc/group</span></span><br><span class="line">kkutysllb:x:1024:</span><br><span class="line"></span><br><span class="line"><span class="comment"># 虽然没有指定组密码，但是在系统配置/etc/gshadow文件中仍有默认配置</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># tail -1 /etc/gshadow</span></span><br><span class="line">kkutysllb:!::</span><br></pre></td></tr></table></figure><p><strong><em>groupadd的命令在工作场景中的应用绝大多数情况下仅限于此，一般掌握上述用法即可。</em></strong></p><p><strong>groupdel：删除用户组</strong></p><p>groupdel命令用于删除指定的用户组，此命令的使用频率极低，了解基本用法即可。需要注意一点：groupdel不能删除还有用户归属的主用户组。</p><p><strong>语法格式：groupdel [group]</strong></p><p><strong>【使用示例】</strong></p><p><strong>删除用户组的例子</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 尝试删除root用户组，会提示失败，因为root用户还存在</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># groupdel root</span></span><br><span class="line">groupdel: cannot remove the primary group of user <span class="string">'root'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除sa用户组</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># groupdel sa</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询系统配置文件sa用户组的信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># grep -w sa /etc/group | wc -l</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="passwd：修改用户密码"><a href="#passwd：修改用户密码" class="headerlink" title="passwd：修改用户密码"></a>passwd：修改用户密码</h2><p>passwd命令可以修改用户密码及密码过期时间等内容，是实际中很常用的命令。普通用户和超级用户都可以运行passwd命令，但普通用户只能更改自身的用户密码，超级用户root则可以设置或修改所有用户的密码。root用户修改密码时，如果不符合系统密码规则，则给出警告信息，但密码设置仍然生效。普通用户修改密码时，如果使用弱密码，则给出告警信息，且修改无效。</p><p><strong>语法格式：passwd [option] [username]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/05/02/5cc9cbf78aa41.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）新增/修改用户的密码</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建kkutysllb用户（刚才已删除）</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># useradd -u 1024 -d /home/kkutysllb -g kkutysllb -c AdminUser -e "2199-12-31" -f 30 kkutysllb</span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># tail -1 /etc/passwd</span></span><br><span class="line">kkutysllb:x:1024:1024:AdminUser:/home/kkutysllb:/bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># root用户使用passwd命令新增kkutysllb用户的密码</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># passwd kkutysllb</span></span><br><span class="line">Changing password <span class="keyword">for</span> user kkutysllb.</span><br><span class="line">New password:    <span class="comment"># 输入新密码</span></span><br><span class="line">Retype new password:   <span class="comment"># 确认新密码</span></span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用su命令切换到kkutysllb用户下（从root用户切换到非root用户不用输入密码）</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># su - kkutysllb</span></span><br><span class="line">Last login: Wed May  1 19:32:00 CST 2019 on pts/0</span><br><span class="line">[kkutysllb@C7-Server01 ~]$ </span><br><span class="line"></span><br><span class="line"><span class="comment"># 在kkutysllb用户下修改自身密码为123456，会提示三次密码过于简单，然后退出，设置失败</span></span><br><span class="line"></span><br><span class="line">[kkutysllb@C7-Server01 ~]$ passwd</span><br><span class="line">Changing password <span class="keyword">for</span> user kkutysllb.</span><br><span class="line">Changing password <span class="keyword">for</span> kkutysllb.</span><br><span class="line">(current) UNIX password:   <span class="comment"># 首先输入用户当前密码</span></span><br><span class="line">New password:   <span class="comment"># 然后输入新密码</span></span><br><span class="line">BAD PASSWORD: The password is shorter than 8 characters</span><br><span class="line">New password: </span><br><span class="line">BAD PASSWORD: The password is shorter than 8 characters</span><br><span class="line">New password: </span><br><span class="line">BAD PASSWORD: The password is shorter than 8 characters</span><br><span class="line">passwd: Have exhausted maximum number of retries <span class="keyword">for</span> service</span><br></pre></td></tr></table></figure><p><strong>2）显示账号密码</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只能在root用户下使用，所以先切换回root用户</span></span><br><span class="line"></span><br><span class="line">[kkutysllb@C7-Server01 ~]$ su -</span><br><span class="line">Password:   <span class="comment"># 从非root用户切换回root用户要求输入密码</span></span><br><span class="line">Last login: Wed May  1 19:35:06 CST 2019 on pts/0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-S选项查看kkutysllb用户密码简单信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># passwd -S kkutysllb</span></span><br><span class="line">kkutysllb PS 2019-05-01 0 99999 7 30 (Password <span class="built_in">set</span>, SHA512 crypt.)</span><br></pre></td></tr></table></figure><p><strong>3）使用一条命令设置密码</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用--stdin选项从标准输入中读取密码，并设置给用户user03</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># echo "Adsds#@123"| passwd --stdin user03</span></span><br><span class="line">Changing password <span class="keyword">for</span> user user03.</span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看user03用户密码简单信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># passwd -S user03</span></span><br><span class="line">user03 PS 2019-05-01 0 99999 7 -1 (Password <span class="built_in">set</span>, SHA512 crypt.)</span><br></pre></td></tr></table></figure><p><strong>4）要求kkutysllb用户7天内不能更改密码，60天以后必须修改密码，过期前10天通知用户，过期后30天后禁止用户登录。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ~]<span class="comment"># passwd -n 7 -x 60 -w 10 -i 30 kkutysllb</span></span><br><span class="line">Adjusting aging data <span class="keyword">for</span> user kkutysllb.</span><br><span class="line">passwd: Success</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看kkutysllb密码简单信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># passwd -S kkutysllb</span></span><br><span class="line">kkutysllb PS 2019-05-01 7 60 10 30 (Password <span class="built_in">set</span>, SHA512 crypt.)</span><br></pre></td></tr></table></figure><p><strong>chage：修改用户密码有效期</strong></p><p>chage命令用于查看或修改用户密码的有效期，有些参数和passwd的功能相同。</p><p><strong>语法格式：chage [option] [login]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/05/02/5cc9cc8e80c1b.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）要求kkutysllb用户7天内不能更改密码，60天以后必须修改密码，过期前10天通知用户，过期后30天后禁止用户登录。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用chage命令实现</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># chage -m 7 -M 60 -W 10 -I 30 kkutysllb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-l选项，查看kkutysllb账号密码期限信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># chage -l kkutysllb</span></span><br><span class="line">Last password change: May 01, 2019</span><br><span class="line">Password expires: Jun 30, 2019</span><br><span class="line">Password inactive: Jul 30, 2019</span><br><span class="line">Account expires: Dec 31, 2199</span><br><span class="line">Minimum number of days between password change: 7</span><br><span class="line">Maximum number of days between password change: 60</span><br><span class="line">Number of days of warning before password expires: 10</span><br></pre></td></tr></table></figure><p><strong>2） 测试-E选项</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-E选项，将user03用户的账号有限期设置为2019-12-31</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># chage -E "2019-12-31" user03</span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># chage -l user03</span></span><br><span class="line">Last password change: May 01, 2019</span><br><span class="line">Password expires: never</span><br><span class="line">Password inactive: never</span><br><span class="line">Account expires: Dec 31, 2019</span><br><span class="line">Minimum number of days between password change: 0</span><br><span class="line">Maximum number of days between password change: 99999</span><br><span class="line">Number of days of warning before password expires: 7</span><br></pre></td></tr></table></figure><h2 id="chpasswd：批量更新用户密码"><a href="#chpasswd：批量更新用户密码" class="headerlink" title="chpasswd：批量更新用户密码"></a>chpasswd：批量更新用户密码</h2><p>chpasswd命令用于从标准输入中读取一定格式的用户名、密码来批量更新用户的密码，其格式为“用户名：密码”。</p><p><strong>语法格式：chpasswd [option]</strong> </p><p><strong>重要参数选项</strong></p><p><img src="https://i.loli.net/2019/05/02/5cc9ccf3a411d.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）命令行批量修改密码</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输入chapasswd后，按照格式 用户名：密码逐行修改密码，每行一个</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改密码的用户必须存在，修改完成后按ctrl+d退出</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># chpasswd </span></span><br><span class="line">user02:123456   <span class="comment"># 修改user02的密码为123456</span></span><br><span class="line">user03:123456   <span class="comment"># 修改user03的密码为123456</span></span><br></pre></td></tr></table></figure><p><strong>2）在不使用shell循环下，批量创建10个用户stu01-stu10，并且设置8位随机密码</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 批量创建10个用户</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># echo test&#123;01..10&#125;|xargs -n 1 useradd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看刚创建的10个用户</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># tail /etc/passwd</span></span><br><span class="line">test01:x:2000:2000::/home/test01:/bin/bash</span><br><span class="line">test02:x:2001:2001::/home/test02:/bin/bash</span><br><span class="line">test03:x:2002:2002::/home/test03:/bin/bash</span><br><span class="line">test04:x:2003:2003::/home/test04:/bin/bash</span><br><span class="line">test05:x:2004:2004::/home/test05:/bin/bash</span><br><span class="line">test06:x:2005:2005::/home/test06:/bin/bash</span><br><span class="line">test07:x:2006:2006::/home/test07:/bin/bash</span><br><span class="line">test08:x:2007:2007::/home/test08:/bin/bash</span><br><span class="line">test09:x:2008:2008::/home/test09:/bin/bash</span><br><span class="line">test10:x:2009:2009::/home/test10:/bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立账号:密码格式文件</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># echo test&#123;01..10&#125;:$((RANDOM+10000000))|tr " " "\n" &gt; userpass.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检验刚创建用户名:密码格式文件</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># cat userpass.txt </span></span><br><span class="line">test01:10013080</span><br><span class="line">test02:10008930</span><br><span class="line">test03:10025107</span><br><span class="line">test04:10009300</span><br><span class="line">test05:10012914</span><br><span class="line">test06:10029118</span><br><span class="line">test07:10018810</span><br><span class="line">test08:10024358</span><br><span class="line">test09:10003684</span><br><span class="line">test10:10008929</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用chpasswd命令从格式文件中读取内容，进行批量设置</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># chpasswd &lt; userpass.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从root用户先切换到test01用户下（无需密码），再切换到test10用户下（需要输入密码）</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># su - test01</span></span><br><span class="line">[test01@C7-Server01 ~]$ su - test10</span><br><span class="line">Password:    <span class="comment"># 输入testt10用户的密码</span></span><br><span class="line">[test10@C7-Server01 ~]$</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用whoami指令检验</span></span><br><span class="line"></span><br><span class="line">[test10@C7-Server01 ~]$ whoami </span><br><span class="line">test10</span><br></pre></td></tr></table></figure><h2 id="su：切换用户"><a href="#su：切换用户" class="headerlink" title="su：切换用户"></a>su：切换用户</h2><p>su命令用于将当前用户切换到指定用户或者以指定用户的身份执行命令或程序。若省略了命令后面的用户名，则默认切换为root用户。）从root用户切换到普通用户时，不需要任何密码；从普通用户切换到root用户时，需要输入root密码。</p><p><strong>语法格式：su [option] [user]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/05/02/5cc9cd600a4a1.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）切换用户忘记-选项，导致环境变量未同步切换</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先查询当前root用户下环境变量设置</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># env | egrep "USER|MAIL|PWD|LOGNAME"</span></span><br><span class="line">USER=root</span><br><span class="line">MAIL=/var/spool/mail/root</span><br><span class="line">PWD=/root</span><br><span class="line">LOGNAME=root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先从root用户切换到kkutysllb用户，再切回，不带-选项</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># su - kkutysllb</span></span><br><span class="line">Last login: Wed May  1 19:36:49 CST 2019 on pts/0</span><br><span class="line">[kkutysllb@C7-Server01 ~]$ su</span><br><span class="line">Password: </span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次查询当前root用户的环境变量，发现是kkutysllb用户的环境变量设置</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># env | egrep "USER|MAIL|PWD|LOGNAME"</span></span><br><span class="line">USER=kkutysllb</span><br><span class="line">MAIL=/var/spool/mail/kkutysllb</span><br><span class="line">PWD=/home/kkutysllb</span><br><span class="line">LOGNAME=kkutysllb</span><br></pre></td></tr></table></figure><p><strong><em>上述示例告诉我们，在切换用户时要保持好的习惯，带-和用户名切换，确保环境变量与当前用户设置一致。</em></strong></p><p><strong>2）向shell传递单个命令示例</strong></p><p>在后续我们不熟openstack的各项服务时，经常会进行数据库同步操作，完成此操作的语句如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su -s /bin/sh -c <span class="string">"neutron-db-manage --config-file /etc/neutron/neutron.conf --config-file /etc/neutron/plugins/ml2/ml2_conf.ini upgrade head"</span> neutron</span><br></pre></td></tr></table></figure><p>上述语句的意思就是：切换到neutron用户下，以/bin/sh作为shell解释器，执行neutron-db-manage –config-file /etc/neutron/neutron.conf –config-file /etc/neutron/plugins/ml2/ml2_conf.ini upgrade head命令完成neutron数据的库表创建工作。</p><p>因此，如果仅希望在某用户下执行命令，而不用直接切换到该用户下来操作，可以使用su - 用户名 -c”命令”的方式。</p><h2 id="visudo：编辑sudoers文件"><a href="#visudo：编辑sudoers文件" class="headerlink" title="visudo：编辑sudoers文件"></a>visudo：编辑sudoers文件</h2><p>visudo命令是专门用来编辑/etc/sudoers这个文件的，同时提供语法检查等功能。/etc/sudoers文件是sudo命令的配置文件。</p><p><strong>语法格式：visudo [option]</strong> </p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/05/02/5cc9cdc60b382.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）执行visudo对普通用户kkutysllb授权</strong></p><p><strong>执行visudo命令，按照vim编辑器的使用方法在101行添加如下内容，使得kkutysllb用户拥有root用户的权限。</strong></p><p><img src="https://i.loli.net/2019/05/02/5cc9cde09ec7d.jpg"></p><p><strong><em>上述授权内容对应的说明如下：</em></strong></p><p><img src="https://i.loli.net/2019/05/02/5cc9ce03e84da.jpg"></p><p><strong><em>visudo 相当于直接执行vim /etc/sudoers编辑，但用命令方式更安全，推荐使用该命令。同时，</em></strong>通过sudo进行系统授权管理的目的：即能让运维人员干活，又不会威胁系统安全，还可以审计用户使用sudo的提权操作命令，默认的用户是无法获得root权限的。</p><p><strong>2）检查sudoer文件语法</strong></p><p>有的时候用户不是使用visudo（保存时会自动检查语法）编辑的sudoer文件，而是使用vim或者echo等命令编辑的sudoer文件，此时就需要执行如下命令来检查编辑文件的语法是否正确，如果语法不正确，则可能会导致授权无法生效的问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过echo命令将kkutysllb用户组也授权为root权限</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># echo "%kkutysllb ALL=(ALL) ALL"  &gt;&gt; /etc/sudoers</span></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># tail -1 /etc/sudoers</span></span><br><span class="line">%kkutysllb ALL=(ALL) ALL</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-c选项检查sudoer文件语法合规性</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># visudo -c</span></span><br><span class="line">/etc/sudoers: parsed OK</span><br></pre></td></tr></table></figure><h2 id="users：显示已登录用户"><a href="#users：显示已登录用户" class="headerlink" title="users：显示已登录用户"></a>users：显示已登录用户</h2><p>users命令可以显示已经登录系统的用户。如果是同一用户登录多次，则登录几次就会显示几次用户名。</p><p><strong>语法格式：users</strong></p><p><strong>【使用示例】</strong></p><p><strong>显示已登录用户，如果是一个用户登录多次，就显示几个同名用户</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># users</span></span><br><span class="line">root  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 再通过root用户登录系统2次</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># users</span></span><br><span class="line">root root root</span><br></pre></td></tr></table></figure><p><strong>whoami：显示当前登录的用户名</strong></p><p>whoami命令用于显示当前登录的用户名，这个命令可以看作英文短句who am i的简写。</p><p><strong>语法格式：whoami</strong></p><p><strong>【使用示例】</strong></p><p><strong>显示当前登录的用户名</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># whoami </span></span><br><span class="line">root</span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># su - kkutysllb</span></span><br><span class="line">Last login: Wed May  1 22:17:04 CST 2019 on pts/0</span><br><span class="line">[kkutysllb@C7-Server01 ~]$ whoami</span><br><span class="line">kkutysllb</span><br></pre></td></tr></table></figure><p><strong>last：显示用户登录列表</strong></p><p>last命令能够从日志文件/var/log/wtmp读取信息并显示用户最近的登录列表。</p><p><strong>语法格式：last [option]</strong> </p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/05/02/5cc9ce7460e57.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）显示用户最近登录的列表</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ~]<span class="comment"># last</span></span><br><span class="line">root     pts/2        192.168.101.1    Wed May  1 22:51   still logged <span class="keyword">in</span>   </span><br><span class="line">root     pts/1        192.168.101.1    Wed May  1 22:51   still logged <span class="keyword">in</span>   </span><br><span class="line">kkutysll pts/1        192.168.101.1    Wed May  1 18:17 - 22:51  (04:33)    </span><br><span class="line">root     pts/1        192.168.101.1    Wed May  1 18:13 - 18:17  (00:04)    </span><br><span class="line">root     pts/0        192.168.101.1    Wed May  1 16:35   still logged <span class="keyword">in</span>   </span><br><span class="line">reboot   system boot  3.10.0-957.10.1. Wed May  1 16:35 - 22:57  (06:22)    </span><br><span class="line">root     pts/0        192.168.101.1    Mon Apr 29 16:42 - 18:05  (01:23)    </span><br><span class="line">reboot   system boot  3.10.0-957.10.1. Mon Apr 29 16:41 - 22:57 (2+06:16)   </span><br><span class="line">root     pts/1        192.168.101.1    Sun Apr 28 19:14 - crash  (21:27)    </span><br><span class="line">root     pts/0        192.168.101.1    Sun Apr 28 16:53 - crash  (23:48)    </span><br><span class="line">reboot   system boot  3.10.0-957.10.1. Sun Apr 28 16:53 - 22:57 (3+06:04)   </span><br><span class="line">root     pts/0        192.168.101.1    Sat Apr 27 21:43 - down   (04:27)    </span><br><span class="line">reboot   system boot  3.10.0-957.10.1. Sat Apr 27 21:43 - 02:11  (04:27)    </span><br><span class="line">root     pts/0        192.168.101.1    Sat Apr 27 21:42 - down   (00:00)    </span><br><span class="line">reboot   system boot  3.10.0-957.10.1. Sat Apr 27 21:42 - 21:43  (00:01)    </span><br><span class="line">root     pts/0        192.168.101.1    Sat Apr 27 12:00 - down   (00:56)    </span><br><span class="line">reboot   system boot  3.10.0-957.10.1. Sat Apr 27 12:00 - 12:57  (00:57)    </span><br><span class="line">root     pts/0        192.168.101.1    Sat Apr 27 11:13 - crash  (00:46)    </span><br><span class="line">reboot   system boot  3.10.0-957.10.1. Sat Apr 27 10:51 - 12:57  (02:05)    </span><br><span class="line">root     pts/0        192.168.101.1    Fri Apr 26 17:24 - down   (01:04)    </span><br><span class="line">reboot   system boot  3.10.0-957.10.1. Fri Apr 26 17:24 - 18:29  (01:04)    </span><br><span class="line">root     pts/1        192.168.101.1    Tue Apr 23 19:56 - down   (01:39)    </span><br><span class="line">root     pts/0        192.168.101.1    Tue Apr 23 18:25 - down   (03:10)    </span><br><span class="line">reboot   system boot  3.10.0-957.10.1. Tue Apr 23 18:24 - 21:36  (03:11)    </span><br><span class="line">root     pts/0        192.168.101.1    Tue Apr 23 12:51 - 13:14  (00:23)    </span><br><span class="line">reboot   system boot  3.10.0-957.10.1. Tue Apr 23 12:50 - 13:14  (00:23)    </span><br><span class="line">root     pts/0        192.168.101.1    Tue Apr 23 12:42 - down   (00:06)    </span><br><span class="line">reboot   system boot  3.10.0-957.10.1. Tue Apr 23 12:41 - 12:48  (00:06)    </span><br><span class="line">root     pts/0        192.168.101.1    Tue Apr 23 10:29 - crash  (02:12)    </span><br><span class="line">reboot   system boot  3.10.0-957.10.1. Tue Apr 23 10:28 - 12:48  (02:19)    </span><br><span class="line">kkutysll tty1                          Tue Apr 23 00:17 - 00:17  (00:00)    </span><br><span class="line">root     pts/0        192.168.101.1    Mon Apr 22 22:53 - crash  (11:35)    </span><br><span class="line">reboot   system boot  3.10.0-957.10.1. Mon Apr 22 22:53 - 12:48  (13:55)    </span><br><span class="line">root     pts/0        192.168.101.1    Mon Apr 22 22:52 - down   (00:00)    </span><br><span class="line">reboot   system boot  3.10.0-957.10.1. Mon Apr 22 22:52 - 22:53  (00:01)    </span><br><span class="line">root     pts/0        192.168.101.1    Mon Apr 22 22:38 - down   (00:13)    </span><br><span class="line">reboot   system boot  3.10.0-957.10.1. Mon Apr 22 22:23 - 22:52  (00:28)    </span><br><span class="line">reboot   system boot  3.10.0-957.10.1. Sun Apr 21 16:27 - 22:52 (1+06:24)   </span><br><span class="line">root     pts/1        192.168.101.1    Sat Apr 20 18:22 - crash  (22:05)    </span><br><span class="line">root     pts/0        192.168.101.1    Sat Apr 20 15:57 - crash (1+00:29)   </span><br><span class="line">reboot   system boot  3.10.0-862.el7.x Sat Apr 20 15:57 - 22:52 (2+06:54)   </span><br><span class="line">root     pts/1        192.168.101.1    Sat Apr 20 12:42 - down   (03:14)    </span><br><span class="line">root     pts/1        192.168.101.1    Sat Apr 20 12:40 - 12:40  (00:00)    </span><br><span class="line">root     pts/1        192.168.101.1    Sat Apr 20 12:37 - 12:37  (00:00)    </span><br><span class="line">root     pts/0        192.168.101.1    Sat Apr 20 11:06 - down   (04:50)    </span><br><span class="line">reboot   system boot  3.10.0-862.el7.x Sat Apr 20 11:06 - 15:57  (04:50)    </span><br><span class="line">root     pts/0        192.168.101.1    Fri Apr 19 17:13 - down   (01:16)    </span><br><span class="line">reboot   system boot  3.10.0-862.el7.x Fri Apr 19 16:37 - 18:30  (01:52)    </span><br><span class="line">root     pts/1        192.168.101.1    Wed Apr 17 13:12 - crash (2+03:25)   </span><br><span class="line">root     pts/0        192.168.101.1    Wed Apr 17 10:41 - crash (2+05:55)   </span><br><span class="line">reboot   system boot  3.10.0-862.el7.x Wed Apr 17 10:38 - 18:30 (2+07:51)   </span><br><span class="line">root     pts/0        192.168.101.1    Tue Apr 16 23:04 - down   (01:13)    </span><br><span class="line">reboot   system boot  3.10.0-862.el7.x Tue Apr 16 22:30 - 00:18  (01:48)    </span><br><span class="line">root     pts/1        192.168.101.1    Tue Apr 16 14:29 - down   (04:09)    </span><br><span class="line">root     pts/0        192.168.101.1    Tue Apr 16 10:42 - 16:39  (05:57)    </span><br><span class="line">reboot   system boot  3.10.0-862.el7.x Tue Apr 16 10:41 - 18:38  (07:57)    </span><br><span class="line">reboot   system boot  3.10.0-862.el7.x Tue Apr 16 02:05 - 18:38  (16:32)    </span><br><span class="line">root     pts/0        192.168.101.1    Tue Apr 16 02:05 - down   (00:00)    </span><br><span class="line">reboot   system boot  3.10.0-862.el7.x Tue Apr 16 02:05 - 02:05  (00:00)    </span><br><span class="line">root     pts/0        192.168.101.1    Tue Apr 16 02:02 - down   (00:00)    </span><br><span class="line">reboot   system boot  3.10.0-862.el7.x Tue Apr 16 02:01 - 02:02  (00:00)    </span><br><span class="line">root     pts/0        192.168.101.1    Tue Apr 16 02:00 - down   (00:00)    </span><br><span class="line">reboot   system boot  3.10.0-862.el7.x Tue Apr 16 01:59 - 02:00  (00:00)    </span><br><span class="line">root     pts/0        192.168.101.1    Tue Apr 16 01:59 - down   (00:00)    </span><br><span class="line">reboot   system boot  3.10.0-862.el7.x Tue Apr 16 01:59 - 01:59  (00:00)    </span><br><span class="line">root     pts/0        192.168.101.1    Tue Apr 16 01:49 - down   (00:08)    </span><br><span class="line">root     pts/0        192.168.101.1    Tue Apr 16 01:45 - 01:49  (00:03)    </span><br><span class="line">root     pts/0        192.168.101.1    Tue Apr 16 01:34 - 01:45  (00:10)    </span><br><span class="line">reboot   system boot  3.10.0-862.el7.x Tue Apr 16 01:34 - 01:57  (00:23)    </span><br><span class="line">root     pts/0        192.168.101.1    Mon Apr 15 23:45 - down   (00:41)    </span><br><span class="line">reboot   system boot  3.10.0-862.el7.x Mon Apr 15 23:44 - 00:27  (00:42)    </span><br><span class="line">reboot   system boot  3.10.0-862.el7.x Mon Apr 15 18:00 - 00:27  (06:26)    </span><br><span class="line">root     pts/0        192.168.101.1    Mon Apr 15 17:59 - crash  (00:00)    </span><br><span class="line">reboot   system boot  3.10.0-862.el7.x Mon Apr 15 17:59 - 00:27  (06:27)    </span><br><span class="line">root     pts/0        192.168.101.1    Mon Apr 15 17:58 - crash  (00:01)    </span><br><span class="line">reboot   system boot  3.10.0-862.el7.x Mon Apr 15 17:57 - 00:27  (06:29)    </span><br><span class="line">root     pts/0        192.168.101.1    Mon Apr 15 17:45 - down   (00:09)    </span><br><span class="line">reboot   system boot  3.10.0-862.el7.x Mon Apr 15 17:45 - 17:55  (00:10)    </span><br><span class="line">root     pts/0        192.168.101.1    Mon Apr 15 17:44 - down   (00:00)    </span><br><span class="line">reboot   system boot  3.10.0-862.el7.x Mon Apr 15 17:43 - 17:44  (00:01)    </span><br><span class="line">root     pts/0        192.168.101.1    Mon Apr 15 17:06 - crash  (00:36)    </span><br><span class="line">root     pts/0        192.168.101.1    Mon Apr 15 16:45 - 17:06  (00:21)    </span><br><span class="line">reboot   system boot  3.10.0-862.el7.x Mon Apr 15 16:43 - 17:44  (01:00)    </span><br><span class="line">root     pts/0        192.168.101.1    Sat Apr 13 15:44 - 04:36  (12:51)    </span><br><span class="line">reboot   system boot  3.10.0-862.el7.x Sat Apr 13 15:44 - 11:54  (20:10)    </span><br><span class="line">reboot   system boot  3.10.0-862.el7.x Sat Apr 13 15:43 - 11:54  (20:11)    </span><br><span class="line">reboot   system boot  3.10.0-862.el7.x Sat Apr 13 15:42 - 15:42  (00:00)    </span><br><span class="line">root     pts/0        192.168.101.1    Tue Apr  9 17:58 - down   (01:04)    </span><br><span class="line">reboot   system boot  3.10.0-862.el7.x Tue Apr  9 17:58 - 19:03  (01:04)    </span><br><span class="line">root     pts/0        192.168.101.1    Mon Apr  8 01:05 - down   (00:27)    </span><br><span class="line">root     pts/0        192.168.101.1    Sun Apr  7 23:35 - 01:05  (01:29)    </span><br><span class="line">reboot   system boot  3.10.0-862.el7.x Sun Apr  7 23:34 - 01:32  (01:57)    </span><br><span class="line">root     pts/0        192.168.101.1    Sun Apr  7 20:43 - down   (00:03)    </span><br><span class="line">reboot   system boot  3.10.0-862.el7.x Sun Apr  7 20:43 - 20:47  (00:04)</span><br></pre></td></tr></table></figure><p><strong>2）只显示前10行信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ~]<span class="comment"># last -10</span></span><br><span class="line">root     pts/2        192.168.101.1    Wed May  1 22:51   still logged <span class="keyword">in</span>   </span><br><span class="line">root     pts/1        192.168.101.1    Wed May  1 22:51   still logged <span class="keyword">in</span>   </span><br><span class="line">kkutysll pts/1        192.168.101.1    Wed May  1 18:17 - 22:51  (04:33)    </span><br><span class="line">root     pts/1        192.168.101.1    Wed May  1 18:13 - 18:17  (00:04)    </span><br><span class="line">root     pts/0        192.168.101.1    Wed May  1 16:35   still logged <span class="keyword">in</span>   </span><br><span class="line">reboot   system boot  3.10.0-957.10.1. Wed May  1 16:35 - 22:59  (06:24)    </span><br><span class="line">root     pts/0        192.168.101.1    Mon Apr 29 16:42 - 18:05  (01:23)    </span><br><span class="line">reboot   system boot  3.10.0-957.10.1. Mon Apr 29 16:41 - 22:59 (2+06:17)   </span><br><span class="line">root     pts/1        192.168.101.1    Sun Apr 28 19:14 - crash  (21:27)    </span><br><span class="line">root     pts/0        192.168.101.1    Sun Apr 28 16:53 - crash  (23:48)</span><br></pre></td></tr></table></figure><p><strong>3）显示指定用户登录情况</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ~]<span class="comment"># last kkutysllb</span></span><br><span class="line">kkutysll pts/1        192.168.101.1    Wed May  1 18:17 - 22:51  (04:33)    </span><br><span class="line">kkutysll tty1                          Tue Apr 23 00:17 - 00:17  (00:00)    </span><br><span class="line">wtmp begins Sun Apr  7 20:43:09 2019</span><br></pre></td></tr></table></figure><h2 id="lastb：显示用户登录失败的记录"><a href="#lastb：显示用户登录失败的记录" class="headerlink" title="lastb：显示用户登录失败的记录"></a>lastb：显示用户登录失败的记录</h2><p>lastb命令可以从日志文件/var/log/btmp中读取信息，并显示用户登录失败的记录，用于发现系统登录异常。</p><p><strong>语法格式：lastb [option]</strong> </p><p><strong>重要选项参数：</strong></p><p><img src="https://i.loli.net/2019/05/02/5cc9ceeb16911.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>显示用户登录失败的列表</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ~]<span class="comment"># lastb</span></span><br><span class="line">kkutysll ssh:notty    192.168.101.1    Wed May  1 18:21 - 18:21  (00:00)    </span><br><span class="line">kkutysll ssh:notty    192.168.101.1    Wed May  1 18:20 - 18:20  (00:00)    </span><br><span class="line">kkutysll ssh:notty    192.168.101.1    Wed May  1 18:20 - 18:20  (00:00)    </span><br><span class="line">btmp begins Wed May  1 18:20:46 2019</span><br></pre></td></tr></table></figure><p><strong><em>需要多加注意这个命令执行的结果，如果发现未知的登录失败信息，那就要考虑系统是否遭到暴力破解登录。</em></strong></p><h2 id="lastlog：显示所有用户的最近登录记录"><a href="#lastlog：显示所有用户的最近登录记录" class="headerlink" title="lastlog：显示所有用户的最近登录记录"></a>lastlog：显示所有用户的最近登录记录</h2><p>lastlog命令从日志文件/var/log/lastlog中读取信息，并显示所有用户的最近登录记录，用于查看系统是否有异常登录。</p><p><strong>语法格式：lastlog</strong></p><p><strong>【使用示例】</strong></p><p><strong>显示所有用户的最近登录记录</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ~]<span class="comment"># lastlog </span></span><br><span class="line">Username         Port     From             Latest</span><br><span class="line">root             pts/0                     Wed May  1 22:57:53 +0800 2019</span><br><span class="line">bin                                        **Never logged <span class="keyword">in</span>**</span><br><span class="line">daemon                                     **Never logged <span class="keyword">in</span>**</span><br><span class="line">adm                                        **Never logged <span class="keyword">in</span>**</span><br><span class="line">lp                                         **Never logged <span class="keyword">in</span>**</span><br><span class="line">sync                                       **Never logged <span class="keyword">in</span>**</span><br><span class="line">shutdown                                   **Never logged <span class="keyword">in</span>**</span><br><span class="line">halt                                       **Never logged <span class="keyword">in</span>**</span><br><span class="line">mail                                       **Never logged <span class="keyword">in</span>**</span><br><span class="line">operator                                   **Never logged <span class="keyword">in</span>**</span><br><span class="line">games                                      **Never logged <span class="keyword">in</span>**</span><br><span class="line">ftp                                        **Never logged <span class="keyword">in</span>**</span><br><span class="line">nobody                                     **Never logged <span class="keyword">in</span>**</span><br><span class="line">systemd-network                            **Never logged <span class="keyword">in</span>**</span><br><span class="line">dbus                                       **Never logged <span class="keyword">in</span>**</span><br><span class="line">polkitd                                    **Never logged <span class="keyword">in</span>**</span><br><span class="line">tss                                        **Never logged <span class="keyword">in</span>**</span><br><span class="line">sshd                                       **Never logged <span class="keyword">in</span>**</span><br><span class="line">postfix                                    **Never logged <span class="keyword">in</span>**</span><br><span class="line">chrony                                     **Never logged <span class="keyword">in</span>**</span><br><span class="line">ntp                                        **Never logged <span class="keyword">in</span>**</span><br><span class="line">ett                                        **Never logged <span class="keyword">in</span>**</span><br><span class="line">user02                                     **Never logged <span class="keyword">in</span>**</span><br><span class="line">user03                                     **Never logged <span class="keyword">in</span>**</span><br><span class="line">kkutysllb        pts/0                     Wed May  1 22:54:01 +0800 2019</span><br><span class="line">test01           pts/0                     Wed May  1 22:02:48 +0800 2019</span><br><span class="line">test02                                     **Never logged <span class="keyword">in</span>**</span><br><span class="line">test03                                     **Never logged <span class="keyword">in</span>**</span><br><span class="line">test04                                     **Never logged <span class="keyword">in</span>**</span><br><span class="line">test05                                     **Never logged <span class="keyword">in</span>**</span><br><span class="line">test06                                     **Never logged <span class="keyword">in</span>**</span><br><span class="line">test07                                     **Never logged <span class="keyword">in</span>**</span><br><span class="line">test08                                     **Never logged <span class="keyword">in</span>**</span><br><span class="line">test09                                     **Never logged <span class="keyword">in</span>**</span><br><span class="line">test10           pts/0                     Wed May  1 22:03:22 +0800 2019</span><br></pre></td></tr></table></figure><p><strong><em>上面显示Never logged in的表示从未登录过系统的用户，一般都是系统服务的虚拟用户。</em></strong></p><h2 id="chown：改变文件或目录的用户和用户组"><a href="#chown：改变文件或目录的用户和用户组" class="headerlink" title="chown：改变文件或目录的用户和用户组"></a>chown：改变文件或目录的用户和用户组</h2><p>chown命令用于改变文件或目录的用户和用户组。要授权的用户和组名，必须是Linux系统实际存在的。</p><p><strong>常用格式：</strong></p><ul><li><strong>chown 用户 文件或目录 #&lt;==仅仅授权用户。</strong></li><li><strong>chown :组 文件或目录 #&lt;==仅仅授权组。</strong></li></ul><p><strong>语法格式：chown [option] [OWNER][:[GROUP]] [file]，其中的“：”可以用“.”来代替</strong></p><p><strong>【重要选项参数】</strong></p><p><img src="https://i.loli.net/2019/05/02/5cc9cf580bc4e.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）更改文件所属的用户属性</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询userpass.txt文件的用户和用户组</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ls -l userpass.txt </span></span><br><span class="line">-rw-r--r-- 1 root root 160 May  1 21:59 userpass.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改userpass.txt文件用户为test01</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># chown test01 userpass.txt </span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ls -l userpass.txt </span></span><br><span class="line">-rw-r--r-- 1 test01 root 160 May  1 21:59 userpass.txt</span><br></pre></td></tr></table></figure><p><strong>2）更改文件所属的用户组</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更改userpass.txt文件的所属用户组为kkutysllb</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># chown .kkutysllb userpass.txt </span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ls -l userpass.txt </span></span><br><span class="line">-rw-r--r-- 1 test01 kkutysllb 160 May  1 21:59 userpass.txt</span><br></pre></td></tr></table></figure><p><strong>3 ）同时更改文件的用户和用户组</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更改userpass.txt文件的用户为kkutysllb，用户组为root</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># chown kkutysllb:root userpass.txt </span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ls -l userpass.txt </span></span><br><span class="line">-rw-r--r-- 1 kkutysllb root 160 May  1 21:59 userpass.txt</span><br></pre></td></tr></table></figure><p><strong>4）递归更改目录及目录下的所有子目录及文件的用户和用户组的属性</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询/home/test目录的所属用户和用户组信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ls -ld /home/test</span></span><br><span class="line">drwxr-xr-x 5 root root 45 May  1 23:16 /home/<span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-R选项，递归修改/home/test目录及其子目录的用户和用户组为kkutysllb:kkutysllb</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># chown -R kkutysllb:kkutysllb /home/test</span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ls -ld /home/test /home/test/stu01</span></span><br><span class="line">drwxr-xr-x 5 kkutysllb kkutysllb 45 May  1 23:16 /home/<span class="built_in">test</span></span><br><span class="line">drwxr-xr-x 3 kkutysllb kkutysllb 25 May  1 23:16 /home/<span class="built_in">test</span>/stu01</span><br></pre></td></tr></table></figure><h2 id="chmod：改变文件或目录权限"><a href="#chmod：改变文件或目录权限" class="headerlink" title="chmod：改变文件或目录权限"></a>chmod：改变文件或目录权限</h2><p>chmod命令是用来改变文件或目录权限的命令，但是只有文件的属主和超级用户root才能够执行这个命令。模式有两种格式：一种是采用权限字母和操作符表达式；另一种是采用数字。权限示意图如下：</p><p><img src="https://i.loli.net/2019/05/02/5cc9cfdde0f8a.jpg"></p><p><strong>语法格式：chmod [option] [mode] [file]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/05/02/5cc9cff386a72.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）权限字母和操作符表达式</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置所有权限为空</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># chmod a= userpass.txt </span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ls -l userpass.txt </span></span><br><span class="line">---------- 1 kkutysllb root 160 May  1 21:59 userpass.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置文件属主有执行权限</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># chmod u+x userpass.txt </span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ls -l userpass.txt </span></span><br><span class="line">---x------ 1 kkutysllb root 160 May  1 21:59 userpass.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置文件归属用户组有可写权限</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># chmod g+w userpass.txt </span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ls -l userpass.txt </span></span><br><span class="line">---x-w---- 1 kkutysllb root 160 May  1 21:59 userpass.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置其他用户对文件有可读权限</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># chmod o+r userpass.txt </span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ls -l userpass.txt </span></span><br><span class="line">---x-w-r-- 1 kkutysllb root 160 May  1 21:59 userpass.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复刚才的设置，即恢复用户的默认权限</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># chmod u=rwx,g=rx,o=x userpass.txt </span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ls -l userpass.txt </span></span><br><span class="line">-rwxr-x--x 1 kkutysllb root 160 May  1 21:59 userpass.txt</span><br></pre></td></tr></table></figure><p><strong>2）文件的数字权限授权</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置文件userpass.txt为归属用户组可读写执行，其他用户可读可执行</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># chmod 075 userpass.txt </span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ls -l userpass.txt </span></span><br><span class="line">----rwxr-x 1 kkutysllb root 160 May  1 21:59 userpass.txt</span><br></pre></td></tr></table></figure><p><strong>3） 使用-R选项递归授权目录</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 授权/home/test及其子目录所有用户可读，可写，可执行</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># chmod -R 777 /home/test</span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ls -ld /home/test /home/test/stu&#123;01..03&#125;</span></span><br><span class="line">drwxrwxrwx 5 kkutysllb kkutysllb 45 May  1 23:16 /home/<span class="built_in">test</span></span><br><span class="line">drwxrwxrwx 3 kkutysllb kkutysllb 25 May  1 23:16 /home/<span class="built_in">test</span>/stu01</span><br><span class="line">drwxrwxrwx 3 kkutysllb kkutysllb 25 May  1 23:16 /home/<span class="built_in">test</span>/stu02</span><br><span class="line">drwxrwxrwx 3 kkutysllb kkutysllb 25 May  1 23:16 /home/<span class="built_in">test</span>/stu03</span><br></pre></td></tr></table></figure><p><strong><em>Linux普通文件的读、写、执行权限说明</em></strong></p><p><img src="https://i.loli.net/2019/05/02/5cc9d0447fa4c.jpg"></p><p><strong><em>Linux目录的读、写、执行权限说明</em></strong></p><p><img src="https://i.loli.net/2019/05/02/5cc9d05b587fb.jpg"></p><h2 id="chgrp：更改文件用户组"><a href="#chgrp：更改文件用户组" class="headerlink" title="chgrp：更改文件用户组"></a>chgrp：更改文件用户组</h2><p>chgrp命令只用于更改文件的用户组，功能被chown取代了，了解一下即可。</p><p><strong>语法格式：chgrp [option] [group] [file]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/05/02/5cc9d07861f6f.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）修改文件的用户组属性信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看文件userpass.txt文件的用户组信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ll userpass.txt </span></span><br><span class="line">----rwxr-x 1 kkutysllb root 160 May  1 21:59 userpass.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改文件用户组为kkutysllb</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># chgrp kkutysllb userpass.txt </span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ll userpass.txt </span></span><br><span class="line">----rwxr-x 1 kkutysllb kkutysllb 160 May  1 21:59 userpass.txt</span><br></pre></td></tr></table></figure><p><strong>2）递归修改目录的用户组信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改/home/test目录及子目录的用户组为root</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># chgrp -R root /home/test</span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># ll -d /home/test/stu&#123;01..03&#125;</span></span><br><span class="line">drwxrwxrwx 3 kkutysllb root 25 May  1 23:16 /home/<span class="built_in">test</span>/stu01</span><br><span class="line">drwxrwxrwx 3 kkutysllb root 25 May  1 23:16 /home/<span class="built_in">test</span>/stu02</span><br><span class="line">drwxrwxrwx 3 kkutysllb root 25 May  1 23:16 /home/<span class="built_in">test</span>/stu03</span><br></pre></td></tr></table></figure><h2 id="umask：显示或设置权限掩码"><a href="#umask：显示或设置权限掩码" class="headerlink" title="umask：显示或设置权限掩码"></a>umask：显示或设置权限掩码</h2><p>umask是通过八进制的数值来定义用户创建文件或目录的默认权限。</p><p><strong>语法格式：umask [option] [mode]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/05/02/5cc9d0c58fb55.jpg"></p><p><strong>通过umask计算文件目录权限</strong></p><p><strong>文件权限计算：</strong>创建文件默认最大的权限为666（-rw-rw-rw-），默认创建的文件没有可执行权限x位。对于文件来说，umask的设置是在假定文件拥有八进制666的权限上进行的，文件的权限就是666减umask（umask的各个位数字也不能大于6，比如077就不符合条件）的掩码数值，如果得到的3位数字其每一位都是偶数，那么这就是最终结果；如果有若干位的数字是奇数，那么这个奇数需要加1变成偶数，最后得到全是偶数的结果。</p><p><strong>目录权限计算：</strong>创建目录默认最大权限777（-rwx-rwx-rwx），默认创建的目录属主是有x权限的，允许用户进入。对于目录来说，umask的设置是在假定文件拥有八进制777权限上进行，目录八进制权限777减去umask的掩码数值。</p><p><strong>【使用示例】</strong></p><p><strong>1）查看root用户和非root用户的umask值</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ~]<span class="comment"># umask </span></span><br><span class="line">0022               <span class="comment"># 超级用户root的umask值是0022</span></span><br><span class="line">[root@C7-Server01 ~]<span class="comment"># su - kkutysllb</span></span><br><span class="line">Last login: Wed May  1 22:54:01 CST 2019 on pts/0</span><br><span class="line">[kkutysllb@C7-Server01 ~]$ <span class="built_in">umask</span> </span><br><span class="line">0002              <span class="comment"># 普通用户的umask值是0002</span></span><br></pre></td></tr></table></figure><p><strong>上述结果意味着，通过root用户创建文件默认权限是644，目录默认权限是755；通过普通用户（普通用户名和用户组名相同的情况下）创建的文件默认权限是664，目录默认权限是775。详细情况参见示例2。</strong></p><p><strong>2）查询umask在系统配置文件的设置规则</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[kkutysllb@C7-Server01 ~]$ sed -n <span class="string">'59,63p'</span> /etc/profile</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$UID</span> -gt 199 ] &amp;&amp; [ <span class="string">"`/usr/bin/id -gn`"</span> = <span class="string">"`/usr/bin/id -un`"</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">umask</span> 002</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">umask</span> 022</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p><strong>上述结果是shell条件判断语句，有两个判断条件，且为与关系：</strong></p><p><strong>条件1是判断用户的uid是否大于199，条件2是判断用户名是否和用户组名相同，当两个条件都满足时，则为普通用户，umask取值为002，否则为root用户，umask取值为022。</strong></p><p><strong>注意一点：普通用户的umask未必是002，比如满足以下条件，kkutysllb用户属于root组的时候，由于id-gn的执行结果不等于id-un的执行结果，所以umask值为022。</strong></p><p><strong>3）使用-p和-S选项</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-p选项，输出的权限掩码可直接作为命令来执行，也就是可以使用umask+数字更改umask的默认值</span></span><br><span class="line"></span><br><span class="line">[kkutysllb@C7-Server01 ~]$ <span class="built_in">umask</span> -p</span><br><span class="line"><span class="built_in">umask</span> 0002</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-S选项，</span></span><br><span class="line"></span><br><span class="line">[kkutysllb@C7-Server01 ~]$ <span class="built_in">umask</span> -S</span><br><span class="line">u=rwx,g=rwx,o=rx</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;useradd：创建用户&quot;&gt;&lt;a href=&quot;#useradd：创建用户&quot; class=&quot;headerlink&quot; title=&quot;useradd：创建用户&quot;&gt;&lt;/a&gt;useradd：创建用户&lt;/h2&gt;&lt;p&gt;useradd命令可用于创建新的用户或者更改用户的信息。在使用useradd命令时，若不加任何参数选项，后面直接跟所添加的用户名，那么系统首先会读取/etc/login.defs（用户定义文件）和/etc/default/useradd（用户默认配置文件）文件中所定义的参数和规则，然后根据所设置的规则添加用户，同时还会向/etc/passwd（用户文件）和/etc/group（组文件）文件内添加新用户和新用户组记录，向/etc/shadow（用户密码文件）和/etc/gshadow（组密码文件）文件里添加新用户和组对应的密码信息的相关记录。最后，系统还会根据/etc/default/useradd文件所配置的信息建立用户的家目录，并将/etc/skel中的所有文件（包括隐藏的环境配置文件）都复制到新用户的家目录中。
    
    </summary>
    
      <category term="Linux核心命令" scheme="https://kkutysllb.cn/categories/Linux%E6%A0%B8%E5%BF%83%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Linux" scheme="https://kkutysllb.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>2019-05-01-DPDK技术栈在电信云中的最佳实践（三）</title>
    <link href="https://kkutysllb.cn/2019/05/01/2019-05-01-DPDK%E6%8A%80%E6%9C%AF%E6%A0%88%E5%9C%A8%E7%94%B5%E4%BF%A1%E4%BA%91%E4%B8%AD%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://kkutysllb.cn/2019/05/01/2019-05-01-DPDK技术栈在电信云中的最佳实践（三）/</id>
    <published>2019-05-01T03:37:51.000Z</published>
    <updated>2019-05-02T04:08:46.791Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DPDK技术基础（3）"><a href="#DPDK技术基础（3）" class="headerlink" title="DPDK技术基础（3）"></a>DPDK技术基础（3）</h2><h3 id="网络报文转发模式"><a href="#网络报文转发模式" class="headerlink" title="网络报文转发模式"></a>网络报文转发模式</h3><p>我们来看看发展了十几年的DPDK，从Intel主导开发，到华为、思科、AWS等大厂商的加入，核心玩家都在该圈子里，拥有完善的社区，生态形成闭环。早期，主要是传统电信领域3层以下的应用，如华为、中国电信、中国移动都是其早期使用者，交换机、路由器、网关是主要应用场景。但是，随着上层业务的需求以及DPDK的完善，在更高的未来网络转发性能提升方面的应用也在逐步出现。<a id="more"></a></p><p>在x86服务器中，基于网络包的处理架构如下：</p><p><img src="https://i.loli.net/2019/05/01/5cc915c968f4a.jpg"></p><ul><li>Packet input：报文输入。</li><li>Pre-processing：对报文进行比较粗粒度的处理。</li><li>Input classification：对报文进行较细粒度的分流。</li><li>Ingress queuing：提供基于描述符的队列FIFO。</li><li>Delivery/Scheduling：根据队列优先级和CPU状态进行调度。</li><li>Accelerator：提供加解密和压缩/解压缩等硬件功能。</li><li>Egress queueing：在出口上根据QOS等级进行调度。</li><li>Post processing：后期报文处理释放缓存。</li><li>Packet output：从硬件上发送出去。</li></ul><p>可以看到在浅色和阴影对应的模块都是和硬件相关的，因此要提升这部分性能的最佳选择就是去选择网卡上或网络设备芯片上具有网络功能硬件卸载特性的设备，而在深色软件部分可以通过提高算法的效率和结合CPU相关的并行指令来提升网络性能。</p><p>传统的Network Processor（专用网络处理器）转发的模型可以分为<strong>run to completion（运行至终结，简称RTC）模型</strong>和<strong>pipeline（流水线）模型</strong>。</p><p><strong>1）pipeline模型：</strong>pipeline模型借鉴于工业上的流水线模型，将一个功能（大于模块级的功能）分解成多个独立的阶段，不同阶段间通过队列传递产品。这样，对于一些CPU密集和I/O密集的应用，通过pipeline模型，可以把CPU密集的操作放在一个微处理引擎上执行，将I/O密集的操作放在另外一个微处理引擎上执行。通过过滤器可以为不同的操作分配不同的线程，通过连接两者的队列匹配两者的处理速度，从而达到最好的并发效率。</p><p><img src="https://i.loli.net/2019/05/01/5cc915e413a43.jpg"></p><p>如上图所示，在NPA中最主要的就是TOP（Task Optimized Processor）单元，每个TOP单元都是对特定的事务进行过优化的特殊微处理单元，在处理特定的事务时会在性能上有较大的提升，一个报文从Input进入后会经历五个不同的TOP单元，每个TOP的输出又会是下个TOP的输入，这种硬件模型决定了在报文的不同处理中必须按照TOP的顺序来进行，不可能先进行报文修改再进行报文查找。如果需要这种顺序修改处理，必须从TOP修改这个单元将报文再回传到TOP解析上，但这样包的处理速度会大幅下降。</p><p><strong>2）run to completion模型：</strong>主要将一个程序分为几个不同的逻辑功能，但是这几个逻辑功能会在一个CPU的核上运行，可以进行水平扩展使得在SMP的系统中多个核上执行一样的逻辑，从而提高单位时间内事务处理的量。但是，由于每个核上的处理能力其实都是一样的，并没有针对某个逻辑功能进行优化，因此在这个层面上与pipeline模型比较，run to completion模型是不高效的。</p><p><img src="https://i.loli.net/2019/05/01/5cc9160409b80.jpg"></p><p>如上图所示，在AMCC 345x的模型中，对于报文的处理没有特殊的运算单元，只有两个NP核，两个NP核利用已烧录的微码进行报文的处理，如果把运行的微码看成处理报文的逻辑，两个NP核上总共可以跑48个任务，每个任务的逻辑都共享一份微码，则同一时刻可以处理48份网络报文。</p><p><strong>基于通用IA平台的DPDK中是怎么利用专用网络处理器中的这两种模型来进行高速包处理？如下图所示：</strong></p><p><img src="https://i.loli.net/2019/05/01/5cc91621d52cb.jpg"></p><blockquote><p>从RTC模型中（上图左边），我们可以清楚地看出，每个IA的物理核都负责处理整个报文的生命周期从RX到TX，这点非常类似前面所提到的AMCC的nP核的作用。</p><p>从pipeline模型中（上图右边），我们可以看出，报文的处理被划分成不同的逻辑功能单元A、B、C，一个报文需分别经历A、B、C三个阶段，这三个阶段的功能单元可以不止一个并且可以分布在不同的物理核上，不同的功能单元可以分布在相同的核上（也可以分布在不同的核上）。因此，其对于模块的分类和调用比EZchip的硬件方案更加灵活。</p></blockquote><p><strong>DPDK RTC模型</strong></p><p>普通的Linux网络驱动中的扩展方法如下：把不同的收发包队列对应的中断转发到指定核的local APIC（本地中断控制器）上，并且使得每个核响应一个中断，从而处理此中断对应的队列集合中的相关报文。</p><p>而在DPDK的轮询模式中主要通过一些DPDK中eal中的参数-c、-l、-lcores来设置哪些核可以被DPDK使用，最后再把处理对应收发队列的线程绑定到对应的核上。每个报文的整个生命周期都只可能在其中一个线程中出现。</p><p>和普通网络处理器的RTC模式相比，基于IA平台的通用CPU也有不少的计算资源，比如一个socket上面可以有独立运行的16运算单元（核），每个核上面可以有两个逻辑运算单元（thread）共享物理的运算单元。而多个socket可以通过QPI总线连接在一起，这样使得每一个运算单元都可以独立地处理一个报文，并且通用处理器上的编程更加简单高效，在快速开发网络功能的同时，利用硬件AES-NI、SHA-NI等特殊指令可以加速网络相关加解密和认证功能。RTC模型虽然有许多优势，但是针对单个报文的处理始终集中在一个逻辑单元上，无法利用其他运算单元，并且逻辑的耦合性太强，而流水线模型正好解决了以上的问题。下面我们来看DPDK的流水线模型，DPDK中称为Packet Framework。</p><p><strong>DPDK pipeline模型</strong></p><p>pipeline的主要思想就是不同的工作交给不同的模块，而每一个模块都是一个处理引擎，每个处理引擎都只单独处理特定的事务，每个处理引擎都有输入和输出，通过这些输入和输出将不同的处理引擎连接起来，完成复杂的网络功能。</p><p>DPDK pipeline的多处理引擎实例和每个处理引擎中的组成框图可见如下两个实例的图片：zoom out（多核应用框架）和zoom in（单个流水线模块）。</p><p><img src="https://i.loli.net/2019/05/01/5cc9165a5c616.jpg"></p><p><img src="https://i.loli.net/2019/05/01/5cc9166dc874d.jpg"></p><p>Zoom out的实例中包含了五个DPDK pipeline处理模块，每个pipeline作为一个特定功能的包处理模块。一个报文从进入到发送，会有两个不同的路径，上面的路径有三个模块（解析、分类、发送），下面的路径有四个模块（解析、查表、修改、发送）。Zoom in的图示中代表在查表的pipeline中有两张查找表，报文根据不同的条件可以通过一级表或两级表的查询从不同的端口发送出去。</p><p>DPDK的pipeline是由三大部分组成的，<strong>逻辑端口（port）、查找表（table）</strong>和<strong>处理逻辑（action）</strong>。DPDK的pipeline模型中把网络端口作为每个处理模块的输入，所有的报文输入都通过这个端口来进行报文的输入。查找表是每个处理模块中重要的处理逻辑核心，不同的查找表就提供了不同的处理方法。而转发逻辑指明了报文的流向和处理。</p><p><img src="https://i.loli.net/2019/05/01/5cc91683cc5b7.jpg"></p><p>用户可以根据以上三大类构建数据自己的pipeline，然后把每个pipeline都绑定在指定的核上从而使得我们能快速搭建属于我们自己的packet framework。<strong>DPDK实现报文转发上述两种方案的优缺点比较如下：</strong></p><p><img src="https://i.loli.net/2019/05/01/5cc91699eccdf.jpg"></p><h3 id="PCIe与包处理I-O"><a href="#PCIe与包处理I-O" class="headerlink" title="PCIe与包处理I/O"></a>PCIe与包处理I/O</h3><p>PCI Express（Peripheral Component Interconnect Express）又称PCIe，它是一种高速串行通信互联标准。PCIe规范遵循开放系统互联参考模型（OSI），自上而下分为<strong>事务传输层、数据链路层、物理层</strong>，如下图所示：</p><p><img src="https://i.loli.net/2019/05/01/5cc916c688d5f.jpg"></p><p>如果在PCIe的线路上抓取一个TLP（Transaction Layer Packet，事务传输层数据包），其格式是一种分组形式，层层嵌套，事务传输层也拥有头部、数据和校验部分。应用层的数据内容就承载在数据部分，而头部定义了一组事务类型。</p><p><img src="https://i.loli.net/2019/05/01/5cc916e0b3cbc.jpg"></p><p>应用层数据作为有效载荷被承载在事务传输层之上，网卡从线路上接收的以太网包整个作为有效载荷在PCIe的事务传输层上进行内部传输。对于PCIe事务传输层操作而言，应用层数据内容是透明的。一般网卡采用DMA控制器通过PCIe Bus访问内存，除了对以太网数据内容的读写外，还有DMA描述符操作相关的读写。</p><p>既然应用层数据只是作为有效载荷，那么PCIe协议的三层栈有多少额外开销呢？下图列出了每个部分的长度。物理层开始和结束各有1B的标记，整个数据链路层占用6B。TLP头部64位寻址占用16B（32位寻址占用12B），TLP中的ECRC为可选位。所以，对于一个完整的TLP包来说，除去有效载荷，额外还有24B的开销（TLP头部以16B计算）。</p><p><img src="https://i.loli.net/2019/05/01/5cc91700d43d4.jpg"></p><p>PCIe逐代的理论峰值带宽都有显著提升，Gen1到Gen2单路传输率翻倍，Gen2到Gen3虽然传输率没有翻倍，但随着编码效率的提升，实际单路有效传输仍然有接近一倍的提升，Gen1和Gen2采用8b/10b编码，Gen3采用128b/130b编码，如下所示：</p><p><img src="https://i.loli.net/2019/05/01/5cc91718c07ce.jpg"></p><p>以8b/10b编码为例，每10个比特传输8个比特（1个字节）的有效数据。以GEN2为例，传输1个字节数据需要500M*10b/s=500MB/s单向每路，对于8路同时传输8个字节数据就有4GB/s的理论带宽。</p><p>要查看特定PCIe设备的链路能力和当前速率，可以用Linux工具lspci读取PCIe的配置寄存器（Configuration Space），以下是在虚拟机中读出的信息展示，与实际物理服务器并不一致</p><p><img src="https://i.loli.net/2019/05/01/5cc917511d370.jpg"></p><p>除了TLP的协议开销以外，有时还会有实际实现的开销。比如有些网卡可能会要求每个TLP都要从Lane0开始，甚至要求从偶数的时钟周期开始。由于存在这样的实现因素影响，有效带宽还会进一步降低。同时，真实的网卡收发包由DMA驱动，除了写包内容之外，还有一系列的控制操作，这些操作也会进一步影响PCIe带宽的利用。</p><p><strong>DMA（Direct Memory Access，直接存储器访问）</strong>是一种高速的数据传输方式，允许在外部设备和存储器之间直接读写数据。数据既不通过CPU，也不需要CPU干预。整个数据传输操作在DMA控制器的控制下进行。除了在数据传输开始和结束时做一点处理外，在传输过程中CPU可以进行其他的工作。</p><p>网卡DMA控制器通过环形队列与CPU交互。环形队列由一组控制寄存器和一块物理上连续的缓存构成。主要的控制寄存器有Base、Size、Head和Tail。通过设置Base寄存器，可以将分配的一段物理连续的内存地址作为环形队列的起始地址，通告给DMA控制器。同样通过Size寄存器，可以通告该内存块的大小。Head寄存器往往对软件只读，它表示硬件当前访问的描述符单元。而Tail寄存器则由软件来填写更新，通知DMA控制器当前已准备好被硬件访问的描述符单元。</p><p>为Intel 82599网卡的收发描述符环形队列为例，硬件控制所有Head和Tail之间的描述符。如下所示：</p><p><img src="https://i.loli.net/2019/05/01/5cc91766e0634.jpg"></p><ol><li>Head等于Tail时表示队列为空，Head等于Next（Tail）时表示队列已满。</li><li>环形队列中每一条记录就是描述符。</li><li>描述符的格式和大小根据不同网卡各不相同，Intel 82599网卡的一个描述符大小为16B，整个环形队列缓冲区的大小必须是网卡支持的最大Cache line（128B））的整数倍，所以描述符的总数是8的倍数。</li><li>环形队列的起始地址也需要对齐到最大Cache line的大小。</li></ol><p><strong>无论网卡是工作在中断方式还是轮询方式下，判断包是否接收成功，或者包是否发送成功，都会需要检查描述符中的完成状态位（Descriptor Done，DD）。该状态位由DMA控制器在完成操作后进行回写。</strong></p><p>对网络帧的封装及处理有两种方式：将网络帧元数据（metadata）和帧本身存放在固定大小的同一段缓存中；或将元数据和网络帧分开存放在两段缓存里。前者的好处是高效：对缓存的申请及释放均只需要一个指令，缺点是因为缓存长度固定而网络帧大小不一，大部分帧只能使用填0（padding）的方式填满整个缓存，较为耗费内存空间。后者的优点则是相对自由：帧数据的大小可以任意，同时对元数据和网络帧的缓存可以分开申请及释放；缺点是低效，因为无法保证数据存在于一个Cache Line中，可能造成Hit Miss。</p><p>为保持包处理的效率，DPDK采用了前者。网络帧元数据的一部分内容由DPDK的网卡驱动写入，包括：VLAN标签、RSS哈希值、网络帧入口端口号以及巨型帧所占的Mbuf个数等。对于巨型帧，网络帧元数据仅出现在第一个帧的Mbuf结构中，其他的帧该信息为空。</p><blockquote><p>Mbuf主要用来封装网络帧缓存，也可用来封装通用控制信息缓存（缓存类型需使用CTRL_MBUF_FLAG来指定）。Mbuf结构报头经过精心设计，原先仅占1个Cache Line。随着Mbuf头部携带的信息越来越多，现在Mbuf头部已经调整成两个Cache Line，原则上将基础性、频繁访问的数据放在第一个Cache Line字节，而将功能性扩展的数据放在第二个Cache Line字节。Mbuf报头包含包处理所需的所有数据，对于单个Mbuf存放不下的巨型帧（Jumbo Frame），Mbuf还有指向下一个Mbuf结构的指针来形成帧链表结构。有兴趣的参见DPDK开发者手册。</p></blockquote><p>当一个网络帧被网卡接收时，DPDK的网卡驱动将其存储在一个高效的环形缓存区中，同时在Mbuf的环形缓存区中创建一个Mbuf对象。这两个行为都不涉及向系统申请内存，因为这些内存已经在内存池被创建时就申请好了。Mbuf对象被创建好后，网卡驱动根据分析出的帧信息将其初始化，并将其和实际帧对象逻辑相连。对网络帧的分析处理都集中于Mbuf，仅在必要的时候访问实际网络帧。这就是<strong>内存池的双环形缓存区结构</strong>。</p><h3 id="IO包处理中轮询和中断的抉择"><a href="#IO包处理中轮询和中断的抉择" class="headerlink" title="IO包处理中轮询和中断的抉择"></a>IO包处理中轮询和中断的抉择</h3><p>DPDK采用了轮询或者轮询混杂中断的模式来进行收包和发包，而以前网卡驱动程序基本都是基于异步中断处理模式。</p><p><strong>异步中断模式：</strong>当有包进入网卡收包队列后，网卡会产生硬件（MSIX/MSI/INTX）中断，进而触发CPU中断，进入中断服务程序，在中断服务程序来完成收包的处理。为了改善包处理性能，也可以在中断处理过程中加入轮询，来避免过多的中断响应次数。总之，基于异步中断信号模式的收包，是不断地在做中断处理，上下文切换，每次处理这种开销是固定的，累加带来的负荷显而易见。当有包需要发送出去的时候，基于异步中断信号的驱动程序会准备好要发送的包，配置好发送队列的各个描述符。在包被真正发送完成时，网卡同样会产生硬件中断信号，进而触发CPU中断，进入中断服务程序，来完成发包后的处理，例如释放缓存等。</p><p><strong>轮询模式：</strong>是指收发包完全不使用中断处理的高吞吐率的方式。DPDK所有的收发包有关的中断在物理端口初始化的时候都会关闭，也就是说，CPU这边在任何时候都不会收到收包或者发包成功的中断信号，也不需要任何收发包有关的中断处理。DPDK的轮询驱动程序负责初始化每一个收包描述符，包括把包缓冲内存块的物理地址填充到收包描述符对应的位置，以及把相应的收包成功标志复位。然后驱动程序修改相应的队列管理寄存器来通知网卡硬件，网卡硬件会把收到的包填充到对应的收包描述符表示的缓冲内存块里，同时标记好收包成功标志。当一个收包描述符所代表的缓冲内存块大小不够存放一个完整的包时，这时候候就需要两个甚至多个收包描述符来处理一个包。</p><p>1）每一个收包队列，DPDK都会有一个相应的线程负责轮询里面的收包描述符的收包成功的标志。一旦发现某一个收包描述符的收包成功标志被硬件置位了，就意味着有一个包已经进入到网卡，并且网卡已经存储到描述符对应的缓冲内存块里面，这时候驱动程序会解析相应的收包描述符，把收包缓冲内存块放到收包函数提供的数组里面，同时分配好一个新的缓冲内存块给这个描述符，以便下一次收包。</p><p>2）每一个发包队列，DPDK都会有一个相应的线程负责设置需要发送出去的包，DPDK的驱动程序负责提取发包缓冲内存块的有效信息，例如包长、地址、校验和信息、VLAN配置信息等。DPDK的轮询驱动程序根据内存缓存块中的包的内容来负责初始化每一个发包描述符。其中最关键的有两个，一个就是标识完整的包结束的标志EOP（End Of Packet），另外一个就是请求报告发送状态RS（Report Status）。</p><blockquote><p>由于一个包可能存放在一个或者多个内存缓冲块里面，需要一个或者多个发包描述符来表示一个等待发送的包，EOP就是驱动程序用来通知网卡硬件一个完整的包结束的标志。每当驱动程序设置好相应的发包描述符，硬件就可以开始根据发包描述符的内容来发包，那么驱动程序可能会需要知道什么时候发包完成，然后回收占用的发包描述符和内存缓冲块。基于效率和性能上的考虑，驱动程序可能不需要每一个发包描述符都报告发送结果，RS就是用来由驱动程序来告诉网卡硬件什么时候需要报告发送结果的一个标志。不同的硬件会有不同的机制，有的网卡硬件要求每一个包都要报告发送结果，有的网卡硬件要求相隔几个包或者发包描述符再报告发送结果，而且可以由驱动程序来设置具体的位置。</p></blockquote><p>3）发包的轮询就是轮询发包结束的硬件标志位。DPDK驱动程序根据需要发送的包的信息和内容，设置好相应的发包描述符，包含设置对应的RS标志，然后会在发包线程里不断查询发包是否结束。只有设置了RS标志的发包描述符，网卡硬件才会在发包完成时以写回的形式告诉发包结束。当驱动程序发现写回标志，意味着包已经发送完成，就释放对应的发包描述符和对应的内存缓冲块，这时候就全部完成了包的发送过程。</p><p><strong>混和中断轮询模式：</strong>由于实际网络中可能存在的潮汐效应，在某些时间段网络数据流量可能很低，甚至完全没有需要处理的包，这样完全轮询的方式会让处理器一直全速运行，明显浪费处理能力。因此在DPDK R2.1和R2.2陆续添加了<strong>收包中断与轮询的混合模式</strong>的支持，类似NAPI的思路，用户可以根据实际应用场景来选择完全轮询模式，或者混合中断轮询模式。而且，完全由用户来制定中断和轮询的切换策略，比如什么时候开始进入中断休眠等待收包，中断唤醒后轮询多长时间等等。所谓混合中断轮询模式，就是应用程序开始就是轮询收包，这时候收包中断是关闭的。但是当连续多次收到的包的个数为0，应用程序可以定义一个简单的策略来决定是否切换到中断以及什么时候让使能收包中断。轮询线程进入休眠之后，对应的核的运算能力就被释放出来，完全可以用于其他任何运算，或者干脆进入省电模式。当后续有任何包收到的时候，会产生一个收包中断，并且最终唤醒对应的应用程序收包线程。线程被唤醒后，就会关闭收包中断，再次轮询收包。应用程序完全可以根据不同的需要来定义不同的策略来让收包线程休眠或者唤醒收包线程。</p><p>1）DPDK的混合中断轮询机制是基于UIO或VFIO来实现其收包中断通知与处理流程的。如果是基于VFIO的实现，该中断机制是可以支持队列级别的，即一个接收队列对应一个中断号，这是因为VFIO支持多MSI-X中断号。如果是基于UIO的实现，该中断机制就只支持一个中断号，所有的队列共享一个中断号。</p><p>2）混合中断轮询模式相比完全轮询模式，会在包处理性能和时延方面有一定的牺牲，比如：当需要把DPDK工作线程从睡眠状态唤醒并运行，这样会引起中断触发后的第一个接收报文的时延增加。由于时延的增加，需要适当调整Mbuf队列的大小，以避免当大量报文同时到达时可能发生的丢包现象。</p><p><strong>综上，在应用场景下如何更高效地利用处理器的计算能力，用户需要根据实际应用场景来做出最合适的选择。</strong></p><h3 id="零拷贝技术"><a href="#零拷贝技术" class="headerlink" title="零拷贝技术"></a>零拷贝技术</h3><p>在每一次网络io过程，数据都要经过几个缓存，再发送出去。如下图：</p><p><img src="https://i.loli.net/2019/05/01/5cc917d7ecdd4.jpg"></p><p>上图右侧为client，左侧为Server为例：</p><ul><li>当Server收到Client发送的index.html文件的请求时，负责处理请求的httpd子进程/线程总是会先发起系统调用，让内核将index.html从存储设备中载入。但是加载到的位置是内核空间的缓冲区kernel buffer，而不是直接给进程/线程的内存区。由于是内存设备和存储设备之间的数据传输，没有CPU的参与，所以这是一次DMA操作。</li><li>当数据准备好后，内核唤醒httpd子进程/线程，让它使用read()函数把数据复制到它自己的缓冲区，也就是图中的app buffer。到了app buffer中的数据，已经独属于进程/线程，也就可以对它做读取、修改等等操作。由于这次是使用CPU来复制的，所以会消耗CPU资源。由于这个阶段从内核空间切换到用户空间，所以进行了上下文切换。</li><li>当数据修改完成(也可能没做任何操作)后，Server需要发送响应消息给Client，也就是说要通过TCP连接传输出去。但TCP协议栈有自己的缓冲区，要通过它发送数据，必须将数据写到它的buffer中，对于发送者就是send buffer，对于接受者就是recv buffer。于是，通过write()函数将数据再次从app buffer复制到send buffer。这次也是CPU参与进行的复制，所以会消耗CPU。同样也会进行上下文切换。</li><li>非本机数据最终还是会通过网卡传输出去的，所以再使用send()函数就可以将send buffer中的数据交给网卡并通过网卡传输出去。由于这次是内存和设备之间的数据传输，没有CPU的参与，所以这次也是一次DMA操作。</li><li>当Client的网卡收到响应数据后，将它传输到TCP的recv buffer。这是一次DMA操作。</li><li>数据源源不断地填充到recv buffer中，但是Client的应用程序却不一定会去读取，而是需要通知应用程序的进程使用recv()函数将数据从read buffer中取走。这次是CPU操作。</li></ul><p>在Server端，每次进程/线程需要一段数据时，总是先拷贝到kernel buffer，再拷贝到app buffer，再拷贝到socket buffer，最后再拷贝到网卡上。也就是说，总是会经过4段拷贝经历。通过分析上述4段拷贝，数据从存储设备到kernel buffer是必须的，从socket buffer到NIC也是必须的，但是从kernel buffer到app buffer却不一定。对于web服务来说，如果不修改http响应报文，数据完全可以不用经过用户空间。也就是不用再从kernel buffer拷贝到app buffer，这就是<strong>零复制</strong>的概念。</p><p>零复制的概念是避免将数据在内核空间和用户空间进行拷贝。主要目的是减少不必要的拷贝，避免让CPU做大量上下文切换。</p><p>mmap()函数将文件直接映射到用户程序的内存中，映射成功时返回指向目标区域的指针。这段内存空间可以用作进程间的共享内存空间，内核也可以直接操作这段空间。在映射文件之后，暂时不会拷贝任何数据到内存中，只有当访问这段内存时，发现没有数据，于是产生缺页访问，使用DMA操作将数据拷贝到这段空间中。可以直接将这段空间的数据拷贝到socket buffer中。所以也算是零复制技术。如图：</p><p><img src="https://i.loli.net/2019/05/01/5cc917f571530.jpg"></p><p>mmap()的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure><p>另外，sendfile()函数也是一种零复制函数。sendfile()函数借助文件描述符来实现数据拷贝：直接将文件描述in_fd的数据拷贝给文件描述符out_fd，其中in_fd是数据提供方，out_fd是数据接收方。文件描述符的操作都是在内核进行的，不会经过用户空间，所以数据不用拷贝到app buffer，实现了零复制。如下图所示：</p><p><img src="https://i.loli.net/2019/05/01/5cc918484ea5e.jpg"></p><p>sendfile()的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> </span></span><br><span class="line"><span class="keyword">ssize_t</span> sendfile(<span class="keyword">int</span> out_fd, <span class="keyword">int</span> in_fd, <span class="keyword">off_t</span> *offset, <span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure><p>还有一种常用的零拷贝技术就是<strong>COW（copy-on-write，写时复制）</strong>。当父进程fork生成子进程时，会复制它的所有内存页。这至少会导致两个问题：消耗大量内存；复制操作消耗时间。特别是fork后使用exec加载新程序时，由于会初始化内存空间，所以复制操作几乎是多余的。使用copy-on-write技术，使得在fork子进程时不复制内存页，而是共享内存页(也就是说，子进程也指向父进程的物理空间)，只有在该子进程需要修改某一块数据，才会将这一块数据拷贝到自己的app buffer中并进行修改，那么这一块数据就属于该子进程的私有数据，可随意访问、修改、复制。这在一定程度上实现了零复制，即使复制了一些数据块，也是在逐渐需要的过程进行复制的。</p><h3 id="网卡多队列技术"><a href="#网卡多队列技术" class="headerlink" title="网卡多队列技术"></a>网卡多队列技术</h3><p>多队列与流分类是当今网卡通用的技术。利用多队列及流分类技术可以使得网卡更好地与多核处理器、多任务系统配合，从而达到更高效IO处理的目的。说起网卡多队列，顾名思义，也就是传统网卡的DMA队列有多个，网卡有基于多个DMA队列的分配机制。</p><p>网卡多队列技术应该是与处理器的多核技术密不可分的。早期的多数计算机，处理器可能只有一个核，从网卡上收到的以太网报文都需要这个处理器处理。随着多核处理技术的发展，2007年在Intel的82575、82598网卡上引入多队列技术，可以将各个队列通过绑定到不同的核上来满足高速流量的需求。</p><p><strong>Linux内核对多队列的支持：</strong>众所周知，Linux的网卡由结构体net_device表示，一个该结构体可对应多个可以调度的数据包发送队列，数据包的实体在内核中以结构体sk_buff（skb）表示。网卡驱动程序为每个接收队列设定相应的中断号，通过中断的均衡处理，或者设置中断的亲和性（SMP IRQ Affinity），从而实现队列绑定到不同的核。Linux提供了较为灵活的队列选择机制。<strong>dev_pick_tx</strong>用于选取发送队列，可以由driver定制其策略，也可以根据队列优先级选取，按照hash来做均衡。也就是利用XPS（Transmit Packet Steering，内核2.6.38后引入）机制，智能地选择多队列设备的队列来发送数据包。为此，需要对CPU核到硬件队列做一个表来记录映射关系，每一个映射记录着专门分配的队列到一个CPU核列表，这个映射的CPU核负责完成队列中的数据传输。这样做的目的一是减少设备队列上的锁竞争，二是增加传输时的缓存命中概率。下面的代码简单说明了在发送时队列的选取是考虑在其中的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dev_queue_xmit</span><span class="params">(struct sk_buff *skb)</span> </span>&#123; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> = <span class="title">skb</span>-&gt;<span class="title">dev</span>;</span> </span><br><span class="line">txq = dev_pick_tx(dev, skb); <span class="comment">// 选出一个队列</span></span><br><span class="line">spin_lock_prefetch(&amp;txq-&gt;lock); </span><br><span class="line">dev_put(dev); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">struct netdev_queue *<span class="title">netdev_pick_tx</span><span class="params">(struct net_device *dev, struct sk_buff *skb)</span> </span>&#123; </span><br><span class="line"><span class="keyword">int</span> queue_index = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">if</span> (dev-&gt;real_num_tx_queues！= <span class="number">1</span>) &#123; </span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_device_ops</span> *<span class="title">ops</span> = <span class="title">dev</span>-&gt;<span class="title">netdev_ops</span>;</span> </span><br><span class="line"><span class="keyword">if</span> (ops-&gt;ndo_select_queue) queue_index = ops-&gt;ndo_select_queue(dev, skb); <span class="comment">// 按照driver提供的策略来选择一个队列的索引</span></span><br><span class="line"><span class="keyword">else</span> queue_index = __netdev_pick_tx(dev, skb); </span><br><span class="line">queue_index = dev_cap_txqueue(dev, queue_index); </span><br><span class="line">&#125; </span><br><span class="line">skb_set_queue_mapping(skb, queue_index); </span><br><span class="line"><span class="keyword">return</span> netdev_get_tx_queue(dev, queue_index); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，收发队列一般会被绑在同一个中断上，其目的也是为了增加cache命中率。</p><p>除了硬件支持的多队列技术外，还有软件支持的流量均衡技术，主要用于单队列网卡，将其上流量均衡的分摊到多个核上，该项技术就是RPS（Receive Packet Steering）。在接收侧，RPS主要是把软中断的负载均衡到CPU的各个core上，网卡驱动对每个流生成一个hash标识，这个hash值可以通过四元组（源IP地址SIP，源四层端口SPORT，目的IP地址DIP，目的四层端口DPORT）来计算，然后由中断处理的地方根据这个hash标识分配到相应的core上去，这样就可以比较充分地发挥多核的能力了。在发送侧，无论来自哪个CPU的数据包只能往这唯一的队列上发送。通俗点来说，就是在软件层面模拟实现硬件的多队列网卡功能，其实现机制如下图所示：</p><p><img src="https://i.loli.net/2019/05/01/5cc918c47c16b.jpg"></p><p><strong>DPDK对多队列的支持：</strong>观察DPDK提供的一系列以太网设备的API，可以发现其Packet I/O机制具有与生俱来的多队列支持功能，可以根据不同的平台或者需求，选择需要使用的队列数目，并可以很方便地使用队列，指定队列发送或接收报文。根据这样的特性，可以很容易实现CPU核、缓存与网卡队列之间的亲和性，从而达到很好的性能。除此之外，DPDK的队列管理机制还可以避免多核处理器中的多个收发进程采用自旋锁产生的不必要等待。以RTC模型为例，可以从核、内存与网卡队列之间的关系来理解DPDK是如何利用网卡多队列技术带来性能的提升：</p><p>1）将网卡的某个接收队列分配给某个核，从该队列中收到的所有报文都应当在该指定的核上处理。</p><p>2）从核对应的本地存储中分配内存池，接收报文和对应的报文描述符都位于该内存池。</p><p>3）为每个核分配一个单独的发送队列，发送报文和对应的报文描述符都位于该核和发送队列对应的本地内存池中。</p><p><strong>可以看出不同的核，操作的是不同的队列，从而避免了多个线程同时访问一个队列带来的锁的开销。</strong>那么，网卡是如何将网络中的报文分发到不同的队列呢？常用的方法有微软提出的RSS与英特尔提出的Flow Director技术，前者是根据哈希值希望均匀地将包分发到多个队列中。后者是基于查找的精确匹配，将包分发到指定的队列中。此外，网卡还可以根据优先级分配队列提供对QoS的支持。除此之外，网卡多队列机制还可以应用于虚拟化，详见后文《I/O虚拟化详解》。</p><p>高级的网卡设备可以分析出包的类型，包的类型会携带在接收描述符中，应用程序可以根据描述符快速地确定包是哪种类型的包，避免了大量的解析包的软件开销。DPDK的Mbuf结构中含有相应的字段来表示网卡分析出的包的类型，从下面的代码可见Packet_type由二层、三层、四层及tunnel的信息来组成，应用程序可以很方便地定位到它需要处理的报文头部或是内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span> &#123;</span></span><br><span class="line">…… </span><br><span class="line"><span class="keyword">union</span> &#123; </span><br><span class="line"><span class="keyword">uint32_t</span> packet_type; <span class="comment">/**&lt; L2/L3/L4 and tunnel information．*/</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">uint32_t</span> l2_type：<span class="number">4</span>; <span class="comment">/**&lt; (Outer) L2 type．*/</span> </span><br><span class="line"><span class="keyword">uint32_t</span> l3_type：<span class="number">4</span>; <span class="comment">/**&lt; (Outer) L3 type．*/</span> </span><br><span class="line">            <span class="keyword">uint32_t</span> l4_type：<span class="number">4</span>; <span class="comment">/**&lt; (Outer) L4 type．*/</span> </span><br><span class="line">            <span class="keyword">uint32_t</span> tun_type：<span class="number">4</span>; <span class="comment">/**&lt; Tunnel type．*/</span> </span><br><span class="line">            <span class="keyword">uint32_t</span> inner_l2_type：<span class="number">4</span>; <span class="comment">/**&lt; Inner L2 type．*/</span> </span><br><span class="line">            <span class="keyword">uint32_t</span> inner_l3_type：<span class="number">4</span>; <span class="comment">/**&lt; Inner L3 type．*/</span> </span><br><span class="line">            <span class="keyword">uint32_t</span> inner_l4_type：<span class="number">4</span>; <span class="comment">/**&lt; Inner L4 type．*/</span> </span><br><span class="line">        &#125;; </span><br><span class="line">&#125;; </span><br><span class="line">……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="网卡硬件卸载功能"><a href="#网卡硬件卸载功能" class="headerlink" title="网卡硬件卸载功能"></a>网卡硬件卸载功能</h3><p>网卡的硬件卸载功能可能是基于端口设置，也有可能是基于每个包设置使能，需要仔细区分。在包粒度而言，每个包都对应一个或者多个Mbuf，DPDK软件利用rte_mbuf数据结构里的64位的标识（ol_flags）来表征卸载与状态。</p><p>如果需要使用硬件卸载功能，网卡驱动需要提供相应的API给上层应用，通过调用API驱动硬件完成相应的工作。而驱动硬件的工作实际上是由网卡驱动程序完成的，网卡驱动程序也是通过硬件提供的接口来驱动硬件。硬件提供的接口一般包括寄存器（Register）和描述符（Descriptor）。寄存器是全局的设置，一般用于开启某项功能或者为某项功能设置全局性的参数配置，一般情况下是基于以太网端口为基本单位。描述符可以看做是每个数据包的属性，和数据包一起发送给硬件，一般用于携带单个数据包的参数或设置。</p><p>对于各种各样的硬件卸载功能，按照功能的相似性大致可分成三类，分别是<strong>计算及更新功能、分片功能、组包功能。</strong></p><p><strong>VLAN硬件卸载：</strong>VLAN在以太网报文中增加了了一个4字节的802.1q Tag（也称为VLAN Tag），如果由软件完成VLAN Tag的插入将会给CPU带来额外的负荷，涉及一次额外的内存拷贝（报文内容复制），最坏场景下，这可能是上百周期的开销。大多数网卡硬件提供了VLAN卸载的功能，VLAN Tag的插入和剥离由网卡硬件完成，可以减轻服务器CPU的负荷。</p><p>1）网卡最典型的卸载功能之一就是在接收侧针对VLAN进行包过滤。在网卡硬件端口设计了VLAN过滤表，无法在过滤表中匹配的VLAN包会被丢弃，没有VLAN信息的以太网则会通过网卡的过滤机制，在DPDK中app/testpmd提供了测试命令与实现代码。</p><p><img src="https://i.loli.net/2019/05/01/5cc91916474a0.jpg"></p><p>2）网卡硬件能够对接收到的包的VLAN Tag进行剥离。首先硬件能够对VLAN包进行识别，原理上是判断以太帧的以太网类型来确定是否是VLAN包。启动这项硬件特性，需要在网卡端口，或者是属于这个网卡端口的队列上设置使能标志，将VLAN剥离特性打开，对应到软件，是通过驱动将配置写入相应的寄存器。DPDK的app/testpmd提供了如何基于端口使能与去使能的测试命令：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testpmd&gt; <span class="function">vlan <span class="built_in">set</span> <span class="title">strip</span> <span class="params">(on|off)</span> <span class="params">(port_id)</span></span></span><br><span class="line">testpmd&gt; vlan set stripq (on|off) (port_id,queue_id)</span><br></pre></td></tr></table></figure><p>3）网卡硬件会将4字节的VLAN tag从数据包中剥离，VLAN Tag中包含的信息对上层应用是有意义的，不能丢弃，此时，网卡硬件会在硬件描述符中设置两个域，将需要的信息通知驱动软件，包含此包是否曾被剥离了VLAN Tag以及被剥离的Tag。软件省去了剥离VLAN Tag的工作负荷，还获取了需要的信息。在DPDK中，驱动会根据硬件描述符信息对每个接收的数据包进行检测，如果剥离动作发生，需要将rte_mbuf数据结构中的<strong>PKT_RX_VLAN_PKT</strong>置位，表示已经接收到VLAN的报文，并且将被剥离VLAN Tag写入到下列字段，供上层应用处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Struct rte_mbuf&#123; </span><br><span class="line"><span class="keyword">uint16_t</span> vlan_tci; <span class="comment">/**&lt; VLAN Tag Control Identifier(CPU order) */</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）在发送端口需要在数据包中插入VLAN标识。VLAN Tag由两部分组成：TPID（Tag Protocol Identifier），也就是VLAN的Ether type，和TCI（Tag Control Information）。TPID是一个固定的值，作为一个全局范围内起作用的值，可通过寄存器进行设置。而TCI是每个包相关的，需要逐包设置，在DPDK中，在调用发送函数前，必须提前设置mbuf数据结构中<strong>PKT_TX_VLAN_PKT</strong>位，同时将具体的Tag信息写入vlan_tci字段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span>&#123;</span> </span><br><span class="line"><span class="keyword">uint16_t</span> vlan_tci; <span class="comment">/**&lt; VLAN Tag Control Identifier(CPU order) */</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5）为了解决VLAN个数局限，业界发展出了采用双层乃至多层VLAN堆叠模式，随着这种模式（也被称为QinQ技术）在网络应用中变得普遍，现代网卡硬件大多提供对两层VLAN Tag进行卸载，如VLAN Tag的剥离、插入。DPDK的app/testapp应用中提供了测试命令，网卡数据手册有时也称VLAN Extend模式。在DPDK相应测试代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testpmd&gt; <span class="function">vlan <span class="built_in">set</span> <span class="title">qinq</span> <span class="params">(on|off)</span> <span class="params">(port_id)</span></span></span><br></pre></td></tr></table></figure><p><strong>checksum硬件卸载功能：</strong>checksum计算是网络协议的容错性设计的一部分，基于网络传输不可靠的假设，因此在Ethernet、IPv4、UDP、TCP、SCTP各个协议层设计中都有checksum字段，用于校验包的正确性，checksum不涉及复杂的逻辑，是简单机械的计算，算法稳定，适合固化到硬件中。checksum虽然可以硬件卸载，但依然需要软件的协同配合实现。checksum在收发两个方向上都需要支持，操作并不一致，在接收方向上，主要是检测，通过设置端口配置，强制对所有达到的数据报文进行检测，即判断哪些包的checksum是错误的，对于这些出错的包，可以选择将其丢弃，并在统计数据中体现出来。在DPDK中，和每个数据包都有直接关联的是rte_mbuf，网卡自动检测进来的数据包，如果发现checksum错误，就会设置错误标志。软件驱动会查询硬件标志状态，通过mbuf中的ol_flags字段来通知上层应用。但在发送侧就会复杂一些，硬件需要计算协议的checksum，将且写入合适的位置。。在原理上，网卡在设计之初时就依赖软件做额外设置，软件需要逐包提供发送侧上下文状态描述符，这段描述符需要通过PCIe总线写入到网卡设备内，帮助网卡进行checksum计算。设置上下文状态描述符，在DPDK驱动里面已经实现，对于使用DPDK的程序员，真正需要做的工作是设置rte_mbuf和改写报文头部，保证网卡驱动得到足够的mbuf信息，完成整个运算。</p><p>1）从设置mbuf的角度，需要关注如下字段：<strong>IPv6头部没有checksum字段，无需计算。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* fields to support TX offloads */</span> </span><br><span class="line"><span class="keyword">uint64_t</span> tx_offload; <span class="comment">/**&lt; combined for easy fetch */</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line"><span class="keyword">uint64_t</span> l2_len：<span class="number">7</span>; <span class="comment">/**&lt; L2 (MAC) Header Length．*/</span> </span><br><span class="line"><span class="keyword">uint64_t</span> l3_len：<span class="number">9</span>; <span class="comment">/**&lt; L3 (IP) Header Length．*/</span> </span><br><span class="line"><span class="keyword">uint64_t</span> l4_len：<span class="number">8</span>; <span class="comment">/**&lt; L4 (TCP/UDP) Header Length．*/</span> </span><br><span class="line"><span class="keyword">uint64_t</span> tso_segsz：<span class="number">16</span>; <span class="comment">/**&lt; TCP TSO segment size */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）对于IPv4的checksum，在发送侧如果需要硬件完成自动运算与插入，准备工作如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ipv4_hdr-&gt;hdr_checksum = <span class="number">0</span>; <span class="comment">// 将头部的checksum字段清零 </span></span><br><span class="line">ol_flags |= PKT_TX_IP_CKSUM; <span class="comment">// IP层checksum请求标识置位</span></span><br></pre></td></tr></table></figure><p>3）对于UDP或者TCP，checksum计算方法一样，准备工作如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">udp_hdr-&gt;dgram_cksum = <span class="number">0</span>; <span class="comment">// 将头部的checksum字段清零 </span></span><br><span class="line">ol_flags |= PKT_TX_UDP_CKSUM; <span class="comment">// UDP层checksum请求标识置位 </span></span><br><span class="line">udp_hdr-&gt;dgram_cksum = get_psd_sum(l3_hdr, info-&gt;ethertype, ol_flags); <span class="comment">/* 填入IP层伪头部计算码，具体实现参阅DPDK代码*/</span></span><br></pre></td></tr></table></figure><p>4）对于SCTP checksum计算方法一样，准备工作如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sctp_hdr-&gt;hdr_checksum = <span class="number">0</span>; ol_flags |= PKT_TX_SCTP_CKSUM;</span><br></pre></td></tr></table></figure><p><strong>TSO硬件卸载：</strong>TSO（TCP Segment Offload）是TCP分片功能的硬件卸载，显然这是发送方向的功能。TCP会协商决定发送的TCP分片的大小，对于从应用层获取的较大的数据，TCP需要根据下层网络的报文大小限制，将其切分成较小的分片发送。硬件提供的TCP分片硬件卸载功能可以大幅减轻软件对TCP分片的负担。而且这项功能本身也是非常适合由硬件来完成的，因为它是比较简单机械的实现。如下所示，就是采用TSO和不采用TSO的示意图：</p><p><img src="https://i.loli.net/2019/05/01/5cc91d176fb2c.jpg"></p><p>在下图中，我们可以看到，TCP分片需要将现有的较大的TCP分片拆分成较小的TCP分片，在这个过程中，不需要提供特殊的信息，<strong>仅仅需要复制TCP的包头，更新头里面的长度</strong>相关的信息，<strong>重新计算校验和</strong>，显然这些功能非常适合硬件来实现。</p><p><img src="https://i.loli.net/2019/05/01/5cc91f747fceb.jpg"></p><p>在dpdk/testpmd中提供了两条TSO相关的命令行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tso <span class="built_in">set</span> <span class="number">14000</span>：用于设置tso分片大小。</span><br><span class="line">tso show <span class="number">0</span>：用于查看tso分片的大小。</span><br></pre></td></tr></table></figure><p>和csum硬件卸载功能类似，tso分片硬件卸载功能也需要对mbuf进行设置，同样从设置mbuf的角度，如下字段需要关注：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* fields to support TX offloads */</span> </span><br><span class="line"><span class="keyword">uint64_t</span> tx_offload; <span class="comment">/**&lt; combined for easy fetch */</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line"><span class="keyword">uint64_t</span> l2_len：<span class="number">7</span>; <span class="comment">/**&lt; L2 (MAC) Header Length．*/</span> </span><br><span class="line"><span class="keyword">uint64_t</span> l3_len：<span class="number">9</span>; <span class="comment">/**&lt; L3 (IP) Header Length．*/</span> </span><br><span class="line"><span class="keyword">uint64_t</span> l4_len：<span class="number">8</span>; <span class="comment">/**&lt; L4 (TCP/UDP） Header Length．*/</span> </span><br><span class="line"><span class="keyword">uint64_t</span> tso_segsz：<span class="number">16</span>; <span class="comment">/**&lt; TCP TSO segment size */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时tso使用了ol_flag中的<strong>PKT_TX_TCP_SEG</strong>来指示收发包处理流程中当前的包需要开启tso的硬件卸载功能。</p><p><strong>RSC组包功能卸载：</strong>RSC（Receive Side Coalescing，接收方聚合）是TCP组包功能的硬件卸载。硬件组包功能针对TCP实现，是接收方向的功能，可以将拆分的TCP分片聚合成一个大的分片，从而减轻软件的处理。如下图所示，LRO是RCS的另一种表述，下图左边是通过硬件层面完成组包功能，下图右边是通过驱动层面完成组包。</p><p><img src="https://i.loli.net/2019/05/01/5cc91f8887da0.jpg"></p><p>当硬件接收到TCP分片后，硬件可以将多个TCP分片缓存起来，并且将其排序，这样多个TCP分片最终传递给软件时将会呈现为一个分片，软件将不再需要分析处理多个数据包的头，同时对TCP包的排序的负担也有所减轻。如下图所示：</p><p><img src="https://i.loli.net/2019/05/01/5cc91fa61ce3e.jpg"></p><p>RSC是一种硬件能力，使用此功能时需要先明确硬件支持此能力。我们通过配置来开启RSC功能，需要关注下面的数据结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * A structure used to configure the RX features of an Ethernet port. */</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_rxmode</span> &#123;</span> </span><br><span class="line"><span class="comment">/** The multi-queue packet distribution mode to be used, e.g．RSS．*/</span> </span><br><span class="line"><span class="keyword">enum</span> rte_eth_rx_mq_mode mq_mode; </span><br><span class="line"><span class="keyword">uint32_t</span> max_rx_pkt_len; <span class="comment">/**&lt; Only used if jumbo_frame enabled．*/</span> </span><br><span class="line"><span class="keyword">uint16_t</span> split_hdr_size; <span class="comment">/**&lt; hdr buf size (header_split enabled).*/</span> </span><br><span class="line"><span class="keyword">uint16_t</span> header_split：<span class="number">1</span>, <span class="comment">/**&lt; Header Split enable．*/</span> </span><br><span class="line">hw_ip_checksum ：<span class="number">1</span>, <span class="comment">/**&lt; IP/UDP/TCP checksum offload enable．*/</span> </span><br><span class="line">hw_vlan_filter ：<span class="number">1</span>, <span class="comment">/**&lt; VLAN filter enable．*/</span> </span><br><span class="line">hw_vlan_strip ：<span class="number">1</span>, <span class="comment">/**&lt; VLAN strip enable．*/</span> </span><br><span class="line">hw_vlan_extend ：<span class="number">1</span>, <span class="comment">/**&lt; Extended VLAN enable．*/</span> </span><br><span class="line">jumbo_frame ：<span class="number">1</span>, <span class="comment">/**&lt; Jumbo Frame Receipt enable．*/</span> </span><br><span class="line">hw_strip_crc ：<span class="number">1</span>, <span class="comment">/**&lt; Enable CRC stripping by hardware．*/</span> </span><br><span class="line">enable_scatter ：<span class="number">1</span>, <span class="comment">/**&lt; Enable scatter packets rx handler */</span> </span><br><span class="line">enable_lro ：<span class="number">1</span>; <span class="comment">/**&lt; Enable LRO */</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当对接收处理进行初始化<strong>ixgbe_dev_rx_init</strong>时，会调用ixgbe_set_rsc，此函数中对enable_lro进行判断，如果其为真，则会对RSC进行相关设置，从而使用此功能。</p><h2 id="DPDK在NFV中应用案例"><a href="#DPDK在NFV中应用案例" class="headerlink" title="DPDK在NFV中应用案例"></a>DPDK在NFV中应用案例</h2><p>回顾ETSI NFV参考架构，NFV技术通过运行在通用x86架构硬件上的虚拟化网络功能，通过软硬件解耦及功能抽象来实现各类网络功能在x86标准服务器上的灵活部署和业务的快速迭代。不同于典型数据中心业务和企业网业务，电信广域网业务要求网元（如DPI、FW等）具有高吞吐、低时延、海量流表支持、用户级QoS控制的特点。考虑到现实环境中的NFV解决方案一般由<strong>NFV基础设施</strong>和<strong>VNF</strong>两类系统服务商提供。因此，相应的NFV端到端性能优化，也应划分为底层的NFV基础设施性能与上层的VNF性能两类，以方便明确各自的性能瓶颈，避免不同层次的性能调优工作带来相互干扰。    </p><p>在NFV基础设施性能优化技术方案中，DPDK软件加速方案已成为一种普遍采用的基本方法，它以用户数据I/O通道优化为基础，结合了Intel VT技术、操作系统、虚拟化层与vSwitch等多种优化方案，已经形成了完善的性能加速整体架构，并提供了用户态API供高速转发类应用访问。</p><h3 id="场景一：VNF在物理机上应用"><a href="#场景一：VNF在物理机上应用" class="headerlink" title="场景一：VNF在物理机上应用"></a>场景一：VNF在物理机上应用</h3><p>运营商现有网络大部分都是专用网络设备，物理设备与应用软件紧耦合，设备升级成本高、功能扩展困难。将这些专用的网络功能设备，以软件化的VNF形式直接运行在物理服务器上，可以实现网络设备形态的通用化，方便设备功能灵活扩展。</p><p>该方案将一部分原来由硬件实现的网络功能，以VNF软件的形式直接运行在x86服务器OS上，同时在物理服务器上加载DPDK组件。此时，DPDK接管了物理网卡的I/O驱动， VNF也不再使用传统Linux内核网络协议栈，而是通过调用DPDK的用户态API进行快速转发。同时，DPDK进程将使用少量的处理器核（如2个核）与内存以满足高速转发处理， VNF 可以直接使用剩余的全部硬件资源，适用于数据转发频繁等资源利用率长期较高的网络业务，比如C/U分离后的U面网元采用VNF部署。该方案下整台服务器仅支持单一VNF应用，但因设备形态统一，软件功能部署灵活，仍具有较高应用价值。具体实现架构如下图所示：</p><p><img src="https://i.loli.net/2019/05/01/5cc9206f09584.jpg"></p><h3 id="场景二：VNF-OVS应用"><a href="#场景二：VNF-OVS应用" class="headerlink" title="场景二：VNF + OVS应用"></a>场景二：VNF + OVS应用</h3><p>当多个VNF分别运行在一台服务器的多个VM中时，为满足VNF之间可能的流量交换或者共享物理网卡的需要，可以在Host OS上安装OVS类虚拟交换机，用于连接各个VNF（VM）和服务器的物理网卡端口。此时，这多个VNF一般是不同类型的VNF应用，VNF之间可能产生交互流量或者业务链处理流量（东西+南北流量模型），而同类型多个VNF或者纯粹共享网卡的多个VNF，一般采用<strong>场景三的“VNF + SR-IOV”方案</strong>。</p><p>在“VNF + OVS”方案中，因主要的性能瓶颈存在于VNF的虚拟I/O通道和OVS交换机，DPDK需要分别安装在运行VNF的VM镜像内部和运行OVS的物理服务器OS上：前者用于优化VM内部的VNF数据平面转发性能，包括提供虚拟化网卡驱动、提供用户态转发API等，DPDK的各种配置方法与VNF运行在物理机中的机制类似，VNF并不能感知是运行在VM环境；后者用于优化OVS交换机性能，连接VM与各NUMA节点上的DPDK端口。该场景可以细分为两种：</p><p>​        A：VM到OVS仅使用单一连接。</p><p>​        B：VM到OVS采用一进一出的双向连接，如各类业务链中的VNF应用，见下图所示。</p><p><img src="https://i.loli.net/2019/05/01/5cc9208d47b71.jpg"></p><p>该方案可以实现VNF的灵活扩容/缩容，以及在资源池中按需迁移，方案中的第三方VNF厂商可以屏蔽物理设备差异，提供各自的高性能业务产品。同时，使用经过DPDK优化后的OVS 交换机，可以灵活实现VNF间流量的灵活转发与互联互通，节省硬件交换机。</p><h3 id="场景三：VNF-SR-IOV"><a href="#场景三：VNF-SR-IOV" class="headerlink" title="场景三：VNF + SR-IOV"></a>场景三：VNF + SR-IOV</h3><p>当多个VNF运行在VM中时，各VM的虚拟网卡可以直接连至HOST上支持SR-IOV功能的物理网卡（VF）进行数据收发，如同独占物理网卡一样。该方案适用于VNF间无需流量交互的场景，或者是基于硬件交换机进行VNF互连和流量控制的场景。由于旁路了HOST的虚拟化层实现直接转发，可以达到近似物理转发的性能，被业界普遍用于消除Hypervisor带来的数据转发性能影响。如下图所示：</p><p><img src="https://i.loli.net/2019/05/01/5cc920bf9fb36.jpg"></p><p>尽管“VNF+SR-IOV”方案消除了从物理网卡到VM虚拟网卡的性能瓶颈，但VM内部仍然需要通过加载DPDK以进一步优化各VNF（VM内部）的转发性能。此时，DPDK可以采用与前两种场景中类似的方法进行加载，同时占用VM内部一定CPU核和内存资源。</p><p><strong><em>综上，就是DPDK技术在电信云中最佳实践的全部内容，后续我们将开始讲述电信云中另一个重要领域内容–虚拟化。</em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;DPDK技术基础（3）&quot;&gt;&lt;a href=&quot;#DPDK技术基础（3）&quot; class=&quot;headerlink&quot; title=&quot;DPDK技术基础（3）&quot;&gt;&lt;/a&gt;DPDK技术基础（3）&lt;/h2&gt;&lt;h3 id=&quot;网络报文转发模式&quot;&gt;&lt;a href=&quot;#网络报文转发模式&quot; class=&quot;headerlink&quot; title=&quot;网络报文转发模式&quot;&gt;&lt;/a&gt;网络报文转发模式&lt;/h3&gt;&lt;p&gt;我们来看看发展了十几年的DPDK，从Intel主导开发，到华为、思科、AWS等大厂商的加入，核心玩家都在该圈子里，拥有完善的社区，生态形成闭环。早期，主要是传统电信领域3层以下的应用，如华为、中国电信、中国移动都是其早期使用者，交换机、路由器、网关是主要应用场景。但是，随着上层业务的需求以及DPDK的完善，在更高的未来网络转发性能提升方面的应用也在逐步出现。
    
    </summary>
    
      <category term="NFV关键技术" scheme="https://kkutysllb.cn/categories/NFV%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="电信云" scheme="https://kkutysllb.cn/tags/%E7%94%B5%E4%BF%A1%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>2019-04-30-DPDK技术栈在电信云中的最佳实践（二）</title>
    <link href="https://kkutysllb.cn/2019/05/01/2019-04-30-DPDK%E6%8A%80%E6%9C%AF%E6%A0%88%E5%9C%A8%E7%94%B5%E4%BF%A1%E4%BA%91%E4%B8%AD%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://kkutysllb.cn/2019/05/01/2019-04-30-DPDK技术栈在电信云中的最佳实践（二）/</id>
    <published>2019-05-01T03:15:45.000Z</published>
    <updated>2019-05-01T04:56:24.247Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DPDK技术基础（2）"><a href="#DPDK技术基础（2）" class="headerlink" title="DPDK技术基础（2）"></a>DPDK技术基础（2）</h2><h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a><strong>原子操作</strong></h3><p>虽然，DPDK提出理念之一就是<strong>“遵循资源局部化的原则，解耦数据的跨核共享，使得性能可以有很好的水平扩展”</strong>。这种跨核解耦数据并同步的的本质就是<strong>原子操作</strong>，所谓原子操作简单来说就是：<strong>多个线程执行一个操作时，其中任何一个线程要么可以完全执行完此操作，要么根本不执行。</strong>比如：在单处理器系统（UniProcessor）中，能够在单条指令中完成的操作都可以认为是“原子操作”，因为中断只能发生于指令之间。<a id="more"></a></p><p>在多核CPU的时代，架构中运行着多个独立的CPU，即使在单个指令中可以完成的操作也可能会被干扰。典型的例子就是decl指令（递减指令），它细分为三个过程：“读-&gt;改-&gt;写”，涉及两次内存操作。如果多个CPU运行的多个进程或线程在同时对同一块内存执行这个指令，那情况是无法预测的。</p><p>这里需要特别介绍一下<strong>CMPXCHG</strong>这条指令，它的语义是比较并交换操作数（CAS，Compare And Set）。而用<strong>XCHG类的指令做内存操作</strong>，CPU自动遵循LOCK语义，可见该指令是一条原子的CAS单指令操作，<strong>它是实现很多无锁数据结构的基础</strong>。CAS操作需要输入两个数值，一个旧值（期望操作前的值）和一个新值，在操作期间先比较下旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化，则不交换。比如：CMPXCHG r/m，r将累加器AL/AX/EAX/RAX中的值与首操作数（目的操作数）比较，如果相等，第2操作数（源操作数）的值装载到首操作数，zf置1。如果不等， 首操作数的值装载到AL/AX/EAX/RAX并将zf清0。该指令只能用于486及其后继机型。第2操作数（源操作数）只能用8位、16位或32位寄存器。第1操作数（目地操作数）则可用寄存器或任一种存储器寻址方式。我们通过下列代码可以对CMPXCHG指令（CAS)进行测试理解：</p><p><strong><em>1）不相等条件测试</em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>,c=<span class="number">0</span>;</span><br><span class="line">__asm&#123;</span><br><span class="line">mov eax,<span class="number">100</span>;</span><br><span class="line">mov a,eax</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a := "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">b = <span class="number">99</span>;</span><br><span class="line">c = <span class="number">11</span>;</span><br><span class="line">__asm&#123;</span><br><span class="line">mov ebx,b</span><br><span class="line">cmpxchg c,ebx</span><br><span class="line">mov a,eax    </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"b := "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"c := "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a := "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>输出:(如果不等， “首操作数”(c)的值装载到AL/AX/EAX/RAX并将zf清0)</em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="number">100</span></span><br><span class="line">b := <span class="number">99</span></span><br><span class="line">c := <span class="number">11</span></span><br><span class="line">a := <span class="number">11</span></span><br></pre></td></tr></table></figure><p><strong><em>2）相等条件测试</em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>,c=<span class="number">0</span>;</span><br><span class="line">__asm&#123;</span><br><span class="line">mov eax,<span class="number">100</span>;</span><br><span class="line">mov a,eax</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a := "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">b = <span class="number">99</span>;</span><br><span class="line">c = <span class="number">99</span>;</span><br><span class="line">__asm&#123;</span><br><span class="line">mov eax,<span class="number">99</span></span><br><span class="line">mov ebx,<span class="number">777</span></span><br><span class="line">cmpxchg c,ebx</span><br><span class="line">mov a,eax</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"b := "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"c := "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a := "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>输出:(如果相等，第2操作数（源操作数）的值装载到首操作数，zf置1)</em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="number">100</span></span><br><span class="line">b := <span class="number">99</span></span><br><span class="line">c := <span class="number">777</span></span><br><span class="line">a := <span class="number">99</span></span><br></pre></td></tr></table></figure><p>在x86平台上，CPU提供的硬件原子操作分为三种独立的原子锁机制：<strong>原子保证操作、加LOCK指令前缀</strong>和<strong>缓存一致性协议</strong>。我们这里只讨论软件原子锁机制，硬件原子锁有兴趣的详见英特尔的软件开发者手册《Volume 38.1LOCKED ATOMIC OPERATIO》章节。</p><p>软件级的原子操作实现依赖于硬件原子操作的支持。对于Linux而言，内核提供了两组原子操作接口：<strong>一组是针对整数进行操作</strong>；<strong>另一组是针对单独的位进行操作</strong>。针对整数的原子操作只能处理atomic_t类型的数据，这是一种抽象出来的整型数据类型结构，而没有使用C语言的int类型是因为：1）将原子操作涉及的数据与普通int类型数据进行区分；2）可以屏蔽不同硬件架构的差异性。而针对位的原子操作，在Linux内核中，原子位操作分别定义于include\linux\types.h和arch\x86\include\asm\bitops.h。</p><blockquote><p>尽管Linux支持的所有机器上的整型数据都是32位，但是使用atomic_t的代码只能将该类型的数据当作24位来使用。这个限制完全是因为在SPARC体系结构上，原子操作的实现不同于其他体系结构：32位int类型的低8位嵌入了一个锁，因为SPARC体系结构对原子操作缺乏指令级的支持，所以只能利用该锁来避免对原子类型数据的并发访问。</p></blockquote><p>原子操作在DPDK代码中的定义都在<strong>rte_atomic.h</strong>文件中，主要包含两部分：<strong>内存屏蔽</strong>和<strong>原16、32和64位的原子操作API</strong>。</p><ul><li><strong>rte_mb（）：内存屏障读写API</strong></li><li><strong>rte_wmb（）：内存屏障写API</strong></li><li><strong>rte_rmb（）：内存屏障读API</strong></li></ul><p>这三个API的实现在DPDK代码中没有什么区别，都是直接调用__sync_synchronize()。比如：在virtio_dev_rx()函数中，在读取avail-&gt;flags之前，加入内存屏障API以防止乱序的执行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*(<span class="keyword">volatile</span> <span class="keyword">uint16_t</span> *)&amp;vq-&gt;used-&gt;idx += count; </span><br><span class="line">vq-&gt;last_used_idx = res_end_idx; </span><br><span class="line"><span class="comment">/* flush used-&gt;idx update before we read avail-&gt;flags．*/</span> </span><br><span class="line">rte_mb(); </span><br><span class="line"><span class="comment">/* Kick the guest if necessary．*/</span> </span><br><span class="line"><span class="keyword">if</span> (！(vq-&gt;avail-&gt;flags &amp; VRING_AVAIL_F_NO_INTERRUPT)) </span><br><span class="line">eventfd_write(vq-&gt;callfd, (<span class="keyword">eventfd_t</span>)<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>DPDK代码中提供了16、32和64位原子操作的API，以rte_atomic64_add()API源代码为例，讲解一下DPDK中原子操作的实现，其代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rte_atomic64_add</span><span class="params">(<span class="keyword">rte_atomic64_t</span> *v, <span class="keyword">int64_t</span> inc)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">int</span> success = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">uint64_t</span> tmp; </span><br><span class="line"><span class="keyword">while</span> (success == <span class="number">0</span>) </span><br><span class="line">&#123; </span><br><span class="line">tmp = v-&gt;cnt; </span><br><span class="line">success = rte_atomic64_cmpset((<span class="keyword">volatile</span> <span class="keyword">uint64_t</span> *)&amp;v-&gt;cnt, tmp, tmp + inc); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个API中主要是使用了比较和交换的原子操作API函数rte_atomic64_cmpset()，里面通过嵌入汇编来实现，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rte_atomic64_cmpset(<span class="keyword">volatile</span> <span class="keyword">uint64_t</span> *dst, <span class="keyword">uint64_t</span> <span class="built_in">exp</span>, <span class="keyword">uint64_t</span> src) </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">uint8_t</span> res; </span><br><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">( MPLOCKED <span class="string">"cmpxchgq ％[src], ％[dst];"</span> <span class="string">"sete ％[res];"</span> ：[res] <span class="string">"=a"</span> (res), [dst] <span class="string">"=m"</span> (*dst) ：[src] <span class="string">"r"</span> (src), <span class="string">"a"</span> (<span class="built_in">exp</span>), <span class="string">"m"</span> (*dst) ：<span class="string">"memory"</span>)</span></span>; </span><br><span class="line"><span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在现网VXLAN的数据包校验和错包统计中，就是通过加上原子操作的数据包统计才能实现多核场景下的准确性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vxlan_rx_pkts</span><span class="params">(struct virtio_net *dev, struct rte_mbuf **pkts_burst, <span class="keyword">uint32_t</span> rx_count)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">uint32_t</span> i = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">uint32_t</span> count = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">int</span> ret; <span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span> *<span class="title">pkts_valid</span>[<span class="title">rx_count</span>];</span> </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; rx_count; i++) </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">if</span> (enable_stats) </span><br><span class="line">&#123; </span><br><span class="line">rte_atomic64_add( &amp;dev_statistics[dev-&gt;device_fh].rx_bad_ip_csum, (pkts_burst[i]-&gt;ol_flags &amp; PKT_RX_IP_CKSUM_BAD) ！= <span class="number">0</span>); </span><br><span class="line">rte_atomic64_add( &amp;dev_statistics[dev-&gt;device_fh].rx_bad_ip_csum, (pkts_burst[i]-&gt;ol_flags &amp; PKT_RX_L4_CKSUM_BAD) ！= <span class="number">0</span>); </span><br><span class="line">&#125;</span><br><span class="line">ret = vxlan_rx_process(pkts_burst[i]); </span><br><span class="line"><span class="keyword">if</span> (unlikely(ret &lt; <span class="number">0</span>)) <span class="keyword">continue</span>; </span><br><span class="line">pkts_valid[count] = pkts_burst[i]; count++; </span><br><span class="line">&#125; </span><br><span class="line">ret = rte_vhost_enqueue_burst(dev, VIRTIO_RXQ, pkts_valid, count); </span><br><span class="line"><span class="keyword">return</span> ret; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>何谓自旋锁（spin lock）？它是<strong>为实现保护共享资源而提出一种锁机制</strong>。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是<strong>自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，“自旋”一词就是因此而得名。</strong></p><p>自旋锁必须基于CPU的数据总线锁定，它通过读取一个<strong>内存单元（spinlock_t）</strong>来判断这个自旋锁是否已经被别的CPU锁住。如果否，它写进一个特定值，表示锁定了总线，然后返回。如果是，它会重复以上操作直到成功，或者spin次数超过一个设定值。</p><p>锁定数据总线的指令只能保证一个指令操作期间CPU独占数据总线。<strong>（自旋锁在锁定的时侯，不会睡眠而是会持续地尝试）</strong>。其作用是为了解决某项资源的互斥使用。因为自旋锁不会引起调用者睡眠，所以自旋锁的效率远高于互斥锁，但是它也有些不足之处：</p><ol><li>自旋锁一直占用CPU，它在未获得锁的情况下，一直运行——自旋，所以占用着CPU，如果不能在很短的时间内获得锁，这无疑会使CPU效率降低。</li><li>在用自旋锁时有可能造成死锁，当递归调用时有可能造成死锁，调用有些其他函数（如copy_to_user()、copy_from_user()、kmalloc()等）也可能造成死锁。</li></ol><p>因此，要慎重使用自旋锁，<strong>自旋锁只有在内核可抢占式或SMP的情况下才真正需要</strong>，在单CPU且不可抢占式的内核下，自旋锁的操作为空操作。<strong>自旋锁适用于锁使用者保持锁时间比较短的情况</strong>。</p><p><strong>Linux内核中的自旋锁API</strong></p><p>在Linux kernel实现代码中，自旋锁的实现与体系结构有关，所以相应的头文件&lt;asm/spinlock.h&gt;位于相关体系结构的代码中。</p><p><strong><em>在Linux内核中，自旋锁的基本使用方式如下：</em></strong></p><p>先声明一个spinlock_t类型的自旋锁变量，并初始化为“未加锁”状态。在进入临界区之前，调用加锁函数获得锁，在退出临界区之前，调用解锁函数释放锁。比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">spinlock_t</span> lock = SPIN_LOCK_UNLOCKED; </span><br><span class="line">spin_lock(&amp;lock);</span><br><span class="line"><span class="comment">/* 临界区 */</span> </span><br><span class="line">spin_unlock(&amp;lock);</span><br></pre></td></tr></table></figure><blockquote><p>spin_lock函数用于获得自旋锁，如果能够立即获得锁，它就马上返回，否则，它将自旋在那里，直到该自旋锁的保持者释放。spin_unlock函数则用于释放自旋锁。此外，还有一个spin_trylock函数用于尽力获得自旋锁，如果能立即获得锁，它获得锁并返回真；若不能立即获得锁，立即返回假。它不会自旋等待自旋锁被释放。</p></blockquote><p><strong><em>自旋锁使用时有两点需要注意：</em></strong></p><p>1）自旋锁是不可递归的，递归地请求同一个自旋锁会造成死锁。</p><p>2）线程获取自旋锁之前，要禁止当前处理器上的中断。</p><blockquote><p>比如：当前线程获取自旋锁后，在临界区中被中断处理程序打断，中断处理程序正好也要获取这个锁，于是中断处理程序会等待当前线程释放锁，而当前线程也在等待中断执行完后再执行临界区和释放锁的代码。</p></blockquote><p><strong>Linux中自旋锁方法汇总如下：</strong></p><p><img src="https://i.loli.net/2019/05/01/5cc91180f1466.jpg"></p><p><strong>DPDK自旋锁实现和应用</strong></p><p>DPDK中自旋锁API的定义在rte_spinlock.h文件中，其中下面三个API被广泛的应用在告警、日志、中断机制、内存共享和link bonding的代码中，用于临界资源的保护。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rte_spinlock_init(<span class="keyword">rte_spinlock_t</span> *sl)； <span class="comment">// 初始化自旋锁</span></span><br><span class="line">rte_spinlock_lock(<span class="keyword">rte_spinlock_t</span> *sl);  <span class="comment">// 获取自旋锁</span></span><br><span class="line">rte_spinlock_unlock (<span class="keyword">rte_spinlock_t</span> *sl); <span class="comment">// 释放自旋锁</span></span><br></pre></td></tr></table></figure><p>rte_spinlock_t定义如下，简洁并且简单:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * The rte_spinlock_t type. */</span> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> locked; </span><br><span class="line"><span class="comment">/**&lt; lock status 0 = unlocked, 1 = locked */</span> </span><br><span class="line">&#125; <span class="keyword">rte_spinlock_t</span>;</span><br></pre></td></tr></table></figure><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁实际是一种<strong>特殊的自旋锁</strong>，它把对共享资源的访问操作划分成读操作和写操作。这种锁相对于自旋锁而言，能提高并发性，因为在多处理器系统中，它允许同时有多个读操作来访问共享资源，最大可能的读操作数为实际的逻辑CPU数。写操作是排他性的，一个读写锁同时只能有一个写操作或多个读操作（与CPU数相关），但<strong>不能同时既有读操作又有写操作</strong>。</p><p><strong><em>读写锁除了和普通自旋锁一样有自旋特性以外，还有以下特点：</em></strong></p><ul><li><strong>读锁之间资源是共享的：</strong>即一个线程持有了读锁之后，其他线程也可以以读的方式持有这个锁。</li><li><strong>写锁之间是互斥的：</strong>即一个线程持有了写锁之后，其他线程不能以读或者写的方式持有这个锁。</li><li><strong>读写锁之间是互斥的：</strong>即一个线程持有了读锁之后，其他线程不能以写的方式持有这个锁。</li></ul><p><strong>每个共享资源关联一个唯一的读写锁，线程只允许以下方式访问共享资源：</strong></p><ol><li>申请锁。</li><li>获得锁后，读写共享资源。</li><li>释放锁。</li></ol><p>读写锁主要用于比较短小的代码片段，线程等待期间不能进入睡眠状态，因为睡眠/唤醒操作相当耗时，大大延长了获得锁的等待时间，所以读写锁适用的场景是要求<strong>忙等待。</strong>申请锁的线程必须不断地查询是否发生退出等待的事件，不能进入睡眠状态。</p><p><strong>Linux中读写锁主要API函数</strong></p><p><img src="https://i.loli.net/2019/05/01/5cc911dd982fe.jpg"></p><p><strong>上述API函数的定义在各个Linux内核文件的&lt;asm/rwlock.h&gt;中。</strong></p><p><strong>DPDK读写锁实现和应用</strong></p><p>DPDK读写锁的定义在rte_rwlock.h文件中，</p><ul><li>rte_rwlock_init（rte_rwlock_t*rwl）：初始化读写锁到unlocked状态。</li><li>rte_rwlock_read_lock（rte_rwlock_t*rwl）：尝试获取读锁直到锁被占用。</li><li>rte_rwlock_read_unlock（rte_rwlock_t*rwl）：释放读锁。</li><li>rte_rwlock_write_lock（rte_rwlock_t*rwl）：获取写锁。</li><li>rte_rwlock_write_unlock（rte_rwlock_t*rwl）：释放写锁。</li></ul><p>读写锁在DPDK中主要应用在下面几个地方，主要用于对操作的对象进行保护。</p><ol><li>在查找空闲的memory segment的时候，使用读写锁来保护memseg结构。LPM表创建、查找和释放。</li><li>Memory ring的创建、查找和释放。</li><li>ACL表的创建、查找和释放。</li><li>Memzone的创建、查找和释放等。</li></ol><p>比如：查找空闲的memory segment的时候，使用读写锁来保护memseg结构的代码实例如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Lookup for the memzone identified by the given name */</span> </span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rte_memzone</span> * </span></span><br><span class="line"><span class="class"><span class="title">rte_memzone_lookup</span>(<span class="title">const</span> <span class="title">char</span> *<span class="title">name</span>) </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_mem_config</span> *<span class="title">mcfg</span>;</span> </span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rte_memzone</span> *<span class="title">memzone</span> = <span class="title">NULL</span>;</span> </span><br><span class="line">mcfg = rte_eal_get_configuration()-&gt;mem_config; </span><br><span class="line">rte_rwlock_read_lock(&amp;mcfg-&gt;mlock); </span><br><span class="line">memzone = memzone_lookup_thread_unsafe(name); </span><br><span class="line">rte_rwlock_read_unlock(&amp;mcfg-&gt;mlock); </span><br><span class="line"><span class="keyword">return</span> memzone; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="无锁环形缓冲区"><a href="#无锁环形缓冲区" class="headerlink" title="无锁环形缓冲区"></a>无锁环形缓冲区</h3><p>高性能的服务器软件（例如，HTTP加速转发器）在大部分情况下是运行在多核服务器上的，当前的硬件可以提供32、64或者更多的CPU，在这种高并发的环境下，锁竞争机制有时会比数据拷贝、上下文切换等更伤害系统的性能。因此，在多核环境下，需要把重要的数据结构从锁的保护下移到无锁环境，以提高软件性能。现在无锁机制变得越来越流行，在特定的场合使用不同的无锁队列，可以节省锁开销，提高程序效率。Linux内核中有无锁队列的实现，可谓简洁而不简单。</p><p><strong>Linux内核无锁环形缓冲</strong></p><p>环形缓冲区通常有一个读指针和一个写指针。读指针指向环形缓冲区中可读的数据，写指针指向环形缓冲区中可写的数据。通过移动读指针和写指针就可以实现缓冲区的数据读取和写入。在通常情况下，环形缓冲区的读用户仅仅会影响读指针，而写用户仅仅会影响写指针。如果仅仅有一个读用户和一个写用户，那么不需要添加互斥保护机制就可以保证数据的正确性。但是，如果有多个读写用户访问环形缓冲区，那么必须添加互斥保护机制来确保多个用户互斥访问环形缓冲区。具体来讲，如果有多个写用户和一个读用户，那么只是需要给写用户加锁进行保护；反之，如果有一个写用户和多个读用户，那么只是需要对读用户进行加锁保护。</p><p>在Linux内核代码中，kfifo就是采用无锁环形缓冲的示例，kfifo是一种“First In First Out”数据结构，它采用了前面提到的环形缓冲区来实现，提供一个无边界的字节流服务。采用环形缓冲区的好处是，当一个数据元素被用掉后，其余数据元素不需要移动其存储位置，从而减少拷贝，提高效率。更重要的是，kfifo采用了并行无锁技术，kfifo实现的单生产/单消费模式的共享队列是不需要加锁同步的。详情可以参考Linux内核代码中的kififo的头文件（include/linux/kfifo.h）和源文件（kernel/kfifo.c）。</p><p><strong>DPDK无锁环形缓冲</strong></p><p>基于无锁环形缓冲的的原理，Intel DPDK提供了一套无锁环形缓冲区队列管理代码。支持单生产者或者多生产者入队列，单消费者或多消费者出队列。下面会记录dpdk中是如何管理所有使用的无锁环形缓冲区以及无锁环形缓冲区中支持的一些操作。</p><p>DPDK中的rte_ring的数据结构定义，可以清楚地理解rte_ring的设计基础。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* * An RTE ring structure. * * The producer and the consumer have a head and a tail index．The particularity * of these index is that they are not between 0 and size(ring)．These indexes * are between 0 and 2^32, and we mask their value when we access the ring[] * field．Thanks to this assumption, we can dosubtractions between 2 index * values in a modulo-32bit base：that's why the overflow of the indexes is not * a problem. */</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_ring</span> &#123;</span> </span><br><span class="line">    <span class="keyword">char</span> name[RTE_RING_NAMESIZE]; <span class="comment">/**&lt; Name of the ring．*/</span> </span><br><span class="line">    <span class="keyword">int</span> flags; <span class="comment">/**&lt; Flags supplied at creation．*/</span> </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">/** Ring producer status．*/</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">prod</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">uint32_t</span> watermark; <span class="comment">/**&lt; Maximum items before EDQUOT．*/</span> </span><br><span class="line">    <span class="keyword">uint32_t</span> sp_enqueue; <span class="comment">/**&lt; True, if single producer．*/</span> </span><br><span class="line">    <span class="keyword">uint32_t</span> size; <span class="comment">/**&lt; Size of ring．*/</span> </span><br><span class="line">    <span class="keyword">uint32_t</span> mask; <span class="comment">/**&lt; Mask (size-1) of ring．*/</span> </span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">uint32_t</span> head; <span class="comment">/**&lt; Producer head．*/</span> </span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">uint32_t</span> tail; <span class="comment">/**&lt; Producer tail．*/</span> </span><br><span class="line">&#125; </span><br><span class="line">prod __rte_cache_aligned; </span><br><span class="line"></span><br><span class="line"><span class="comment">/** Ring consumer status．*/</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cons</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">uint32_t</span> sc_dequeue; <span class="comment">/**&lt; True, if single consumer．*/</span> </span><br><span class="line">    <span class="keyword">uint32_t</span> size; <span class="comment">/**&lt; Size of the ring．*/</span> </span><br><span class="line">    <span class="keyword">uint32_t</span> mask; <span class="comment">/**&lt; Mask (size-1) of ring．*/</span> </span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">uint32_t</span> head; <span class="comment">/**&lt; Consumer head．*/</span> </span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">uint32_t</span> tail; <span class="comment">/**&lt; Consumer tail．*/</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RTE_RING_SPLIT_PROD_CONS </span></span><br><span class="line">    &#125; </span><br><span class="line">    cons __rte_cache_aligned; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> </span></span><br><span class="line">    &#125; </span><br><span class="line">    cons;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RTE_LIBRTE_RING_DEBUG</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_ring_debug_stats</span> <span class="title">stats</span>[<span class="title">RTE_MAX_LCORE</span>];</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">void</span> * ring[<span class="number">0</span>] __rte_cache_aligned; </span><br><span class="line">                        <span class="comment">/**&lt; Memory space of ring starts here.</span></span><br><span class="line"><span class="comment">not volatile so need to be careful</span></span><br><span class="line"><span class="comment">dering */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从上面的定义可以看出，无锁环形缓冲区对象中定义了一个生产者对象和一个消费者对象，对应的也就是缓冲区的写对象和读对象。另外，也可以看出无锁环形缓冲区在内存中的组织形式是前面是无锁环形缓冲区对象本身，然后紧接着就是实际用于存储内容的环形队列，在某一时刻其内存布局如下图所示：</p><p><img src="https://i.loli.net/2019/05/01/5cc912d3a919f.jpg"></p><p>无锁环形缓冲区是一种通用的数据结构，所以可能会在多个地方使用，在dpdk中就会有多种情况会使用，比如内存池。所以，随之而来的一个问题就是dpdk如何管理其所使用的所有的无锁环形缓冲区？从它的源码实现(rte_ring.c/rte_ring.h)中我们可以找到答案，与此相关的部分源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">TAILQ_HEAD(rte_ring_list, rte_tailq_entry);</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rte_tailq_elem</span> <span class="title">rte_ring_tailq</span> = &#123;</span></span><br><span class="line">.name = RTE_TAILQ_RING_NAME,</span><br><span class="line">&#125;;</span><br><span class="line">EAL_REGISTER_TAILQ(rte_ring_tailq)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_ring</span> *</span></span><br><span class="line"><span class="class"><span class="title">rte_ring_create</span>(<span class="title">const</span> <span class="title">char</span> *<span class="title">name</span>, <span class="title">unsigned</span> <span class="title">count</span>, <span class="title">int</span> <span class="title">socket_id</span>,</span></span><br><span class="line"><span class="class"><span class="title">unsigned</span> <span class="title">flags</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> mz_name[RTE_MEMZONE_NAMESIZE];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_ring</span> *<span class="title">r</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_tailq_entry</span> *<span class="title">te</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rte_memzone</span> *<span class="title">mz</span>;</span></span><br><span class="line"><span class="keyword">ssize_t</span> ring_size;</span><br><span class="line"><span class="keyword">int</span> mz_flags = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_ring_list</span>* <span class="title">ring_list</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line">ring_list = RTE_TAILQ_CAST(rte_ring_tailq.head, rte_ring_list);</span><br><span class="line"><span class="comment">/* get the size of memory occupied by ring */</span></span><br><span class="line">ring_size = rte_ring_get_memsize(count);</span><br><span class="line">……</span><br><span class="line">te = rte_zmalloc(<span class="string">"RING_TAILQ_ENTRY"</span>, <span class="keyword">sizeof</span>(*te), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (te == <span class="literal">NULL</span>) &#123;</span><br><span class="line">RTE_LOG(ERR, RING, <span class="string">"Cannot reserve memory for tailq\n"</span>);</span><br><span class="line">rte_errno = ENOMEM;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">rte_rwlock_write_lock(RTE_EAL_TAILQ_RWLOCK);</span><br><span class="line">mz = rte_memzone_reserve(mz_name, ring_size, socket_id, mz_flags);</span><br><span class="line"><span class="keyword">if</span> (mz != <span class="literal">NULL</span>) &#123;</span><br><span class="line">r = mz-&gt;addr;</span><br><span class="line"><span class="comment">/* no need to check return value here, we already checked </span></span><br><span class="line"><span class="comment">the arguments above */</span></span><br><span class="line">rte_ring_init(r, name, count, flags);</span><br><span class="line"><span class="comment">/* 低维尾队列的entry存放着rte_ring的管理对象地址 */</span></span><br><span class="line">te-&gt;data = (<span class="keyword">void</span> *) r;</span><br><span class="line">r-&gt;memzone = mz;</span><br><span class="line"><span class="comment">/* 将存放着环形缓冲区对象的尾队列entry插入到低维尾队列的末端 */</span></span><br><span class="line">TAILQ_INSERT_TAIL(ring_list, te, next);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">r = <span class="literal">NULL</span>;</span><br><span class="line">RTE_LOG(ERR, RING, <span class="string">"Cannot reserve memory\n"</span>);</span><br><span class="line">rte_free(te);</span><br><span class="line">&#125;</span><br><span class="line">rte_rwlock_write_unlock(RTE_EAL_TAILQ_RWLOCK);</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的源码我们可以知道，dpdk是用尾队列来管理其所使用的所有无锁环形缓冲区的，也就是说一个尾队列中的元素就是一个无锁环形缓冲区对象。那用来管理所有无锁环形缓冲区的尾队列，dpdk又如何管理呢？在函数rte_ring_create()中可以看到管理着无锁环形缓冲区的尾队列头部是存放在一个类型为struct rte_tailq_elem的全局变量rte_ring_tailq的head成员中，其中struct rte_tailq_elem定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_tailq_elem</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_tailq_head</span> *<span class="title">head</span>;</span></span><br><span class="line">TAILQ_ENTRY(rte_tailq_elem) next;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> name[RTE_TAILQ_NAMESIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从struct rte_tailq_elem的定义可以看到，管理着无锁环形缓冲区尾队列的头部是另外一个尾队列的一个元素，类似的管理方式还用在了dpdk的内存池等数据结构中，所以<strong>在dpdk中采用了两级尾队列来管理所使用的数据结构</strong>。其实这样说也不完整，因为除了用二级尾队列来管理所使用的数据结构之外，dpdk还用了一个全局共享内存中的列表数组rte_config.mem_config-&gt;tailq_head[RTE_MAX_TAILQ]来分别存储这个二级尾队列中低维尾队列存放的元素，即管理某一种特定数据结构的尾队列头部。</p><p>接下来对dpdk中实现的无锁环形缓冲区所支持的操作做一个说明。从一开始说过无锁环形缓冲区支持单生产者或者多生产者入队列，单消费者或多消费者出队列等操作。其实从另外一个角度还可以说dpdk中的无锁环形缓冲区中支持两种出入队列的模式，即<strong>出入队列元素数目固定模式和尽力而为模式</strong>，出入队列元素数目固定模式就是说只有进入队列的元素数目达到指定数目才算操作成功，否则失败；而出入队列元素数目尽力而为模式就是说对于指定的数目，如果当时队列状态并不能满足，则以当时队列状态为准，尽可能满足指定的数目。比如：如果参数指定需要入队列3个元素，但队列中只剩下2个空闲空间，那么就将其中2个元素入队列，出队列情况同理。</p><p>下面以两个CPU核同时往队列各写入一个元素来介绍无锁环形缓冲区支持的多生产者入队列功能，其他的操作方式都可以从这里推演出来。在代码中多生产者入队列相关的函数为__rte_ring_mp_do_enqueue()，下面的流程也是根据这个函数整理出来的。</p><p> <strong>初始状态下生产者的头和尾指向了同一个位置。如下图所示：</strong></p><p><img src="https://i.loli.net/2019/05/01/5cc913863600e.jpg"></p><p>1）在两个核上，将r-&gt;prod.head和r-&gt;prod.tail分别拷贝到本地的临时变量prod_head和prod_tail中，然后将本地临时变量prod_next指向队列的下一个空闲位置。检查队列中是否有足够的空间，如果没有，则返回失败（如果是写入多个元素，没有足够剩余空间的话，则需要看指定的模式，如果是尽力而为模式，则尽可能往队列中写入元素；否则返回失败）。如下图所示：</p><p><img src="https://i.loli.net/2019/05/01/5cc913a0313aa.jpg"></p><p>2）使用CAS操作指令将本地变量prod_next的值赋值给r-&gt;prod.head，即<strong>两者指向同一个位置</strong>。CAS操作指令有如下特性：<strong>如果r-&gt;prod.head不等于本地变量prod_head，则CAS操作失败，代码重新从第一步开始执行；如果r-&gt;prod.head等于本地变量prod_head，则CAS操作成功，代码继续往后执行。</strong>在这里我们假定在核1上操作成功，那么对于核2该操作就会失败，核2会从第一步重新执行。如下图所示：</p><p><img src="https://i.loli.net/2019/05/01/5cc913b551fae.jpg"></p><p>3）核2上的CAS操作成功，核1上成功往环形缓冲区中写入了一个元素（obj4），接着核2也成功往环形缓冲区中写入了一个元素（obj5）。如下图所示：</p><p><img src="https://i.loli.net/2019/05/01/5cc913d1aef23.jpg"></p><p>4）在上一步中两个核都已经成功往环形缓冲区写入了一个元素，现在两个核都需要更新r-&gt;prod.tail。这里又有一个条件，就是只有r-&gt;prod.tail等于本地变量prod_head的核才能去更新r-&gt;prod.tail的值。从图中可以看到，目前只有在核1上才能满足这个条件，核2不满足，因此更新r-&gt;prod.tail的操作只在核1上进行，核2需要等待核1完成。如下图所示：</p><p><img src="https://i.loli.net/2019/05/01/5cc913eb83636.jpg"></p><p>5）在上一步中，一旦核1完成了更新r-&gt;prod.tail的操作，那么核2也能满足更新r-&gt;prod.tail的条件，核2此时也会去更新r-&gt;prod.tail。如下图所示：</p><p><img src="https://i.loli.net/2019/05/01/5cc9140382e11.jpg"></p><p>DPDK中的无锁环形缓冲区还有另一个特性，那就是充分利用了unsigned类型的回绕特点，这样对于缓冲区中已用空间和剩余空间的计算就得到了极大的简化，也使得生产者头和尾、消费者头和尾的下标值不局限在0和size(ring) – 1之间，只要在0和2^32 - 1范围之内即可。这一点可以参考dpdk的开发者文档，其具体实现也包含在了上节介绍的操作流程当中，感兴趣的可以去看下。参考文献<a href="http://dpdk.org/doc/guides/prog_guide/" target="_blank" rel="noopener">http://dpdk.org/doc/guides/prog_guide/</a></p><p><strong>以上部分是DPDK技术栈在电信云领域CPU密集性操作的优化技术介绍，后面第三篇部分将开始DPDK技术栈在电信云领域IO密集性操作的优化技术介绍和NFV的应用场景。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;DPDK技术基础（2）&quot;&gt;&lt;a href=&quot;#DPDK技术基础（2）&quot; class=&quot;headerlink&quot; title=&quot;DPDK技术基础（2）&quot;&gt;&lt;/a&gt;DPDK技术基础（2）&lt;/h2&gt;&lt;h3 id=&quot;原子操作&quot;&gt;&lt;a href=&quot;#原子操作&quot; class=&quot;headerlink&quot; title=&quot;原子操作&quot;&gt;&lt;/a&gt;&lt;strong&gt;原子操作&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;虽然，DPDK提出理念之一就是&lt;strong&gt;“遵循资源局部化的原则，解耦数据的跨核共享，使得性能可以有很好的水平扩展”&lt;/strong&gt;。这种跨核解耦数据并同步的的本质就是&lt;strong&gt;原子操作&lt;/strong&gt;，所谓原子操作简单来说就是：&lt;strong&gt;多个线程执行一个操作时，其中任何一个线程要么可以完全执行完此操作，要么根本不执行。&lt;/strong&gt;比如：在单处理器系统（UniProcessor）中，能够在单条指令中完成的操作都可以认为是“原子操作”，因为中断只能发生于指令之间。
    
    </summary>
    
      <category term="NFV关键技术" scheme="https://kkutysllb.cn/categories/NFV%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="电信云" scheme="https://kkutysllb.cn/tags/%E7%94%B5%E4%BF%A1%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>2019-04-28-未来网络如何重构</title>
    <link href="https://kkutysllb.cn/2019/04/29/2019-04-28-%E6%9C%AA%E6%9D%A5%E7%BD%91%E7%BB%9C%E5%A6%82%E4%BD%95%E9%87%8D%E6%9E%84/"/>
    <id>https://kkutysllb.cn/2019/04/29/2019-04-28-未来网络如何重构/</id>
    <published>2019-04-29T02:20:57.000Z</published>
    <updated>2019-04-29T02:41:38.329Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h2><p>虽然本人因为出差关系没有参加公司组织的现场培训，但是通过自学相关材料还是想谈一谈自己的一点浅见。</p><p>与其说是对5G认识，不如更广泛地将其定义为“未来网络”这个概念，来谈谈对未来网络的一点儿浅见；与其说是网络转型，不如更彻底说是网络重构；与其说是学习心得，不如说是我自己的思考，尤其是对现有网络如何重构的一点儿思考。<a id="more"></a></p><p>下面我将按照自己学习新东西的“3W”原则（即，What？Why？How？）做一具体阐述: </p><p>首先放张本文主体思路的架构图，让大家先有一点儿感性认识。接下来，开始进入正题。</p><p><img src="https://i.loli.net/2019/04/29/5cc6602945bfb.jpg"></p><h2 id="What？—网络重构的目标和趋势是什么？"><a href="#What？—网络重构的目标和趋势是什么？" class="headerlink" title="What？—网络重构的目标和趋势是什么？"></a>What？—网络重构的目标和趋势是什么？</h2><h3 id="什么是未来网络？"><a href="#什么是未来网络？" class="headerlink" title="什么是未来网络？"></a>什么是未来网络？</h3><p>广义上来说，未来网络应该是网络质量足够好、响应速度足够快、组网足够灵活、覆盖足够广、能能够连接人和万物、性价比足够好的庞大基础设。要满足上述复杂多变的要求，运营商必须先打破现在刚性网络架构的制约，构筑一个简洁、开放、敏捷和集约的新型网路架构。</p><p>狭义上来说，未来网络是以云计算、SDN和NFV为三大技术支柱的网络架构。云计算打破了网络与IT资源分离的局面，构筑了统一云化的虚拟资源池；SDN打破了控制与转发一体的封闭网路架构，实现网络软件可编程；NFV打破了软硬件一体的封闭网元架构，实现了网络资源虚拟化。</p><h3 id="网络重构的背景是什么？"><a href="#网络重构的背景是什么？" class="headerlink" title="网络重构的背景是什么？"></a>网络重构的背景是什么？</h3><p>现有的网络架构是在电话网时代建立的，是以本地电话网为基础、按照行政区域规划构建的省-市-县的分层分域管理体系。</p><p>随着云计算、大数据、“互联网+”、物理网、虚拟现实、人工智能等新技术与新业务的出现和加速发展，网络应用由消费型向生产型扩展，网络的连接也由人人互联向万物互联延伸，信息通信业面临新的机遇和挑战，开放、创新、融合成为重要趋势。而我们现有网络一直以来针对各类业务问题总是以出台具体解决方案的方式来解决，不仅各业务解决方案间不兼容，而且长期积累后形成一套十分复杂且僵化的业务流程，同时其烟囱式的网络架构在面对全新业务时变得越来越力不从心，这使得现有网络架构必须重新审视，重新定义，重新设计，重新架构。</p><h3 id="运营商网络重构的终极目标是什么？"><a href="#运营商网络重构的终极目标是什么？" class="headerlink" title="运营商网络重构的终极目标是什么？"></a>运营商网络重构的终极目标是什么？</h3><p>国内三大运营商—中国移动、中国电信和中国联通分别提出了网络重构的战略目标—NovoNet2020、CTNet2025和CUBE-Net2.0，核心是构建能够主动适应新业务发展需求的智能化柔性网络，实现网络基础设施巨大价值的重新释放。</p><p>而个人认为网络重构的战略目标应该是致力于实现根本性的转变：一是从互联网+被动地适应网络转变为网络主动、快速、灵活地适应网络应用；二是从传统的“烟囱式”分省、分专业的网络转变为“水平整合”的扁平化网络；三是从分层次、分专业基于中心端局（CO）的组网模式转变为以数据中心（DC）为核心的组网模式。</p><h3 id="未来网络的演进趋势是什么？"><a href="#未来网络的演进趋势是什么？" class="headerlink" title="未来网络的演进趋势是什么？"></a>未来网络的演进趋势是什么？</h3><p>网络作为我们的核心资源，也是我们实现战略转型的主要抓手。随着IT与CT融合，未来网络的演进趋势将有以下几个特征。</p><p><strong>1)</strong>     <strong>网络以DC（即Data Center，数据中心）为中心</strong></p><p>随着云计算、大数据等新技术的快速应用，网络的流量、流向已经发生了巨大变化。未来80%甚至更多的应用将部署在云上，DC正逐渐成为网络流量的中心。而现有的网络一般是以省-市-县的划分来组织，在这种逐级收敛的树状架构中，DC仅仅作为一种普通的接入点。因此，必须调整为以DC为中心的新型架构，以适应网络流量及流向变化的新趋势。</p><p><strong>2)</strong>     <strong>网络和云深度融合</strong></p><p>云计算的不断发展对网络带宽提出了越来越高的要求，用户需求的不断升级使得云网融合成为必然趋势。业务、IT和网络都可以基于云化技术实现和部署，但是当前云与网之间缺乏灵活互动的机制。比如：在现有的厂家给出的云网融合解决方案中，网络资源是随计算资源同步分配的，即NaaS服务打包在IaaS服务中一起提供给用户，相对于客户或业务的不同需求，两种资源调配存在一定的浪费。个人认为随着容器技术兴起，云化的网络资源池在提供计算、存储等虚拟化资源的同时，网络资源也可以随云资源池的需求而按需变动，即将NaaS从IaaS中拆分独立出来，通过SDN和NFV的跨域协同，真正实现计算、存储和网络资源的统一动态分配和调度，实现云与网的深度协同。</p><p><strong>3)</strong>     <strong>网络功能的软件化</strong></p><p>现有的网络以专有硬件设备为主，网络调整以及功能升级的周期很长，且成本较高，完全无法适应新兴业务的快速、灵活的特点。</p><p>随着SDN技术逐步成熟、北向接口标准化的制定，将进一步实现三层解耦，甚至通过定义东/西向接口的标准化来进一步解耦VNFM与VNF之间的对接，利用通用的硬件平台为功能网元提供统一的虚拟化运行环境，上层的网元功能按照应用层的模式统一通过软件来实现，软件的升级和更新不再与硬件绑定。一方面实现了网络容量的按需动态伸缩；另一方面利于业务的快速部署和升级，面对不同客户的不同业务需求也可灵活定制，也就是常说的切片网络概念。</p><p><strong>4)</strong>     <strong>集中管控、灵活智能</strong></p><p>由于现有网络以行政区域和地理位置划分，受此影响现有网络的管理的也是分段、分级进行。一个跨省链路的开通往往需在在十几个系统上制作几百条甚至上千条数据，同时还要历经多级流程的审批、确认，导致网络服务存在响应慢、资源利用率低下、端到端体验差等弊端。近期最典型的的例子就是江苏的全国虚假主叫拦截平台的升级，从2017年6月各省反馈误拦截VoLTE用户呼叫问题开始，一直到现在都因为跨省升级测试流程未完成而没法部署，各省目前只能采取临时规避措施进行规避。</p><p>网络功能软件化后，网络的控制与调度均可通过软件来实现，通过控制与转发分离等方式，使得网络的集中控制成为可能，从而可以更好地实现网络的敏捷部署及灵活调整，提供端到端的业务保障，满足客户全网一致性的体验要求。</p><h2 id="Why？—我们为什么要进行网络重构？"><a href="#Why？—我们为什么要进行网络重构？" class="headerlink" title="Why？—我们为什么要进行网络重构？"></a>Why？—我们为什么要进行网络重构？</h2><h3 id="我们现有网络面临什么样的挑战？"><a href="#我们现有网络面临什么样的挑战？" class="headerlink" title="我们现有网络面临什么样的挑战？"></a>我们现有网络面临什么样的挑战？</h3><p>近年来，随着网络承载业务的富丰，尤其互联网IT企业推出的业务体验逐渐与运营商推出的业务体验同一化，迫使运营商在当前网络运营中面临一系列挑战。</p><p><strong>1)</strong>     <strong>网络连接数和流量增长推动网络规模快速膨胀</strong></p><p>近期随着不限量套餐的普及，物联网行业兴起和发展，集团大连接战略布局，未来将有海量的设备和用户接入网络，连接将变得无处不在。宽带从连接十几亿将增长到几百亿，同时宽带流量将有10倍以上的增长。家庭千兆以及个人百兆服务将成为普遍服务，而一些新业务（如4K/8K视频、虚拟现实游戏、无人驾驶等）对网络丢包率、时延等QoS要求更苛刻。</p><p><strong>2)</strong>     <strong>业务云化和终端虚拟化将颠覆网络全局的流量模型</strong></p><p>随着云计算的发展，私有云、公有云的逐步普及，必将推动大规模的移动网络建设，用户对宽带的需求必将从基于覆盖的连接，转向基于内容和社交体验的连接。现有网络业务流量主要服务于网络终端节点之间的通信，符合泊松分布模型。但是，现在随着内容和社交体验业务对流量和流向进行牵引，导致业务流量难以预测。因此必须以数据中心（DC）为主要的流量生产和分发中心，且要呈现无尺度分布的特征，而我们现有的网络部署架构是与之并不匹配的。</p><p><strong>3)</strong>     <strong>专用网络和专用设备极大增加网络经营压力</strong></p><p>随着固移融合业务发展，固定和移动网络覆盖范围的扩大，网络规模日趋庞大。比如中国移动现有2/3/4G/固网的融合是全球最庞大、最复杂的一张网络。这就导致网络服务需要由具有不同功能的多个专业网络组合提供，各专业网络彼此之间条块化分割，能力参差不齐，业务的端到端部署和优化困难，导致新业务的创新乏力以及响应滞后，无法满足互联网+时代应对业务的动态请求。比如最近为了解决苹果手表呼叫时无法回落的问题，全国所有省份核心设备、接入设备和网关设备均在大范围改造升级，已经历时3个多月还未全部完成。</p><p><strong>4)</strong>     <strong>互联网+业务创新加快驱动网络智能化转型</strong></p><p>以亚马逊、阿里和腾讯为首的互联网IT巨头借助运营商管道资源，加快部署自己的云化业务服务，不仅可以及时洞察用户需求，实时响应客户需求，而且可以提供更加智能、弹性的网络服务。比如我个人前期浏览过阿里的EC云服务器资源，只过了一天就有阿里的专有客户经理来电咨询我的业务需求，拿到我的答复后1小时内就给出让我满意的解决方案。这种灵活性、高效性和专业性以我们目前的网络能力，是难以胜任的。</p><h3 id="IT行业发展经验给了我们哪些启示？"><a href="#IT行业发展经验给了我们哪些启示？" class="headerlink" title="IT行业发展经验给了我们哪些启示？"></a>IT行业发展经验给了我们哪些启示？</h3><p>既然提到IT行业，必然离不开摩尔定律。摩尔定律其实揭示了两个发展方向：高性能和低成本。作为运营商的我们更重视前者，代表性就是要求电信级的质量；而IT企业更重视后者，通过采用适度性能要求、宽松可靠性要求的通用IT设备来进行低成本解决方案部署。</p><p>其实，IT行业在20世纪70年代以前也是一个封闭的“烟囱式”架构群，但从80年代开始就打破了这种封闭的垂直架构（<strong>标志性事件就是小型机向X86转型</strong>），转向开放的水平架构。其基本思路就是我们今天谈到的“软硬件解耦”（<strong>标志性事件就是操作系统从设备中分离</strong>），双方分工明确，各自发展，从而也就诞生了今天的云计算（<strong>云计算其本质上就是一个分布式的、借助虚拟化技术实现、与硬件无关的linux操作系统</strong>）。</p><p>而对性能追求更高的我们，通常采用电信级网络设备，因此一直保持着专业化和高成本的特点。设备仍然是软硬件一体化的垂直架构，整个生态环境较为封闭（有限的电信设备厂商控制着从硬件、软件一直到业务实现的生产过程），不仅设计复杂、成本高、升级难、而且不同厂家之间兼容性不好。比如：爱立信EPC设备、卡特IMS设备、诺西HSS设备经现网验证均存在不同程度的兼容性问题。这也就直接造成我们的网络改造难、升级慢、维护成本高、开放性差、灵活性不足，同时也限制了我们在网络和业务上的创新。</p><p>随着SDN、NFV技术的引入，我们的网络设备封闭性有望打破（<strong>注意，我这里只用了有望一词，而不是必须，至于原因是因为VNFM与VNF之间的东西向接口仍是私有接口还未标准化，因此VNFM和VNF必然是同厂家组网，这其实也是一种设备封闭性问题</strong>），软硬件解耦，产业链生态走向开放，不仅有利于降低CAPEX和OPEX，更有利于实现网络开放和弹性，促进新型网络和业务的创新。</p><h3 id="现有网络为何无法满足新兴业务的需求？"><a href="#现有网络为何无法满足新兴业务的需求？" class="headerlink" title="现有网络为何无法满足新兴业务的需求？"></a>现有网络为何无法满足新兴业务的需求？</h3><p>在中国甚至全球，5G从提出就是被提到国家战略的地位，这将进一步推动云计算、大数据、移动互联、物联网等与现代制造业和服务业相结合，对运营商的基础设施提出了更高的要求。为了顺应新环境下业务的发展需求，我们的基础网络改造势在必行，特别是作为网络灵魂的网络架构必须重新定义、重新设计，构建新型的泛在、敏捷、按需的智能型网络，提升公共服务水平。</p><p>从顺应业务需求的角度来看，我们主要面临以下几个方面的挑战。</p><p><strong>1)</strong>     <strong>全面“流量经营”时代，我们面临超大流量对网络挑战</strong></p><p>流量经营已经获得广泛认可，随着不限量业务的普及以及物联网的兴起，直到现在流量对网络的挑战才刚刚开始。最近热门的4K、8K等富媒体技术将进一步激发流量的爆发增长，而AR/VR的发展普及将会把流量增长推向新的高潮。很多行业、部门都在预测流量趋势，包括中国移动自己的大数据平台也在做相关工作。从预测数据和历史经验看，流量的规模将更加刺激我们对宽带化的发展要求，但其背后对网络容量的压力和挑战也是巨大的。如果还是像现在这种“搭积木”方式进行简单扩容来解决，那以后势必难以为继，<strong>自动化、弹性化的重构势在必行</strong>。   </p><p><strong>2)</strong>     <strong>万物互联到万物智联既是新机遇也是新挑战</strong></p><p>万物互联到万物智联是实现“工业互联网”的重要基础。一方面带来巨大的连接规模，为我们运营商提供广泛的业务增长；另一方面也带来了更大的连接广度和深度，需要我们提供面向无线、有线全连接的接入广度，更对我们的网络提出高密度、低时延、广覆盖的个性化高要求。所以，我们的网络能不能适应万物智联，能不能承担“工业互联网”的发展重任，将是决定我们转型成败的关键，<strong>而现有网络模式势必进行智能化重构</strong>。</p><h2 id="How？—我们如何拥抱网络重构？"><a href="#How？—我们如何拥抱网络重构？" class="headerlink" title="How？—我们如何拥抱网络重构？"></a>How？—我们如何拥抱网络重构？</h2><h3 id="我们期望重构后的网络特征和架构是什么样？"><a href="#我们期望重构后的网络特征和架构是什么样？" class="headerlink" title="我们期望重构后的网络特征和架构是什么样？"></a>我们期望重构后的网络特征和架构是什么样？</h3><p><strong>1)</strong>     <strong>重构后的网络应该具备以下关键特征</strong></p><ul><li><p><strong>结构简化：</strong>网络层级、种类、类型等尽量减少，降低运营和维护的复杂性和成本，也有助于业务和应用的保障能力提升。比如：通过层级简化，业务路由优化，在全国90%的地方实现不大于30ms的业务传输网时延，这也是5G时代“三朵云”中接入云设计的初衷。</p></li><li><p><strong>灵活高效：</strong>网络通过软件定义的方式具备弹性可伸缩的能力，实现业务的快速部署和扩/缩n  容。比如：面向客户的VIP网络可以提供分钟级的配套开通和调整能力，使得客户按照需求来随时调整网络连接，这也是切片网络概念引入的初衷。</p></li><li><p><strong>集中控制：</strong>通过软件定义的方式实现网络的集中控制，打破目前分级、分层、分段的管理模式，实现面向全局的最优化网络管理，为客户提供全网一致性体验。比如：一点受理全国性的跨域VPN业务，并能实现即时开通。</p></li><li><p><strong>泛在安全：</strong>一方面满足客户无论何时何地的无缝接入，另一方面通过安全防护的配套建设对承载客户信息实现安全保障。</p></li></ul><p><strong>2)</strong>     <strong>重构后网络应该具备以下参考架构</strong></p><p>要实现重构后网络的上述特征，我们希望未来网络的架构简化为三层组网架构，如下图所示。</p><p><img src="https://i.loli.net/2019/04/29/5cc661b91904d.jpg"></p><ul><li><strong>基础设施层：</strong>分为3类资源。第一类是可虚拟化的通用基础设施，一般由云资源池提供，之上承载各类虚拟化的网元；第二类是可以将控制和转发进行分离的专用基础设施，其控制层可以抽象出来由上层SDN控制器直接进行管理；第三类是高性能专用设施，一般指无法升级改造的传统设备，依靠现有的传统网管进行管理。</li><li><strong>网络功能层：</strong>主要面向软件化的网络功能实现，结合虚拟资源和物理资源的管理系统/平台，实现逻辑功能和网元实体的分离，便于资源的集约化调度管控。其中，云管理平台主要负责对虚拟化资源的的管理协同，包括计算、存储和网络的统一管控；VNFM主要负责对基于NFV实现的虚拟网络功能的管控；SDN控制器实现基础设施的管控。</li><li><strong>协同编排层：</strong>主要提供对网络功能协同和对业务能力的编排，以及对上层应用的接口和能力开放。其中，网络协同和业务编排主要负责向上对业务需求的网络进行语言翻译和能力封装，向下对网络功能层的不同系统和网元进行协同，保障网络端到端打通。IT系统和业务平台则主要服务于网络资源的标准化封装，支持各类标准化API的调用。</li></ul><p><strong><em>重构后的网络与我们现有网络相比，主要改变在以下几点：</em></strong></p><ul><li><strong>硬件通用化：</strong>绝大多数功能网元都是通过标准化的云资源池进行承载，除了少数采用专用设施的设备。</li><li><strong>功能软件化：</strong>网元功能与底层硬件完全解耦，主要以软件的形式存在，充分发挥弹性、灵活和敏捷的特征。</li><li><strong>管控集中化：</strong>各网元的控制部分进行剥离，由上层云管理平台、VNFM、SDN控制器、传统网管进行管理，并由上层协同编排器进行集中协调与控制，更加体现了全程全网以及端到端的概</li><li><strong>能力标准化：标准与开源并存。</strong>标准是为了满足服务的规模化和普适化，开源是为了实现服务的创新性和开放性。因此，对网络能力封装不仅要制定完善相关技术的标准框架，更要借助开源社区新的技术能力来完善新的标准化推动。制定与之对应的、满足生产需求，提升生产效率的标准化接口和协议（<strong>这一点也是中国移动集团从开始推出NFV试点以来一直致力要做的事情</strong>），与上层业务及应用通过API进行互动，使得网络不再仅仅是哑管道，而是能够及时感知业务需求并能随之进行灵活调整的开放式能力平台。</li></ul><h3 id="网络重构过程中我们需要具备哪些关键技术？"><a href="#网络重构过程中我们需要具备哪些关键技术？" class="headerlink" title="网络重构过程中我们需要具备哪些关键技术？"></a>网络重构过程中我们需要具备哪些关键技术？</h3><p><strong><em>SDN：软件定义网络</em></strong></p><p>SDN主要将网络的控制平面与数据转发平面进行分离，采用集中控制替代现有的分布式控制，并通过开放的可编程的接口实现“软件定义”的网络架构。SDN是IT化的网络，是“软件主导一切”的趋势从IT产业向网络领域延伸的标志性技术，其核心就是网络的“软化”。</p><p>SDN的标准架构就是俗称的“三层两接口”，其实这种架构并不是SDN所独有，在现有网络中如VoLTE网络的核心网IMS也是一个标准的“三层两接口”架构，其目的就是实现转控分离。别忘了，IMS可是转发、控制和业务三层完全分离的一个架构体系。：）</p><p>SDN的核心特点是将实体设备作为基础资源，抽象出NOS（网络操作系统），隐藏底层物理细节并向上层提供统一的管理和编程接口。以NOS为平台，开发的应用程序可以实现通过软件定义的网络拓扑、资源分配和处理流程及机制等。</p><p>SDN的技术重点在南/北向接口标准化，南向接口已经实现了标准化定义，统一采用openflow协议，而北向接口虽然业内共识采用REST ful协议，大家都号称支持REST ful协议，但是对接起来仍然问题百出。因此，更需要一个组织或机构来明确这层接口实现的各种细节，同时形成标准化规范，大家共同遵循开发。通过下面的简图，大家可以对SDN有个初步感性认识。</p><p><img src="https://i.loli.net/2019/04/29/5cc66273c5bee.jpg"></p><hr><p><strong>NFV：网络功能虚拟化*</strong></p><p>NFV其本质就是实现硬件资源和软件功能的解耦，其最终目标是通过标准X86服务器、存储和交换设备来取代现有网络中的私有专用网元。主要包括：NFVI、VNF、MANO和OSS/BSS四个逻辑层面。关键特征包括上层的业务云化、底层硬件标准化、分层运营和加快业务的上线与创新。</p><p>其中，NFVI就是典型云计算平台，主要实现对底层物理设备资源进行计算、存储、网络虚拟化呈现。VNF是软件实现的虚拟网元功能，其利用NFVI创建的虚拟化资源，在其上通过软件编程的方式实现各类网元的功能。MANO是业务编排层，主要用于整体的编排和控制管理，将网络服务从上而下进行业务层到资源层逐步分解和调度（<strong>主要通过NFVO、VNFM和VIM三个子模块互相配合、调度NFVI层资源实现</strong>）。OSS/BSS与传统网络功能类似，主要实现业务的发放，计费、网络管理和营帐等功能。（<strong>其实现在随着K8s技术的兴起，这一层也完全可通过云调度的方式呈现。</strong>）</p><p>通过对比SDN技术我们可以发现，NFV技术其本质也是一个“三层两接口”的架构模型，可以说它是SDN技术一个衍生品（个人观点：））。但是，它与SDN技术主要区别还是技术呈现侧重点的区别，NFV更偏重网络功能的软件化，在控制转发层面也可以不依赖于SDN技术通过专用物理设备也能实现，这也是现阶段NFV网络建设的基本模式。而SDN技术更偏重控制和转发层面，不看重网元功能是否软件化实现。如一台具备openflow协议物理交换机也可在SDN网络中承担相应的转发功能，同样它也能抽象出对应网络抽象层由SDN控制器来实现调度。比如山东省内济南和青岛两地市的DC大二层互通就是通过大量这样的物理交换机来实现转发控制。个人判断随着SDN技术的逐步演进，网络重构过程初期这类大量物理交换机会逐渐被openflow软件交换机替换。国际惯例，同样下面放张图让大家对NFV的架构有个初步感性认识。</p><p><img src="https://i.loli.net/2019/04/29/5cc662b30e721.jpg"></p><hr><p><strong>云计算：OpenStack开源云—王者归来*</strong></p><p>在现阶段云计算技术在网络重构过程中主要作用是各种硬件资源的虚拟化呈现。对于未来网络的维护人员或者DevOps人员掌握和熟悉云计算是必不可少的一项基础技能。NFV技术中NFVI层使用的OpenStack就是一个典型的云计算架构，同样SDN中控制器OpenDayLight也是一种云计算的架构，现在OpenStack社区在Pike版本和Queens版本已经将这两种云计算架构进行融合，也就是说在OpenStack服务中中包含了OpenDayLight功能。（相比于OpenDayLight，OpenStack功能更强大，最重要是完全符合生产条件，华为云化设备底层也是采用OpenStack的H版本搭建，中兴同样）。而在我自己的实验环境也分别通过手工搭建和容器部署的方式实现这两种架构的融合。</p><p>OpenStack的原理主要通过各种服务的交互来实现业务的调用和流程分发。其核心思想就是对虚拟机VM进行各类操作控制来实现物理设备的功能。其基本服务包括Keystone（认证服务）、Nova（计算服务）、Glance（镜像服务）、Neutron（网络服务）、Cinder（虚拟块存储服务）、Swift（虚拟对象存储服务）、Heat（云编排服务）和Horizon（人机交互Web服务），对于我们运营商可能还会用到Ceilometer（流量监控、计费服务）。除了这些基础服务外，还有很多负载均衡、密钥共享存储以及开源NFV等高级服务，这里不再一一列举。OpenStack的各类服务之间通过一种叫消息队列（Queus）公共服务来进行异步通信，因此各类服务不仅可以部署同一台物理服务器上，也可采用高可用集群的方式在多个物理服务器上分布式部署。</p><p>我在外面学习时，很多外省的学员甚至华为的老师都在询问云计算怎么学习，我的答案是学习云计算的前提条件需要具备一定操作系统原理知识、虚拟化技术知识和linux操作系统基础知识。最好的学习方式就是自己搭建一套实验环境一遍学习理论、流程，一边动手实践。由于个人时间实在有限，特意在我个人微信公众号上写了一篇实验环境的搭建流程供各位初学者参考学习。下面还是放上一张OpenStack的原理图，让大家对云计算有个初步感性认识。</p><p><img src="https://i.loli.net/2019/04/29/5cc6630f958e4.jpg"></p><h3 id="我们如何紧跟网络重构的步伐进行运营转型升级？"><a href="#我们如何紧跟网络重构的步伐进行运营转型升级？" class="headerlink" title="我们如何紧跟网络重构的步伐进行运营转型升级？"></a>我们如何紧跟网络重构的步伐进行运营转型升级？</h3><p>网络重构对我们现有的网络架构将进行颠覆性的变革，将促进我们的网络布局由传统的电信机房（CO）向数据中心架构（DC）转变，网元部署形态由软硬一体化的专用设备向基础设施的通用化和虚拟化以及网元功能的软件化方向转变，实现对网络的集中、跨层、跨域控制，这与我们现有网络采用分专业、分层、分域的规划、建设和运营管理模式截然相反。未来网络的这种变化将对我们现有业务模式、运营模式、管理模式、人才培养模式都提出了巨大的挑战，将迫使我们改变现有观念，积极拥抱变革。</p><p><strong>1)</strong>     <strong>业务模式的转型升级</strong></p><p>业务需求是技术创新的原动力，同时技术创新也将激发新业务的增长。按照集团“大连接”战略，我们基础设施的建设布局、基础技术的演进，网络系统的革新都是以支撑数字化新服务的智能应用为核心，秉承“连接无限可能”的目标来逐步实施。</p><p>未来，我们面向的对象包括人、物、企业和信息，将提供他们自身及之间的沟通、连接服务。个人理解，可能主要包括十大类数字化业务模式：</p><ul><li><p><strong>人-人：未来通信业务。—</strong>通过VoLTE/VoNR技术，以通信服务提供商的角色将提供随时、随地、即时、高效、高感知、无障碍的人与人之间的通信服务。</p></li><li><p><strong>人-信息：内容信息业务。—</strong>通过内容运营平台，以内容提供商的角色，将提供引人入胜、引领潮流、多方共赢、私人定制的数字娱乐服务。</p></li><li><p><strong>企业-企业：企业信息化业务。—</strong>通过企业网布局，以移动ICT生态服务商的角色，将提供安全可靠、高效、低成本、可灵活定制的企业级移动ICT服务。<strong>（这一点华为已经走在了我们前面，未来我们和华为将是竞争对手关系）</strong></p></li><li><p><strong>企业-人：行业应用业务。—</strong>通过跨领域合作，主要针对教育、医疗、金融行业以行业产品服务提供商的角色，提供方便、实惠、开放的跨界民生服务。</p></li><li><p><strong>企业-信息：能力开放业务。—</strong>通过大数据平台运营和信息处理的模式，以大数据信息处理专家的角色，提供丰富、精选、定制化、实时的数据能力开放服务。（<strong>这一点阿里等互联网IT厂商已经走在了我们前面</strong>）</p></li><li><p><strong>物-物：智能物联网业务。—</strong>通过物联网基础服务平台，以物理网运营专家的角色，提供无处不在、无所不能、自动化、低成本的万物互联服务。</p></li><li><p><strong>物-人：智能家居业务。—</strong>通过智能CPE、机顶盒、行车记录仪等智能终端产品，以解决方案提供商的角色，将提供亲切、便捷、个性化、智能化的人物交互服务。</p></li><li><p><strong>物-信息：社交化物联网业务。—</strong>通过社交化物联网平台，以社交化服务提供商的角色，提供主动关注、动态建圈、自动沟通的社交化物联网服务。</p></li><li><p><strong>物-企业：产业信息化业务。—</strong>通过与传统产业融合，助力产业升级，实现产业再造，以服务和解决方案提供商的角色，将提供安全、低成本、大规模、可灵活定制的产业信息化服务。</p></li><li><p><strong>信息-信息：数据资源提供业务。—</strong>通过大数据、人工智能平台，以数据服务商的角色提供无所不知、实施精确的知识服务及数据资源运营服务。</p></li></ul><p><strong>2)</strong>     <strong>运营模式的转型升级</strong></p><p>未来网络的架构需要能够灵活地适配各类应用，主动对网络资源进行弹性伸缩。对我们目前的网络运营以及市场、网络和IT的协同能力提出了更高的要求，需要我们构建快速响应、高效率、灵活服务的运营能力。</p><p>虽然，我们目前正在逐步强化大数据应用，聚焦产品运营、渠道销售、客户服务、网络的开放合作等领域，但是还远远不够。对于未来网络运营，更需要我们实现集约化、智能化。需要我们以流程优化/变革为基础，以智能IT系统为载体，构建面向客户和业务一体化智慧运营服务。主要思路如下：</p><ol><li>将数据中心作为我们智慧运营的核心资源，通过数据汇聚、数据清洗、数据挖掘来实时驱动我们的营销、服务、运营等生产和管理流程。</li><li>加强服务产品的统筹和规划，重点布局战略级服务和市场化服务，同时要掌控服务产品的核心能力，推进DevOps模式，提升专业化自主开发和迭代优化能力。</li><li>突出市场需求化导向，加强大数据应用，强化渠道O2O协同和跨界合作，提升全业务布局和服务能力。</li><li>充分利用大数据手段，加强用户需求和行为洞察，做精服务品质，持续提升价值经营能力。</li><li>持续推进网络简化和现有网络的智能化升级，积极布局SDN/NFV/云计算能网络能力，结合大数据、人工智能等技术手段，变革创新生产流程和机制，加强对新兴业务的支撑，实现目前的网络运维向端到端集约、云网协同的智能网络运营转变。</li></ol><p><strong>3)</strong>      <strong>管理模式的转型升级</strong></p><p>网络重构对我们目前的组织、生产、运营、人力等管理体制将产生重大影响，主要体现在组织架构调整、规划模式转变、运营组织整合、创新体系建设、团队人才培养等方面。</p><p>未来网络架构将采用水平分层、纵向解耦的技术路线。基于SDN/NFV的网络架构将打破专业界限，管控和调度也将突破传统省-市-县三级的限制。由于网络以DC为核心的组网新格局，现有分域分层的组织架构已成为端到端自动化运营的最大障碍，必须建立纵向的面向云化网络的运维管理团队新模式，按照我们预期重构后网络参考模型，从上而下主要包括：编排器维护管理团队、虚拟网元维护管理团队、云计算维护管理团队、SDN控制器维护管理团队、虚拟化资源维护管理团队和基础设施维护管理团队。必须提前完成各团队的带头人，积极做好迎接转型的准备。这里可以拿我们网管中心内部做一简单举例。（<strong>只是举例，不包含任何其他意思）</strong></p><p>按照目前网管中心的科室划分主要分为：监控室、质量室、安全室、传输室、互联网室和核心业务室。那么，我们对比云化网络纵向组织架构做一简单规划。从下而上：</p><ul><li><strong>基础设施维护管理团队。</strong>该团队的主要职责是维护各IDC机房的物理服务器、交换机等设备，需要一定IT维护从业经验的人才能胜任，最主要的是现场维护模式。我们的自有人员可以通过学习培训来上岗，但从IDC机房的分布和维护成本来看，我的建议采用外包代维的方式来解决。</li><li><strong>虚拟化资源维护管理团队。</strong>该团队的主要职责是维护各类虚拟化资源池，主要涉及资源和虚机维护管理，需要具备虚拟化技术基础的人才能胜任，属于远程维护模式。而我们目前监控NOC大厅各类终端其实就是一种虚拟化部署模式，所以我们的监控室完全可以胜任。</li><li><strong>SDN控制器维护管理团队。</strong>该团队主要职责主要完成各类软件定义的网络拓扑、路由寻址、资源分布调用等进行维护管理，不仅需要SDN控制器的知识，更需要大量数通的基础知识人员才能胜任。因此我们的传输室通过培训SDN方面技能就可以完全胜任。</li><li><strong>云计算维护管理团队。</strong>主要负责云计算中各类服务维护和管理，需要具备linux系统知识、操作系统知识、虚拟化技术知识和云计算知识以及相关维护经验的人员才能胜任，属于纯IT范畴。而我们的安全室目前工作也基本属于IT范畴，因此通过培训和学习应该可以胜任。</li><li><strong>虚拟网元维护管理团队。</strong>主要负责各类虚拟网元的维护管理，现阶段主要包括vIMS、vEPC、vBRAS、虚拟化短信中心、虚拟化智能网和虚拟化彩铃平台等。这部分的维护人员主要涉及CT类的知识和技能储备，在此基础上再进行相关IT类培训（开发语言类和协议类）。因此目前互联网室与核心业务室相关专业的维护人员通过培训完全可以胜任。</li><li><strong>编排器维护管理团队。</strong>主要负责向上各类业务设计、流程规划和API调用，向下进行各类网元功能封装和策略下发。因此该部分实际上属于网业协同层，既要懂业务，还要懂网络，同时具备协议解读、功能封装、流程制定、策略制定等技能的人员才能胜任，属于端到端专业的范畴。因此目前质量室的人员通过培训上岗再加上外聘其他业务部门人员应该可以满足要求。</li></ul><p><strong>4)</strong>     <strong>人才培养模式转型升级</strong></p><p>在现有的网络运维模式下，厂家和我们之间是一种高度依赖的关系，更确切的说我们更依赖厂家，主要表现在网络维护、保障、演练和优化等方面的实操环节。</p><p>CT行业除了设备厂家自有人员外，运营商内部人员更看重人才在信令分析、流程分析、数据分析和优化措施制定方面的能力，而实际措施部署和网络调整完全是厂家人员执行。这一点也正是我入职中国移动以来最疑惑的一点。当然，这其中也存在厂家对运营商有所保留的原因，但更重要是长期以来厂家这种保姆式协维让我们对其有了更大的依赖（全国一样）。</p><p>而IT行业恰恰相反，更看重实操能力，IT的运维效率除了依靠自动化手段外，更多的依赖个人维护经验来提升。比如：阿里前段时间一个高级运维人员离职，曾开出双倍年薪也没挖到同级别的人才。</p><p>因此，随着网络重构逐步进行，除了集团要求的三级解耦要求外（这一点其实也是集团层面和厂家之间的博弈），我们的自有人员转型或者人才培养必须提升DevOps能力，构建自有研发能力体系。一方面，是因为未来ICT的网络需要集成和运维大量不同来源的新老软件、硬件、网管，我们的自有人员必须要能够在代码级层次上深度介入开发、测试、集成、维护直至业务提供的全过程。另一方面，我们现有的IT和CT是一种割裂分离的状态，随着IT和CT的深度融合，需要既懂网络又懂软件、适应开发运营一体化的人才，包括软件开发人才、IT系统人才和网络技术专家。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>以上就是我个人对未来网络的一点儿浅见，有不妥或错误之处还请各位领导和专家批评指正。</p><p>目前，传统网络已经越来越力不从心，这一点通过现在互联网企业不断推出各类业务模式已经让我深有感触，重新构建一个基于SDN/NFV的云化网络架构成为必然选择。目前全球的运营商均已推出了自己的网络重构计划，可以预见未来基于SDN/NFV的云化网络架构将愈发充满活力。</p><p>既然网络重构势必进行，重构之路已经开启，一个更加开放、灵活的新网络时代即将到来，我们与其消极抵触，不如以更加积极的姿态去迎接挑战，拥抱未来。</p><p><strong><em>未来？已来！</em></strong></p><p><strong><em>你，准备好了吗？！</em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写在前面的话&quot;&gt;&lt;/a&gt;写在前面的话&lt;/h2&gt;&lt;p&gt;虽然本人因为出差关系没有参加公司组织的现场培训，但是通过自学相关材料还是想谈一谈自己的一点浅见。&lt;/p&gt;
&lt;p&gt;与其说是对5G认识，不如更广泛地将其定义为“未来网络”这个概念，来谈谈对未来网络的一点儿浅见；与其说是网络转型，不如更彻底说是网络重构；与其说是学习心得，不如说是我自己的思考，尤其是对现有网络如何重构的一点儿思考。
    
    </summary>
    
      <category term="NFV基础" scheme="https://kkutysllb.cn/categories/NFV%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="电信云" scheme="https://kkutysllb.cn/tags/%E7%94%B5%E4%BF%A1%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>2019-04-27-Linux系统命令-第五篇《文件备份与压缩命令》</title>
    <link href="https://kkutysllb.cn/2019/04/28/2019-04-27-Linux%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4-%E7%AC%AC%E4%BA%94%E7%AF%87%E3%80%8A%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%E4%B8%8E%E5%8E%8B%E7%BC%A9%E5%91%BD%E4%BB%A4%E3%80%8B/"/>
    <id>https://kkutysllb.cn/2019/04/28/2019-04-27-Linux系统命令-第五篇《文件备份与压缩命令》/</id>
    <published>2019-04-27T16:44:09.000Z</published>
    <updated>2019-05-01T16:26:45.742Z</updated>
    
    <content type="html"><![CDATA[<h2 id="tar：打包备份"><a href="#tar：打包备份" class="headerlink" title="tar：打包备份"></a>tar：打包备份</h2><p>在Linux系统里，tar是将多个文件打包在一起，并且可以实现解压打包的文件的命令。是系统管理员最常用的命令之一，tar命令不但可以实现对多个文件进行打包，还可以对多个文件打包后进行压缩。</p><p>打包是指将一大堆文件或目录变成一个总的文件，压缩则是将一个大的文件通过一些压缩算法变成一个小文件。tar命令选项的使用有点特殊，对于CentOS、Linux来说，“tar-z”和“tar z”的效果相同，加或不加“-”这个符号都是可以的。而在FreeBSD系统下，必须加“-”符号。<a id="more"></a></p><p><strong>语法格式：tar [option] [file]</strong></p><p><strong>重要参数选项</strong></p><p><img src="https://i.loli.net/2019/04/28/5cc48721b316c.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）备份站点目录html</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建实验环境</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建测试目录/var/www/html/kkutysllb/test</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># mkdir -p /var/www/html/kkutysllb/test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在测试目录下创建测试文件</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># touch /var/www/html/kkutysllb/test/html&#123;01..10&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看刚创建的文件信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># ls -l /var/www/html/kkutysllb/test/</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 27 21:45 html01</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 27 21:45 html02</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 27 21:45 html03</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 27 21:45 html04</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 27 21:45 html05</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 27 21:45 html06</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 27 21:45 html07</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 27 21:45 html08</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 27 21:45 html09</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 27 21:45 html10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入到目标目录的上一级目录，并对目标目录打包</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># cd /var/www/html/kkutysllb/</span></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># tar zcvf www.kkutysllb.gz ./test</span></span><br><span class="line">./<span class="built_in">test</span>/</span><br><span class="line">./<span class="built_in">test</span>/html01</span><br><span class="line">./<span class="built_in">test</span>/html02</span><br><span class="line">./<span class="built_in">test</span>/html03</span><br><span class="line">./<span class="built_in">test</span>/html04</span><br><span class="line">./<span class="built_in">test</span>/html05</span><br><span class="line">./<span class="built_in">test</span>/html06</span><br><span class="line">./<span class="built_in">test</span>/html07</span><br><span class="line">./<span class="built_in">test</span>/html08</span><br><span class="line">./<span class="built_in">test</span>/html09</span><br><span class="line">./<span class="built_in">test</span>/html10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看打包文件信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># ls -lhi *.gz</span></span><br><span class="line">101098015 -rw-r--r-- 1 root root 233 Apr 27 21:49 www.kkutysllb.gz</span><br></pre></td></tr></table></figure><p><strong>2）查看压缩包内的内容</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过t选项可以不解压就能查看压缩包内的内容，加选项v可以显示文件的属性</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># tar ztvf www.kkutysllb.gz </span></span><br><span class="line">drwxr-xr-x root/root         0 2019-04-27 21:45 ./<span class="built_in">test</span>/</span><br><span class="line">-rw-r--r-- root/root         0 2019-04-27 21:45 ./<span class="built_in">test</span>/html01</span><br><span class="line">-rw-r--r-- root/root         0 2019-04-27 21:45 ./<span class="built_in">test</span>/html02</span><br><span class="line">-rw-r--r-- root/root         0 2019-04-27 21:45 ./<span class="built_in">test</span>/html03</span><br><span class="line">-rw-r--r-- root/root         0 2019-04-27 21:45 ./<span class="built_in">test</span>/html04</span><br><span class="line">-rw-r--r-- root/root         0 2019-04-27 21:45 ./<span class="built_in">test</span>/html05</span><br><span class="line">-rw-r--r-- root/root         0 2019-04-27 21:45 ./<span class="built_in">test</span>/html06</span><br><span class="line">-rw-r--r-- root/root         0 2019-04-27 21:45 ./<span class="built_in">test</span>/html07</span><br><span class="line">-rw-r--r-- root/root         0 2019-04-27 21:45 ./<span class="built_in">test</span>/html08</span><br><span class="line">-rw-r--r-- root/root         0 2019-04-27 21:45 ./<span class="built_in">test</span>/html09</span><br><span class="line">-rw-r--r-- root/root         0 2019-04-27 21:45 ./<span class="built_in">test</span>/html10</span><br></pre></td></tr></table></figure><p><strong>3）对压缩包进行解压</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将www.kkutysllb.gz压缩包的内容解压到/home/kkutysllb/html目录中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果目标目录不存在，不会自动创建，需要手动先建立目标目录</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># mkdir -p /home/kkutysllb/html</span></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># tar zxvf www.kkutysllb.gz -C /home/kkutysllb/html/</span></span><br><span class="line">./<span class="built_in">test</span>/</span><br><span class="line">./<span class="built_in">test</span>/html01</span><br><span class="line">./<span class="built_in">test</span>/html02</span><br><span class="line">./<span class="built_in">test</span>/html03</span><br><span class="line">./<span class="built_in">test</span>/html04</span><br><span class="line">./<span class="built_in">test</span>/html05</span><br><span class="line">./<span class="built_in">test</span>/html06</span><br><span class="line">./<span class="built_in">test</span>/html07</span><br><span class="line">./<span class="built_in">test</span>/html08</span><br><span class="line">./<span class="built_in">test</span>/html09</span><br><span class="line">./<span class="built_in">test</span>/html10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看目标目录的信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># ll -h /home/kkutysllb/html/</span></span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x 2 root root 146 Apr 27 21:45 <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p><strong>如果不想看到太多的输出，则可以去掉v选项，功能不受影响。同时z选项也可以省略，只要涉及解压的操作，tar命令都能自动识别压缩包的压缩类型，但是压缩时必须要加上z选项。</strong></p><p><strong>4）排除打包</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在我们刚才打包的文件中包含了目录test，如果不想打包test目录，可以使用exclude选项排除</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># cd ..</span></span><br><span class="line">[root@C7-Server01 html]<span class="comment"># tar zcvf www.kkutysllb.new.gz ./kkutysllb/ --exclude=kkutysllb/test</span></span><br><span class="line">./kkutysllb/</span><br><span class="line">./kkutysllb/www.kkutysllb.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看刚才打包的文件内容</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># cd ..</span></span><br><span class="line">[root@C7-Server01 html]<span class="comment"># tar ztvf www.kkutysllb.new.gz </span></span><br><span class="line">drwxr-xr-x root/root         0 2019-04-27 22:21 ./kkutysllb/</span><br><span class="line">-rw-r--r-- root/root       233 2019-04-27 21:49 ./kkutysllb/www.kkutysllb.gz</span><br></pre></td></tr></table></figure><p><strong>如果要排除多个目录，可以在后面接多个–exclude选项。</strong></p><p><strong>使用exclude选项排除某个子目录时，需要注意以下几点，否则不会排除成功：</strong></p><ul><li>若需要打包的目录为相对路径，则–exclude后只能接相对路径。</li><li>若需要打包的目录为绝对路径，则–exclude后既能接绝对路径也能接相对路径。</li><li>为方便，统一起见，建议–exclude的后接路径和打包路径应保持形式一致，要么都是相对路径，要么都是绝对路径。</li></ul><p><strong>5）排除多个文件打包参数-X</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将要排除的文件名写入一个文件</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># cat &gt;&gt; filtername &lt;&lt; EOF</span></span><br><span class="line"></span><br><span class="line">&gt; html03</span><br><span class="line">&gt; html06</span><br><span class="line">&gt; html02</span><br><span class="line">&gt; html08</span><br><span class="line">&gt; html10</span><br><span class="line">&gt; EOF</span><br><span class="line">&gt; [root@C7-Server01 kkutysllb]<span class="comment"># cat -n filtername </span></span><br><span class="line">&gt;      1html03</span><br><span class="line">&gt;      2html06</span><br><span class="line">&gt;      3html02</span><br><span class="line">&gt;      4html08</span><br><span class="line">&gt;      5html10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用参数X排除上述文件进行打包</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># tar zcvfX afterfilter.gz ./filtername ./test/</span></span><br><span class="line">./<span class="built_in">test</span>/</span><br><span class="line">./<span class="built_in">test</span>/html01</span><br><span class="line">./<span class="built_in">test</span>/html04</span><br><span class="line">./<span class="built_in">test</span>/html05</span><br><span class="line">./<span class="built_in">test</span>/html07</span><br><span class="line">./<span class="built_in">test</span>/html09</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看新打包的文件内容</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># tar ztvf afterfilter.gz </span></span><br><span class="line">drwxr-xr-x root/root         0 2019-04-27 21:45 ./<span class="built_in">test</span>/</span><br><span class="line">-rw-r--r-- root/root         0 2019-04-27 21:45 ./<span class="built_in">test</span>/html01</span><br><span class="line">-rw-r--r-- root/root         0 2019-04-27 21:45 ./<span class="built_in">test</span>/html04</span><br><span class="line">-rw-r--r-- root/root         0 2019-04-27 21:45 ./<span class="built_in">test</span>/html05</span><br><span class="line">-rw-r--r-- root/root         0 2019-04-27 21:45 ./<span class="built_in">test</span>/html07</span><br><span class="line">-rw-r--r-- root/root         0 2019-04-27 21:45 ./<span class="built_in">test</span>/html09</span><br></pre></td></tr></table></figure><p><strong>6）打包链接文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先使用常规选项zc完成打包</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># cd /etc/</span></span><br><span class="line">[root@C7-Server01 etc]<span class="comment"># tar zcf local.tar.gz ./rc.local </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看刚打包的文件内容，发现这是一个符号链接（软链接文件）</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 etc]<span class="comment"># tar ztvf local.tar.gz </span></span><br><span class="line">lrwxrwxrwx root/root         0 2019-04-20 16:07 ./rc.local -&gt; rc.d/rc.local</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里是个坑，如果不加特殊参数，那么打包之后的文件是个软链接文件，不是rc.local的实体内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 采用-h参数打包链接文件</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 etc]<span class="comment"># tar zcfh local.new.tar.gz ./rc.local </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次查看打包的文件内容，发现内容是软链接文件指向的真实文件</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 etc]<span class="comment"># tar ztvf local.new.tar.gz </span></span><br><span class="line">-rw-r--r-- root/root       473 2019-02-20 01:35 ./rc.local</span><br></pre></td></tr></table></figure><p><strong>用tar的通用选项zcf打包文件时，如果这个文件是链接文件如/etc/rc.local，那么tar只会对链接文件本身打包，而不是对链接文件指向的真实文件打包，因此需要额外使用-h选项将软链接文件对应的实体文件打包。</strong></p><p><strong>对文件打包时，除了上述命令选项参数要掌握外，还需要遵循一些好的操作习惯，避免实际运维中不可预知的错误：</strong></p><p>1）在打包一个目录之前，先进入到这个目录的上一级目录，然后执行打包命令，这是大部分情况下打包文件的规范操作流程。</p><p>2）少数情况下打包需要完整的目录结构时，也可以使用绝对路径打包，但是需要注意的是解压tar包时压缩包内的文件是否会覆盖本地文件。</p><p><strong>小练习：请对/etc/目录下所有普通文件进行打包。</strong></p><h2 id="gzip：压缩或解压文件"><a href="#gzip：压缩或解压文件" class="headerlink" title="gzip：压缩或解压文件"></a>gzip：压缩或解压文件</h2><p>gzip命令用于将一个大的文件通过压缩算法（Lempel-Ziv coding（LZ77））变成一个小的文件。gzip命令不能直接压缩目录，因此目录需要先用tar打包成一个文件，然后tar再调用gzip进行压缩。</p><p><strong>语法格式：gzip [option] [file]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/04/28/5cc488044eae4.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）把目录下每个文件都压缩单独的.gz文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看test目录下所有文件的信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># ls -l test/</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 27 21:45 html01</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 27 21:45 html02</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 27 21:45 html03</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 27 21:45 html04</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 27 21:45 html05</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 27 21:45 html06</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 27 21:45 html07</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 27 21:45 html08</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 27 21:45 html09</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 27 21:45 html10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用gzip对每个单独压缩</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># gzip test/html*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次查看test目录下的所有文件信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># ls -l test/</span></span><br><span class="line">total 40</span><br><span class="line">-rw-r--r-- 1 root root 27 Apr 27 21:45 html01.gz</span><br><span class="line">-rw-r--r-- 1 root root 27 Apr 27 21:45 html02.gz</span><br><span class="line">-rw-r--r-- 1 root root 27 Apr 27 21:45 html03.gz</span><br><span class="line">-rw-r--r-- 1 root root 27 Apr 27 21:45 html04.gz</span><br><span class="line">-rw-r--r-- 1 root root 27 Apr 27 21:45 html05.gz</span><br><span class="line">-rw-r--r-- 1 root root 27 Apr 27 21:45 html06.gz</span><br><span class="line">-rw-r--r-- 1 root root 27 Apr 27 21:45 html07.gz</span><br><span class="line">-rw-r--r-- 1 root root 27 Apr 27 21:45 html08.gz</span><br><span class="line">-rw-r--r-- 1 root root 27 Apr 27 21:45 html09.gz</span><br><span class="line">-rw-r--r-- 1 root root 27 Apr 27 21:45 html10.gz</span><br></pre></td></tr></table></figure><p><strong>gzip命令的缺点是压缩后源文件不见了，它的特性是压缩、解压都会自动删除源文件。</strong></p><p><strong>2）不解压显示上一个例子中每个压缩文件的信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-l选项显示压缩文件信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># gzip -l test/*.gz</span></span><br><span class="line">compressed        uncompressed  ratio uncompressed_name</span><br><span class="line">27                   0   0.0% <span class="built_in">test</span>/html01</span><br><span class="line">27                   0   0.0% <span class="built_in">test</span>/html02</span><br><span class="line">27                   0   0.0% <span class="built_in">test</span>/html03</span><br><span class="line">27                   0   0.0% <span class="built_in">test</span>/html04</span><br><span class="line">27                   0   0.0% <span class="built_in">test</span>/html05</span><br><span class="line">27                   0   0.0% <span class="built_in">test</span>/html06</span><br><span class="line">27                   0   0.0% <span class="built_in">test</span>/html07</span><br><span class="line">27                   0   0.0% <span class="built_in">test</span>/html08</span><br><span class="line">27                   0   0.0% <span class="built_in">test</span>/html09</span><br><span class="line">27                   0   0.0% <span class="built_in">test</span>/html10</span><br></pre></td></tr></table></figure><p><strong>因为源文件都是空文件，所以压缩率都为0.0％。</strong></p><p><strong>3）解压文件，并显示解压过程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-d选项解压，-v显示解压过程</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># gzip -dv test/*.gz</span></span><br><span class="line"><span class="built_in">test</span>/html01.gz:  0.0% -- replaced with <span class="built_in">test</span>/html01</span><br><span class="line"><span class="built_in">test</span>/html02.gz:  0.0% -- replaced with <span class="built_in">test</span>/html02</span><br><span class="line"><span class="built_in">test</span>/html03.gz:  0.0% -- replaced with <span class="built_in">test</span>/html03</span><br><span class="line"><span class="built_in">test</span>/html04.gz:  0.0% -- replaced with <span class="built_in">test</span>/html04</span><br><span class="line"><span class="built_in">test</span>/html05.gz:  0.0% -- replaced with <span class="built_in">test</span>/html05</span><br><span class="line"><span class="built_in">test</span>/html06.gz:  0.0% -- replaced with <span class="built_in">test</span>/html06</span><br><span class="line"><span class="built_in">test</span>/html07.gz:  0.0% -- replaced with <span class="built_in">test</span>/html07</span><br><span class="line"><span class="built_in">test</span>/html08.gz:  0.0% -- replaced with <span class="built_in">test</span>/html08</span><br><span class="line"><span class="built_in">test</span>/html09.gz:  0.0% -- replaced with <span class="built_in">test</span>/html09</span><br><span class="line"><span class="built_in">test</span>/html10.gz:  0.0% -- replaced with <span class="built_in">test</span>/html10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看test目录下文件信息，发现解压后gzip也会将原来压缩包自动删除</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># ls -l test/</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 27 21:45 html01</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 27 21:45 html02</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 27 21:45 html03</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 27 21:45 html04</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 27 21:45 html05</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 27 21:45 html06</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 27 21:45 html07</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 27 21:45 html08</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 27 21:45 html09</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 27 21:45 html10</span><br></pre></td></tr></table></figure><p><strong>4）压缩解压保留源文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-c选项与输出重定向结合完成操作</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># gzip -c test/html* &gt; test.gz</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前目录下生成的test.gz压缩文件信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># gzip -lv test.gz</span></span><br><span class="line">method  crc     date  time           compressed        uncompressed  ratio uncompressed_name</span><br><span class="line">defla 00000000 Apr 27 23:07                 270                   0   0.0% <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看源文件是否还存在</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># ls -l test/html*</span></span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 27 21:45 <span class="built_in">test</span>/html01</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 27 21:45 <span class="built_in">test</span>/html02</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 27 21:45 <span class="built_in">test</span>/html03</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 27 21:45 <span class="built_in">test</span>/html04</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 27 21:45 <span class="built_in">test</span>/html05</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 27 21:45 <span class="built_in">test</span>/html06</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 27 21:45 <span class="built_in">test</span>/html07</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 27 21:45 <span class="built_in">test</span>/html08</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 27 21:45 <span class="built_in">test</span>/html09</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 27 21:45 <span class="built_in">test</span>/html10</span><br></pre></td></tr></table></figure><p><strong>解压操作类似，请大家自行练习。</strong></p><p><strong>虽然上面使用重定向符号解决了保留源文件的问题，但是使用起来还是不太方便。其实，gzip套件包含了许多可以“在原地”处理压缩文件的实用程序。zcat、zgrep、zless、zdiff等实用程序的作用分别与cat、grep、less和diff相同，但是它们操作的是压缩的文件。比如：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># zcat命令可以直接读取压缩文件内容</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 etc]<span class="comment"># zcat local.new.tar.gz | head</span></span><br><span class="line">./rc.local0000644000000000000000000000073113433037107011333 0ustar  rootroot<span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># THIS FILE IS ADDED FOR COMPATIBILITY PURPOSES</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># It is highly advisable to create own systemd services or udev rules</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># to run scripts during boot instead of using this file.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># In contrast to previous versions due to parallel execution during boot</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># this script will NOT be run after all other services.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Please note that you must run 'chmod +x /etc/rc.d/rc.local' to ensure</span></span><br></pre></td></tr></table></figure><p><strong>请大家思考下，zcat命令是否可以对gz文件完成解压缩？如果可以，该怎么操作？</strong></p><h2 id="zip：打包和压缩文件"><a href="#zip：打包和压缩文件" class="headerlink" title="zip：打包和压缩文件"></a>zip：打包和压缩文件</h2><p>zip压缩格式是Windows与Linux等多平台通用的压缩格式。和gzip命令相比，zip命令压缩文件不仅不会删除源文件，而且还可以压缩目录。</p><p><strong>语法格式：zip [option] [file]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/04/28/5cc488f632d9e.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）压缩文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 因为测试文件都是空文件，所以压缩率为0%</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># zip test.zip ./test</span></span><br><span class="line">  adding: <span class="built_in">test</span>/ (stored 0%)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看新生成的zip压缩文件信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># ll -h *.zip</span></span><br><span class="line">-rw-r--r-- 1 root root 160 Apr 27 23:21 test.zip</span><br></pre></td></tr></table></figure><p><strong>2）压缩目录</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入根目录/下，压缩tmp目录</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 /]<span class="comment"># zip tmp.zip ./tmp/</span></span><br><span class="line">  adding: tmp/ (stored 0%)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面操作只是压缩tmp这个目录，目录下的文件并没有压缩</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要想同时压缩目录下的文件，可以使用-r选项递归压缩</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 /]<span class="comment"># zip -r tmp.zip ./tmp/</span></span><br><span class="line">updating: tmp/ (stored 0%)</span><br><span class="line">  adding: tmp/.XIM-unix/ (stored 0%)</span><br><span class="line">  adding: tmp/.font-unix/ (stored 0%)</span><br><span class="line">  adding: tmp/.X11-unix/ (stored 0%)</span><br><span class="line">  adding: tmp/.Test-unix/ (stored 0%)</span><br><span class="line">  adding: tmp/.ICE-unix/ (stored 0%)</span><br><span class="line">  adding: tmp/vmware-root/ (stored 0%)</span><br><span class="line">  adding: tmp/vmware-root_16212-827959067/ (stored 0%)</span><br><span class="line">  adding: tmp/systemd-private-f8e761a727fe467cad9e29b0663bc653-chronyd.service-6TlcAm/ (stored 0%)</span><br><span class="line">  adding: tmp/systemd-private-f8e761a727fe467cad9e29b0663bc653-chronyd.service-6TlcAm/tmp/ (stored 0%)</span><br><span class="line">  adding: tmp/vmware-root_9443-3886520225/ (stored 0%)</span><br><span class="line">  adding: tmp/vmware-root_9458-2857896559/ (stored 0%)</span><br><span class="line">  adding: tmp/vmware-root_9420-2857896526/ (stored 0%)</span><br><span class="line">  adding: tmp/vmware-root_9400-3101375875/ (stored 0%)</span><br><span class="line">  adding: tmp/vmware-root_9456-2866351085/ (stored 0%)</span><br><span class="line">  adding: tmp/vmware-root_9609-4121731445/ (stored 0%)</span><br><span class="line">  adding: tmp/vmware-root_9573-4146439782/ (stored 0%)</span><br><span class="line">  adding: tmp/vmware-root_9660-3101179142/ (stored 0%)</span><br><span class="line">  adding: tmp/vmware-root_9604-3101310240/ (stored 0%)</span><br><span class="line">  adding: tmp/vmware-root_9409-3878589979/ (stored 0%)</span><br><span class="line">  adding: tmp/vmware-root_9328-3134798637/ (stored 0%)</span><br><span class="line">  adding: tmp/systemd-private-5b1137097c084a899dfd1557504d079d-chronyd.service-6Ra806/ (stored 0%)</span><br><span class="line">  adding: tmp/systemd-private-5b1137097c084a899dfd1557504d079d-chronyd.service-6Ra806/tmp/ (stored 0%)</span><br><span class="line">  adding: tmp/vmware-root_9392-3134798733/ (stored 0%)</span><br></pre></td></tr></table></figure><p><strong>3）排除压缩</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 排除tmp目录下vmware-root/目录后，进行压缩</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 /]<span class="comment"># zip -r tmp_new.zip /tmp/ -x /tmp/vmware-root/</span></span><br><span class="line">  adding: tmp/ (stored 0%)</span><br><span class="line">  adding: tmp/.XIM-unix/ (stored 0%)</span><br><span class="line">  adding: tmp/.font-unix/ (stored 0%)</span><br><span class="line">  adding: tmp/.X11-unix/ (stored 0%)</span><br><span class="line">  adding: tmp/.Test-unix/ (stored 0%)</span><br><span class="line">  adding: tmp/.ICE-unix/ (stored 0%)</span><br><span class="line">  adding: tmp/vmware-root_16212-827959067/ (stored 0%)</span><br><span class="line">  adding: tmp/systemd-private-f8e761a727fe467cad9e29b0663bc653-chronyd.service-6TlcAm/ (stored 0%)</span><br><span class="line">  adding: tmp/systemd-private-f8e761a727fe467cad9e29b0663bc653-chronyd.service-6TlcAm/tmp/ (stored 0%)</span><br><span class="line">  adding: tmp/vmware-root_9443-3886520225/ (stored 0%)</span><br><span class="line">  adding: tmp/vmware-root_9458-2857896559/ (stored 0%)</span><br><span class="line">  adding: tmp/vmware-root_9420-2857896526/ (stored 0%)</span><br><span class="line">  adding: tmp/vmware-root_9400-3101375875/ (stored 0%)</span><br><span class="line">  adding: tmp/vmware-root_9456-2866351085/ (stored 0%)</span><br><span class="line">  adding: tmp/vmware-root_9609-4121731445/ (stored 0%)</span><br><span class="line">  adding: tmp/vmware-root_9573-4146439782/ (stored 0%)</span><br><span class="line">  adding: tmp/vmware-root_9660-3101179142/ (stored 0%)</span><br><span class="line">  adding: tmp/vmware-root_9604-3101310240/ (stored 0%)</span><br><span class="line">  adding: tmp/vmware-root_9409-3878589979/ (stored 0%)</span><br><span class="line">  adding: tmp/vmware-root_9328-3134798637/ (stored 0%)</span><br><span class="line">  adding: tmp/systemd-private-5b1137097c084a899dfd1557504d079d-chronyd.service-6Ra806/ (stored 0%)</span><br><span class="line">  adding: tmp/systemd-private-5b1137097c084a899dfd1557504d079d-chronyd.service-6Ra806/tmp/ (stored 0%)</span><br><span class="line">  adding: tmp/vmware-root_9392-3134798733/ (stored 0%)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对比tmp.zip和tmp_new.zip文件内容差别</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩文件时二进制文件，所以只能使用vimdiff命令进行对比</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 /]<span class="comment"># vimdiff tmp.zip zip_new.zip</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/28/5cc48b01896a4.jpg"></p><h2 id="unzip：解压zip文件"><a href="#unzip：解压zip文件" class="headerlink" title="unzip：解压zip文件"></a>unzip：解压zip文件</h2><p>unzip命令可以解压zip命令或其他压缩软件压缩的zip格式的文件。</p><p><strong>语法格式：unzip [option] [file]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/04/28/5cc4899850121.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）不解压直接查看压缩文件内容</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-l选项</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 /]<span class="comment"># unzip -l tmp.zip </span></span><br><span class="line">Archive:  tmp.zip</span><br><span class="line">Length      Date    Time    Name</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">0  04-27-2019 22:29   tmp/</span><br><span class="line">0  04-07-2019 20:34   tmp/.XIM-unix/</span><br><span class="line">0  04-07-2019 20:34   tmp/.font-unix/</span><br><span class="line">0  04-07-2019 20:34   tmp/.X11-unix/</span><br><span class="line">0  04-07-2019 20:34   tmp/.Test-unix/</span><br><span class="line">0  04-07-2019 20:34   tmp/.ICE-unix/</span><br><span class="line">0  04-20-2019 11:06   tmp/vmware-root/</span><br><span class="line">0  04-20-2019 16:08   tmp/vmware-root_16212-827959067/</span><br><span class="line">0  04-21-2019 16:27   tmp/systemd-private-f8e761a727fe467cad9e29b0663bc653-chronyd.service-6TlcAm/</span><br><span class="line">0  04-21-2019 16:27   tmp/systemd-private-f8e761a727fe467cad9e29b0663bc653-chronyd.service-6TlcAm/tmp/</span><br><span class="line">0  04-21-2019 16:27   tmp/vmware-root_9443-3886520225/</span><br><span class="line">0  04-22-2019 22:23   tmp/vmware-root_9458-2857896559/</span><br><span class="line">0  04-22-2019 22:52   tmp/vmware-root_9420-2857896526/</span><br><span class="line">0  04-22-2019 22:53   tmp/vmware-root_9400-3101375875/</span><br><span class="line">0  04-23-2019 10:29   tmp/vmware-root_9456-2866351085/</span><br><span class="line">0  04-23-2019 12:41   tmp/vmware-root_9609-4121731445/</span><br><span class="line">0  04-23-2019 12:50   tmp/vmware-root_9573-4146439782/</span><br><span class="line">0  04-23-2019 18:24   tmp/vmware-root_9660-3101179142/</span><br><span class="line">0  04-26-2019 17:24   tmp/vmware-root_9604-3101310240/</span><br><span class="line">0  04-27-2019 12:00   tmp/vmware-root_9409-3878589979/</span><br><span class="line">0  04-27-2019 21:42   tmp/vmware-root_9328-3134798637/</span><br><span class="line">0  04-27-2019 21:43   tmp/systemd-private-5b1137097c084a899dfd1557504d079d-chronyd.service-6Ra806/</span><br><span class="line">0  04-27-2019 21:43   tmp/systemd-private-5b1137097c084a899dfd1557504d079d-chronyd.service-6Ra806/tmp/</span><br><span class="line">0  04-27-2019 21:43   tmp/vmware-root_9392-3134798733/</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">0                     24 files</span><br></pre></td></tr></table></figure><p><strong>2）常规解压文件的例子</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-v选项显示解压过程</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 /]<span class="comment"># unzip -v tmp.zip</span></span><br><span class="line">Archive:  tmp.zip</span><br><span class="line">Length   Method    Size  Cmpr    Date    Time   CRC-32   Name</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">0  Stored        0   0% 04-27-2019 22:29 00000000  tmp/</span><br><span class="line">0  Stored        0   0% 04-07-2019 20:34 00000000  tmp/.XIM-unix/</span><br><span class="line">0  Stored        0   0% 04-07-2019 20:34 00000000  tmp/.font-unix/</span><br><span class="line">0  Stored        0   0% 04-07-2019 20:34 00000000  tmp/.X11-unix/</span><br><span class="line">0  Stored        0   0% 04-07-2019 20:34 00000000  tmp/.Test-unix/</span><br><span class="line">0  Stored        0   0% 04-07-2019 20:34 00000000  tmp/.ICE-unix/</span><br><span class="line">0  Stored        0   0% 04-20-2019 11:06 00000000  tmp/vmware-root/</span><br><span class="line">0  Stored        0   0% 04-20-2019 16:08 00000000  tmp/vmware-root_16212-827959067/</span><br><span class="line">0  Stored        0   0% 04-21-2019 16:27 00000000  tmp/systemd-private-f8e761a727fe467cad9e29b0663bc653-chronyd.service-6TlcAm/</span><br><span class="line">0  Stored        0   0% 04-21-2019 16:27 00000000  tmp/systemd-private-f8e761a727fe467cad9e29b0663bc653-chronyd.service-6TlcAm/tmp/</span><br><span class="line">0  Stored        0   0% 04-21-2019 16:27 00000000  tmp/vmware-root_9443-3886520225/</span><br><span class="line">0  Stored        0   0% 04-22-2019 22:23 00000000  tmp/vmware-root_9458-2857896559/</span><br><span class="line">0  Stored        0   0% 04-22-2019 22:52 00000000  tmp/vmware-root_9420-2857896526/</span><br><span class="line">0  Stored        0   0% 04-22-2019 22:53 00000000  tmp/vmware-root_9400-3101375875/</span><br><span class="line">0  Stored        0   0% 04-23-2019 10:29 00000000  tmp/vmware-root_9456-2866351085/</span><br><span class="line">0  Stored        0   0% 04-23-2019 12:41 00000000  tmp/vmware-root_9609-4121731445/</span><br><span class="line">0  Stored        0   0% 04-23-2019 12:50 00000000  tmp/vmware-root_9573-4146439782/</span><br><span class="line">0  Stored        0   0% 04-23-2019 18:24 00000000  tmp/vmware-root_9660-3101179142/</span><br><span class="line">0  Stored        0   0% 04-26-2019 17:24 00000000  tmp/vmware-root_9604-3101310240/</span><br><span class="line">0  Stored        0   0% 04-27-2019 12:00 00000000  tmp/vmware-root_9409-3878589979/</span><br><span class="line">0  Stored        0   0% 04-27-2019 21:42 00000000  tmp/vmware-root_9328-3134798637/</span><br><span class="line">0  Stored        0   0% 04-27-2019 21:43 00000000  tmp/systemd-private-5b1137097c084a899dfd1557504d079d-chronyd.service-6Ra806/</span><br><span class="line">0  Stored        0   0% 04-27-2019 21:43 00000000  tmp/systemd-private-5b1137097c084a899dfd1557504d079d-chronyd.service-6Ra806/tmp/</span><br><span class="line">0  Stored        0   0% 04-27-2019 21:43 00000000  tmp/vmware-root_9392-3134798733/</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">0                0   0%                            24 files</span><br></pre></td></tr></table></figure><p><strong>3） 指定解压目录解压文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将tmp_new.zip文件加压到/home/kkutysllb/目录下</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 /]<span class="comment"># unzip -d /home/kkutysllb/ tmp_new.zip </span></span><br><span class="line">Archive:  tmp_new.zip</span><br><span class="line">creating: /home/kkutysllb/tmp/</span><br><span class="line">creating: /home/kkutysllb/tmp/.XIM-unix/</span><br><span class="line">creating: /home/kkutysllb/tmp/.font-unix/</span><br><span class="line">creating: /home/kkutysllb/tmp/.X11-unix/</span><br><span class="line">creating: /home/kkutysllb/tmp/.Test-unix/</span><br><span class="line">creating: /home/kkutysllb/tmp/.ICE-unix/</span><br><span class="line">creating: /home/kkutysllb/tmp/vmware-root_16212-827959067/</span><br><span class="line">creating: /home/kkutysllb/tmp/systemd-private-f8e761a727fe467cad9e29b0663bc653-chronyd.service-6TlcAm/</span><br><span class="line">creating: /home/kkutysllb/tmp/systemd-private-f8e761a727fe467cad9e29b0663bc653-chronyd.service-6TlcAm/tmp/</span><br><span class="line">creating: /home/kkutysllb/tmp/vmware-root_9443-3886520225/</span><br><span class="line">creating: /home/kkutysllb/tmp/vmware-root_9458-2857896559/</span><br><span class="line">creating: /home/kkutysllb/tmp/vmware-root_9420-2857896526/</span><br><span class="line">creating: /home/kkutysllb/tmp/vmware-root_9400-3101375875/</span><br><span class="line">creating: /home/kkutysllb/tmp/vmware-root_9456-2866351085/</span><br><span class="line">creating: /home/kkutysllb/tmp/vmware-root_9609-4121731445/</span><br><span class="line">creating: /home/kkutysllb/tmp/vmware-root_9573-4146439782/</span><br><span class="line">creating: /home/kkutysllb/tmp/vmware-root_9660-3101179142/</span><br><span class="line">creating: /home/kkutysllb/tmp/vmware-root_9604-3101310240/</span><br><span class="line">creating: /home/kkutysllb/tmp/vmware-root_9409-3878589979/</span><br><span class="line">creating: /home/kkutysllb/tmp/vmware-root_9328-3134798637/</span><br><span class="line">creating: /home/kkutysllb/tmp/systemd-private-5b1137097c084a899dfd1557504d079d-chronyd.service-6Ra806/</span><br><span class="line">creating: /home/kkutysllb/tmp/systemd-private-5b1137097c084a899dfd1557504d079d-chronyd.service-6Ra806/tmp/</span><br><span class="line">creating: /home/kkutysllb/tmp/vmware-root_9392-3134798733/</span><br></pre></td></tr></table></figure><h2 id="scp：远程文件复制"><a href="#scp：远程文件复制" class="headerlink" title="scp：远程文件复制"></a>scp：远程文件复制</h2><p>scp命令用于在不同的主机之间复制文件，它采用SSH协议来保证复制的安全性。scp命令每次都是全量完整复制，因此效率不高，适合第一次复制时使用，增量复制建议使用rsync命令替代。</p><p><strong>语法格式：scp [option] [[user@]host1:]file1 [[user@]host2:]file2</strong></p><p><strong>重要参数选项</strong></p><p><img src="https://i.loli.net/2019/04/28/5cc48a4764ac9.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）将文件或目录从服务器01复制推懂到服务器02</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将C7 Server01（192.168.101.81）根目录下tmp_new.zip文件推动C7 Server02（192.168.101.81）的/tmp目录下</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 /]<span class="comment"># scp /tmp_new.zip 192.168.101.82:/tmp</span></span><br><span class="line">The authenticity of host <span class="string">'192.168.101.82 (192.168.101.82)'</span> can<span class="string">'t be established.</span></span><br><span class="line"><span class="string">ECDSA key fingerprint is SHA256:xX2VNfiU72qXldv5e8O0B4jJ6+AR4UdVH1AsOvRKeOw.</span></span><br><span class="line"><span class="string">ECDSA key fingerprint is MD5:37:bc:16:82:b1:55:0f:55:2e:ae:08:9c:55:db:4e:f5.</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no)? yes  # 这里输入连接确认信息</span></span><br><span class="line"><span class="string">Warning: Permanently added '</span>192.168.101.82<span class="string">' (ECDSA) to the list of known hosts.</span></span><br><span class="line"><span class="string">root@192.168.101.82'</span>s password:   <span class="comment"># 这里输入C7 Server02服务器登录密码</span></span><br><span class="line">tmp_new.zip                                                                                                                                               100% 4574     4.2MB/s   00:00 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看C7 Server02的/tmp目录下文件信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server02 ~]<span class="comment"># ll -h /tmp/tmp*.zip</span></span><br><span class="line">-rw-r--r-- 1 root root 4.5K Apr 28 00:09 /tmp/tmp_new.zip</span><br></pre></td></tr></table></figure><p><strong>2）保持文件属性进行远程文件/目录推送</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前服务器/home/kkutysllb/test.sh文件属性信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 /]<span class="comment"># ls -lhi /home/kkutysllb/test.sh</span></span><br><span class="line">1231052 -rw-r--r-- 1 root root 114 Apr 19 18:03 /home/kkutysllb/test.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-p选项，保持文件属性推送</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 /]<span class="comment"># scp -p /home/kkutysllb/test.sh 192.168.101.82:/tmp</span></span><br><span class="line">root@192.168.101.82<span class="string">'s password: </span></span><br><span class="line"><span class="string">test.sh                                                                                                                                                   100%  114     1.4KB/s   00:00</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 查看C7 Server02服务器上/tmp目录下test.sh文件属性</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[root@C7-Server02 ~]# ls -lhi /tmp/test.sh </span></span><br><span class="line"><span class="string">34631592 -rw-r--r-- 1 root root 114 Apr 19 18:03 /tmp/test.sh</span></span><br></pre></td></tr></table></figure><p><strong>3）递归推送目录到远程服务器</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-r选项递归复制目录到远程服务器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制目录，最好加上-p选项保持源目录下所有文件和子目录的属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看C7 Server02下/home目录下信息</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server02 ~]<span class="comment"># ls /home</span></span><br><span class="line">[root@C7-Server02 ~]<span class="comment"># </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将Sever01下/home/kkutysllb/目录整体推送到Server02下</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 /]<span class="comment"># scp -rp /home/kkutysllb/ 192.168.101.82:/home</span></span><br><span class="line">root@192.168.101.82<span class="string">'s password: </span></span><br><span class="line"><span class="string">.bash_logout                                                                                                                                              100%   18    17.3KB/s   00:00    </span></span><br><span class="line"><span class="string">.bash_profile                                                                                                                                             100%  193   322.5KB/s   00:00    </span></span><br><span class="line"><span class="string">.bashrc                                                                                                                                                   100%  231     3.1KB/s   00:00    </span></span><br><span class="line"><span class="string">.bash_history                                                                                                                                             100%   41    21.9KB/s   00:00    </span></span><br><span class="line"><span class="string">image008                                                                                                                                                  100%    0     0.0KB/s   00:00    </span></span><br><span class="line"><span class="string">image009                                                                                                                                                  100%    0     0.0KB/s   00:00    </span></span><br><span class="line"><span class="string">202012312234.55                                                                                                                                           100%    0     0.0KB/s   00:00    </span></span><br><span class="line"><span class="string">image010                                                                                                                                                  100%    0     0.0KB/s   00:00    </span></span><br><span class="line"><span class="string">hard_link                                                                                                                                                 100%  158   114.9KB/s   00:00    </span></span><br><span class="line"><span class="string">soft_link                                                                                                                                                 100%  187   259.1KB/s   00:00    </span></span><br><span class="line"><span class="string">data001                                                                                                                                                   100%   54   106.1KB/s   00:00    </span></span><br><span class="line"><span class="string">data002                                                                                                                                                   100%   73   137.8KB/s   00:00    </span></span><br><span class="line"><span class="string">test.sh                                                                                                                                                   100%  114   150.9KB/s   00:00    </span></span><br><span class="line"><span class="string">data003                                                                                                                                                   100%  121   176.4KB/s   00:00    </span></span><br><span class="line"><span class="string">data004                                                                                                                                                   100%   66   131.4KB/s   00:00    </span></span><br><span class="line"><span class="string">test01.sh                                                                                                                                                 100%   82    38.6KB/s   00:00    </span></span><br><span class="line"><span class="string">test01                                                                                                                                                    100%    0     0.0KB/s   00:00    </span></span><br><span class="line"><span class="string">data005                                                                                                                                                   100%  102    86.8KB/s   00:00    </span></span><br><span class="line"><span class="string">html01                                                                                                                                                    100%    0     0.0KB/s   00:00    </span></span><br><span class="line"><span class="string">html02                                                                                                                                                    100%    0     0.0KB/s   00:00    </span></span><br><span class="line"><span class="string">html03                                                                                                                                                    100%    0     0.0KB/s   00:00    </span></span><br><span class="line"><span class="string">html04                                                                                                                                                    100%    0     0.0KB/s   00:00    </span></span><br><span class="line"><span class="string">html05                                                                                                                                                    100%    0     0.0KB/s   00:00    </span></span><br><span class="line"><span class="string">html06                                                                                                                                                    100%    0     0.0KB/s   00:00    </span></span><br><span class="line"><span class="string">html07                                                                                                                                                    100%    0     0.0KB/s   00:00    </span></span><br><span class="line"><span class="string">html08                                                                                                                                                    100%    0     0.0KB/s   00:00    </span></span><br><span class="line"><span class="string">html09                                                                                                                                                    100%    0     0.0KB/s   00:00    </span></span><br><span class="line"><span class="string">html10                                                                                                                                                    100%    0     0.0KB/s   00:00    </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 再次查看Server02下/home目录信息</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[root@C7-Server02 ~]# ls -l /home/</span></span><br><span class="line"><span class="string">total 4</span></span><br><span class="line"><span class="string">drwx------ 7 root root 4096 Apr 28 00:00 kkutysllb</span></span><br></pre></td></tr></table></figure><p><strong>4）从远程服务器上拉取文件到本地</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 与推送时选项参数位置对调</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 /]<span class="comment"># scp -rp 192.168.101.82:/home/ /tmp/</span></span><br><span class="line">root@192.168.101.82<span class="string">'s password: </span></span><br><span class="line"><span class="string">.bash_logout                                                                                                                                              100%   18    14.3KB/s   00:00    </span></span><br><span class="line"><span class="string">.bash_profile                                                                                                                                             100%  193   270.0KB/s   00:00    </span></span><br><span class="line"><span class="string">.bashrc                                                                                                                                                   100%  231   439.6KB/s   00:00    </span></span><br><span class="line"><span class="string">.bash_history                                                                                                                                             100%   41    83.3KB/s   00:00    </span></span><br><span class="line"><span class="string">image008                                                                                                                                                  100%    0     0.0KB/s   00:00    </span></span><br><span class="line"><span class="string">image009                                                                                                                                                  100%    0     0.0KB/s   00:00    </span></span><br><span class="line"><span class="string">202012312234.55                                                                                                                                           100%    0     0.0KB/s   00:00    </span></span><br><span class="line"><span class="string">image010                                                                                                                                                  100%    0     0.0KB/s   00:00    </span></span><br><span class="line"><span class="string">hard_link                                                                                                                                                 100%  158   266.8KB/s   00:00    </span></span><br><span class="line"><span class="string">soft_link                                                                                                                                                 100%  187   142.2KB/s   00:00    </span></span><br><span class="line"><span class="string">data001                                                                                                                                                   100%   54    64.2KB/s   00:00    </span></span><br><span class="line"><span class="string">data002                                                                                                                                                   100%   73   111.3KB/s   00:00    </span></span><br><span class="line"><span class="string">test.sh                                                                                                                                                   100%  114   179.0KB/s   00:00    </span></span><br><span class="line"><span class="string">data003                                                                                                                                                   100%  121    49.8KB/s   00:00    </span></span><br><span class="line"><span class="string">data004                                                                                                                                                   100%   66    92.3KB/s   00:00    </span></span><br><span class="line"><span class="string">test01.sh                                                                                                                                                 100%   82   156.1KB/s   00:00    </span></span><br><span class="line"><span class="string">test01                                                                                                                                                    100%    0     0.0KB/s   00:00    </span></span><br><span class="line"><span class="string">data005                                                                                                                                                   100%  102   170.8KB/s   00:00    </span></span><br><span class="line"><span class="string">html01                                                                                                                                                    100%    0     0.0KB/s   00:00    </span></span><br><span class="line"><span class="string">html02                                                                                                                                                    100%    0     0.0KB/s   00:00    </span></span><br><span class="line"><span class="string">html03                                                                                                                                                    100%    0     0.0KB/s   00:00    </span></span><br><span class="line"><span class="string">html04                                                                                                                                                    100%    0     0.0KB/s   00:00    </span></span><br><span class="line"><span class="string">html05                                                                                                                                                    100%    0     0.0KB/s   00:00    </span></span><br><span class="line"><span class="string">html06                                                                                                                                                    100%    0     0.0KB/s   00:00    </span></span><br><span class="line"><span class="string">html07                                                                                                                                                    100%    0     0.0KB/s   00:00    </span></span><br><span class="line"><span class="string">html08                                                                                                                                                    100%    0     0.0KB/s   00:00    </span></span><br><span class="line"><span class="string">html09                                                                                                                                                    100%    0     0.0KB/s   00:00    </span></span><br><span class="line"><span class="string">html10                                                                                                                                                    100%    0     0.0KB/s   00:00  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 查看本地服务器/tmp目录下文件信息</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[root@C7-Server01 /]# ls -lhi /tmp/</span></span><br><span class="line"><span class="string">total 0</span></span><br><span class="line"><span class="string">101098026 drwxr-xr-x 3 root root 23 Apr 28 00:22 home   # 刚拉取过来的目录</span></span><br><span class="line"><span class="string">    35134 drwx------ 3 root root 17 Apr 27 21:43 systemd-private-5b1137097c084a899dfd1557504d079d-chronyd.service-6Ra806</span></span><br><span class="line"><span class="string">     1237 drwx------ 3 root root 17 Apr 21 16:27 systemd-private-f8e761a727fe467cad9e29b0663bc653-chronyd.service-6TlcAm</span></span><br><span class="line"><span class="string">  1231048 drwx------ 2 root root  6 Apr 20 11:06 vmware-root</span></span><br><span class="line"><span class="string">101013160 drwx------ 2 root root  6 Apr 20 16:08 vmware-root_16212-827959067</span></span><br><span class="line"><span class="string">   689143 drwx------ 2 root root  6 Apr 27 21:42 vmware-root_9328-3134798637</span></span><br><span class="line"><span class="string">   689145 drwx------ 2 root root  6 Apr 27 21:43 vmware-root_9392-3134798733</span></span><br><span class="line"><span class="string">   266371 drwx------ 2 root root  6 Apr 22 22:53 vmware-root_9400-3101375875</span></span><br><span class="line"><span class="string">   470132 drwx------ 2 root root  6 Apr 27 12:00 vmware-root_9409-3878589979</span></span><br><span class="line"><span class="string">   266297 drwx------ 2 root root  6 Apr 22 22:52 vmware-root_9420-2857896526</span></span><br><span class="line"><span class="string">     1875 drwx------ 2 root root  6 Apr 21 16:27 vmware-root_9443-3886520225</span></span><br><span class="line"><span class="string">   266369 drwx------ 2 root root  6 Apr 23 10:29 vmware-root_9456-2866351085</span></span><br><span class="line"><span class="string">   266299 drwx------ 2 root root  6 Apr 22 22:23 vmware-root_9458-2857896559</span></span><br><span class="line"><span class="string">   689124 drwx------ 2 root root  6 Apr 23 12:50 vmware-root_9573-4146439782</span></span><br><span class="line"><span class="string">   689142 drwx------ 2 root root  6 Apr 26 17:24 vmware-root_9604-3101310240</span></span><br><span class="line"><span class="string">   266294 drwx------ 2 root root  6 Apr 23 12:41 vmware-root_9609-4121731445</span></span><br><span class="line"><span class="string">   689141 drwx------ 2 root root  6 Apr 23 18:24 vmware-root_9660-3101179142</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;tar：打包备份&quot;&gt;&lt;a href=&quot;#tar：打包备份&quot; class=&quot;headerlink&quot; title=&quot;tar：打包备份&quot;&gt;&lt;/a&gt;tar：打包备份&lt;/h2&gt;&lt;p&gt;在Linux系统里，tar是将多个文件打包在一起，并且可以实现解压打包的文件的命令。是系统管理员最常用的命令之一，tar命令不但可以实现对多个文件进行打包，还可以对多个文件打包后进行压缩。&lt;/p&gt;
&lt;p&gt;打包是指将一大堆文件或目录变成一个总的文件，压缩则是将一个大的文件通过一些压缩算法变成一个小文件。tar命令选项的使用有点特殊，对于CentOS、Linux来说，“tar-z”和“tar z”的效果相同，加或不加“-”这个符号都是可以的。而在FreeBSD系统下，必须加“-”符号。
    
    </summary>
    
      <category term="Linux核心命令" scheme="https://kkutysllb.cn/categories/Linux%E6%A0%B8%E5%BF%83%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Linux" scheme="https://kkutysllb.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>2019-04-27-DPDK技术栈在电信云中的最佳实践（一）</title>
    <link href="https://kkutysllb.cn/2019/04/27/2019-04-27-DPDK%E6%8A%80%E6%9C%AF%E6%A0%88%E5%9C%A8%E7%94%B5%E4%BF%A1%E4%BA%91%E4%B8%AD%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://kkutysllb.cn/2019/04/27/2019-04-27-DPDK技术栈在电信云中的最佳实践（一）/</id>
    <published>2019-04-27T04:59:18.000Z</published>
    <updated>2019-05-01T03:36:47.737Z</updated>
    
    <content type="html"><![CDATA[<p>本文篇幅有限，很难用短短几语就勾勒出DPDK的完整轮廓，概括来说，DPDK是一个技术栈，主要用于Intel架构的服务器领域，其主要目的就是提升x86标准服务器的转发性能。因此，本文只重点介绍DPDK平台部分技术在电信云中的最佳实践。<a id="more"></a></p><h2 id="为什么需要DPDK？"><a href="#为什么需要DPDK？" class="headerlink" title="为什么需要DPDK？"></a>为什么需要DPDK？</h2><p>在IA上，网络数据包处理远早于DPDK而存在。从商业版的Windows到开源的Linux操作系统，所有跨主机通信几乎都会涉及网络协议栈以及底层网卡驱动对于数据包的处理。然而，低速网络数据转发与高速网络数据转发的处理对系统的要求完全不一样。以Linux为例，传统网络设备驱动包处理的动作可以概括如下：</p><ol><li>数据包到达网卡设备。</li><li>网卡设备依据配置进行DMA操作。</li><li>网卡发送中断，唤醒处理器。</li><li>驱动软件填充读写缓冲区数据结构。</li><li>数据报文达到内核协议栈，进行高层处理。</li><li>如果最终应用在用户态，数据从内核搬移到用户态。</li><li>如果最终应用在内核态，在内核继续进行。</li></ol><p>随着网络接口带宽从千兆向万兆迈进，原先每个报文就会触发一个中断，中断带来的开销变得突出，大量数据到来会触发频繁的中断开销，导致系统无法承受。</p><p>在网络包高性能转发技术领域，有两个著名的技术框架NAPI和Netmap。NAPI策略用于高吞吐的场景，其策略是系统被中断唤醒后，尽量使用轮询的方式一次处理多个数据包，直到网络再次空闲重新转入中断等待，其目的就是解决数据包在转发过程过程中频繁中断引入的大量系统开销。Netmap就是采用共享数据包池的方式，减少内核到用户空间的包复制，从而解决大多数场景下需要把包从内核的缓冲区复制到用户缓冲区引入大量系统开销问题。</p><p>NAPI与Netmap两方面的努力其实已经明显改善了传统Linux系统上的包处理能力，但是，Linux作为分时操作系统，要将CPU的执行时间合理地调度给需要运行的任务。相对于公平分时，不可避免的就是适时调度。早些年CPU核数比较少，为了每个任务都得到响应处理，进行充分分时，用效率换响应，是一个理想的策略。现今CPU核数越来越多，性能越来越强，为了追求极端的高性能高效率，分时就不一定总是上佳的策略。以Netmap为例，即便其减少了内核到用户空间的内存复制，但内核驱动的收发包处理和用户态线程依旧由操作系统调度执行，除去任务切换本身的开销，由切换导致的后续cache替换（不同任务内存热点不同），对性能也会产生负面的影响。为此，Intel针对IA架构的这些问题，就提出了DPDK技术栈的架构，其根本目的就是尽量采用用户态驱动能力来替代内核态驱动，从而减少内核态的开销，提升转发性能。</p><h2 id="鸟瞰DPDK"><a href="#鸟瞰DPDK" class="headerlink" title="鸟瞰DPDK"></a>鸟瞰DPDK</h2><p>什么是DPDK？在《DPDK深入浅出》一书中，有以下一段描述：</p><blockquote><p>针对不同的对象，其定义并不相同。对于普通用户来说，它可能是一个性能出色的包数据处理加速软件库；对于开发者来说，它可能是一个实践包处理新想法的创新工场；对于性能调优者来说，它可能又是一个绝佳的成果分享平台。当下火热的网络功能虚拟化，则将DPDK放在一个重要的基石位置。</p></blockquote><p>DPDK最初的动机很简单，就是为了证明IA多核处理器能够支撑高性能数据包处理。随着早期目标的达成和更多通用处理器体系的加入，DPDK逐渐成为通用多核处理器高性能数据包处理的业界标杆。</p><p>目前，DPDK技术主要应用于计算领域的硬件加速器、通信领域的网络处理器和IT领域的多核处理器。随着软件（例如，DPDK）在I/O性能提升上的不断创新，将多核处理器的竞争力提升到一个前所未有的高度。在SDN/NFV领域，DPDK技术得到了空前应用，产生了不少最佳实践案例。</p><p><img src="https://i.loli.net/2019/04/27/5cc3e29dacd51.jpg"></p><p>DPDK提出的目的就是为IA上的高速包处理。下图所示的DPDK主要模块分解展示了以基础软件库的形式，为上层应用的开发提供一个高性能的基础I/O开发包。主要利用了有助于包处理的软硬件特性，如大页、缓存行对齐、线程绑定、预取、NUMA、IA最新指令的利用、Intel DDIO、内存交叉访问等。</p><p><img src="https://i.loli.net/2019/04/27/5cc3e2d3d69cf.jpg"></p><ul><li><strong>核心库Core Libs</strong>，提供系统抽象、大页内存、缓存池、定时器及无锁环等基础组件。</li><li><strong>PMD库</strong>，提供全用户态的驱动，以便通过轮询和线程绑定得到极高的网络吞吐，支持各种本地和虚拟的网卡。</li><li><strong>Classify库</strong>，支持精确匹配（Exact Match）、最长匹配（LPM）和通配符匹配（ACL），提供常用包处理的查表操作。</li><li><strong>QoS库</strong>，提供网络服务质量相关组件，如限速（Meter）和调度（Sched）。</li></ul><p>除了这些组件，DPDK还提供了几个平台特性，比如节能考虑的运行时频率调整（POWER），与Linux kernel stack建立快速通道的KNI（Kernel Network Interface）。而Packet Framework和DISTRIB为搭建更复杂的多核流水线处理模型提供了基础的组件。</p><p>DPDK软件包内有一个最基本的三层转发实例（l3fwd），可用于测试双路服务器整系统的吞吐能力，通过现场实验，可以达到220Gbit/s的数据报文吞吐能力。除了通过硬件或者软件提升性能之外，如今DPDK整系统报文吞吐能力上限已经不再受限于CPU的核数，当前瓶颈在于PCIe（IO总线）的LANE数。换句话说，系统性能的整体I/O天花板不再是CPU，而是系统所提供的所有PCIe LANE的带宽，也就是能插入多少个高速以太网接口卡。</p><p>在这样的性能基础上，网络节点的软化（NFV）就成为可能。对于网络节点上运转的不同形态的网络功能，通过软化并适配到一个通用的硬件平台，就是软硬件解耦。解耦正是NFV的一个核心思想，而硬件解耦的多个网络功能在单一通用节点上的隔离共生问题，就是另一个核心思想—<strong>虚拟化</strong>。</p><h2 id="DPDK技术基础（1）"><a href="#DPDK技术基础（1）" class="headerlink" title="DPDK技术基础（1）"></a>DPDK技术基础（1）</h2><h3 id="cache的作用"><a href="#cache的作用" class="headerlink" title="cache的作用"></a>cache的作用</h3><p>在当今服务器领域，一个处理器通常包含多个核心（Core），集成Cache子系统，内存子系统通过内部或外部总线与其通信。在经典计算机系统中一般都有两个标准化的部分：北桥（North Bridge）和南桥（SouthBridge）。它们是处理器和内存以及其他外设沟通的渠道。在这类系统中，北桥就是真个架构的瓶颈，一旦北桥处理不过来或故障，整个系统的处理效率就会变低或瘫痪。因此，后来计算机系统中只存在南桥芯片，而北桥部分就被全部移植到CPU的SoC中，其中最重要的部分就是内存控制器，并在此基础上进一步衍生出NUMA和MPP架构，这个放在后面会讲。</p><p>我们在本科学习计算机基础课程时，都知道计算机的内存分为SRAM、DRAM、SDRAM和DDR(1/2/3/4)等不同类型。在早期的PC系统中，主要使用DRAM和SDRAM来作为内存，相比SRAM在成本、功耗方面有不小的优势，而且速度也还可以。后来在现今的PC系统中，利用SDRAM在一个时钟周期的上下边沿进行数据读写，整体数据吞吐率带宽翻倍，也就是DDR RAM，DDR根据不同的主频，又分为DDR1/DDR2/DDR3/DDR4。而SRAM，由于其功耗高、成本高，速度很快，一般都作为CPU的cache使用，目前都被封装的CPU的SoC中。</p><p>一般来说，Cache由三级组成，之所以对Cache进行分级，也是从成本和生产工艺的角度考虑的。一级（L1）最快，但是容量最小；三级（LLC，Last Level Cache）最慢，但是容量最大。</p><p><img src="https://i.loli.net/2019/04/27/5cc3e3322d7e4.jpg"></p><ul><li><strong>一级Cache</strong>：一般分为数据Cache和指令Cache，数据Cache用来存储数据，而指令Cache用于存放指令。这种Cache速度最快，一般处理器只需要3～5个指令周期就能访问到数据，因此成本高，容量小，一般都只有几十KB。</li><li><strong>二级Cache：</strong>和一级Cache分为数据Cache和指令Cache不同，数据和指令都无差别地存放在一起。速度相比一级Cache慢一些，处理器大约需要十几个处理器周期才能访问到数据，容量也相对来说大一些，一般有几百KB到几MB不等。</li><li><strong>三级Cache：</strong>速度更慢，处理器需要几十个处理器周期才能访问到数据，容量更大，一般都有几MB到几十个MB。在多核处理器内部，三级Cache由所有的核心所共有。这样的共享方式，其实也带来一个问题，有的处理器可能会极大地占用三级Cache，导致其他处理器只能占用极小的容量，从而导致Cache不命中，性能下降。因此，Intel公司推出了Intel® CAT技术，确保有一个公平，或者说软件可配置的算法来控制每个核心可以用到的Cache大小，有兴趣的可参考<a href="https://software.intel.com/zh-cn/articles/introduction-to-cache-allocation-technology?_ga=2.54835683.913561365.1556263296-1903721401.1556263296" target="_blank" rel="noopener">https://software.intel.com/zh-cn/articles/introduction-to-cache-allocation-technology?_ga=2.54835683.913561365.1556263296-1903721401.1556263296</a>。</li></ul><p>为了将cache与内存进行关联，需要对cache和内存进行分块，并采用一定的映射算法进行关联。分块就是将Cache和内存以块为单位进行数据交换，块的大小通常以在内存的一个存储周期中能够访问到的数据长度为限。当今主流块的大小都是64字节，因此一个<strong>Cache line</strong>就是指64个字节大小的数据块。而映射算法是指把内存地址空间映射到Cache地址空间。具体来说，就是把存放在内存中的内容按照一定规则装入到Cache中，并建立内存地址与Cache地址之间的对应关系。当CPU需要访问这个数据块内容时，只需要把内存地址转换成Cache地址，从而在Cache中找到该数据块，最终返回给CPU。</p><p>根据Cache和内存之间的映射关系的不同，Cache可以分为三类：第一类是<strong>全关联型Cache</strong>（full associative cache），第二类是<strong>直接关联型Cache</strong>（direct mapped cache），第三类是<strong>组关联型Cache</strong>（N-ways associative cache）。</p><p><strong>全关联型cache</strong>：需要在cache中建立一个目录表，目录表的每一项由内存地址、cache块号和一个有效位组成。当CPU需要访问某个内存地址时，首先查询该目录表判断该内容是否缓存在Cache中，如果在，就直接从cache中读取内容；如果不在，就去通过内存地址转换去内存冲读取。具体原理如下：</p><p><img src="https://i.loli.net/2019/04/27/5cc3e38aabc9c.jpg"></p><p>首先，用内存的块地址A在Cache的目录表中进行查询，如果找到等值的内存块地址，检查有效位是否有效，只有有效的情况下，才能通过Cache块号在Cache中找到缓存的内存，并且加上块内地址B，找到相应数据，这时则称为Cache命中，处理器拿到数据返回；否则称为不命中，CPU则需要在内存中读取相应的数据。使用全关联型Cache，块的冲突最小（没有冲突），Cache的利用率也高，但是需要一个访问速度很快的相联存储器。随着Cache容量的增加，其电路设计变得十分复杂，因此一般只有TLB cache才会设计成全关联型。</p><p><strong>直接关联型Cache：</strong>是指将某一块内存映射到Cache的一个特定的块，即Cache line中。假设一个Cache中总共存在N个Cache line，那么内存就被分成N等分，其中每一等分对应一个Cache line。比如：Cache的大小是2K，而一个Cache line的大小是64B，那么就一共有2K/64B=32个Cache line，那么对应我们的内存，第1块（地址0～63），第33块（地址64<em>32～64</em>33-1），以及第（N<em>32+1）块都被映射到Cache第一块中；同理，第2块，第34块，以及第（N</em>32+2）块都被映射到Cache第二块中；可以依次类推其他内存块。直接关联型Cache的目录表只有两部分组成：<strong>区号</strong>和<strong>有效位</strong>。具体原理如下：</p><p><img src="https://i.loli.net/2019/04/27/5cc3e3b41a473.jpg"></p><p>首先，内存地址被分成三部分：<strong>区号A、块号B</strong>和<strong>块内地址C</strong>。根据区号A在目录表中找到完全相等的区号，并且在有效位有效的情况下，说明该数据在Cache中，然后通过内存地址的块号B获得在Cache中的块地址，加上块内地址C，最终找到数据。如果在目录表中找不到相等的区号，或者有效位无效的情况下，则说明该内容不在Cache中，需要到内存中读取。可以看出，直接关联是一种很“死”的映射方法，当映射到同一个Cache块的多个内存块同时需要缓存在Cache中时，只有一个内存块能够缓存，其他块需要被“淘汰”掉。因此，直接关联型命中率是最低的，但是其实现方式最为简单，匹配速度也最快。</p><p><strong>组关联型Cache：</strong>是目前Cache中用的比较广泛的一种方式，是前两种Cache的折中形式。在这种方式下，内存被分为很多组，一个组的大小为多个Cache line的大小，一个组映射到对应的多个连续的Cache line，也就是一个Cache组，并且该组内的任意一块可以映射到对应Cache组的任意一个。可以看出，在组外，其采用直接关联型Cache的映射方式，而在组内，则采用全关联型Cache的映射方式。比如：有一个4路组关联型Cache，其大小为1M，一个Cache line的大小为64B，那么总共有16K个Cache line，但是在4路组关联的情况下，就拥有了4K个组，每个组有4个Cache line。一个内存单元可以缓存到它所对应的组中的任意一个Cache line中去。具体原理如下：</p><p><img src="https://i.loli.net/2019/04/27/5cc3e3dbd46c5.jpg"></p><p>目录表由三部分组成：<strong>“区号+块号”、Cache块号</strong>和<strong>有效位</strong>。一个内存地址被分成四部分：<strong>区号A、组号B、块号C</strong>和<strong>块内地址D</strong>。首先，根据组号B按地址查找到一组目录表项；然后，根据区号A和块号C在该组中进行关联查找（即并行查找，为了提高效率），如果匹配且有效位有效，则表明该数据块缓存在Cache中，得到Cache块号，加上块内地址D，可以得到该内存地址在Cache中映射的地址，得到数据；如果没有找到匹配项或者有效位无效，则表示该内存块不在Cache中，需要处理器到内存中读取。</p><p>Cache之所以能够提高系统性能，主要是因为程序执行存在局部性现象，即<strong>时间局部性（程序中指令和数据在时间上的关联性，比如：循环体中的变量和指令）</strong>和<strong>空间局部性（程序中指令和数据在空间上的关联性，比如：列表数据结构中的元素）。</strong>cache就可以根据程序的局部性特点，以及当前执行状态、历史执行过程、软件提示等信息，然后以一定的合理方法，在数据/指令被使用前取入Cache，也就是<strong>cache预取</strong>。</p><p>内存的数据被加载进cache后，最终还是需要写回到内存中，这个写回的过程存在两种策略：</p><p><strong>直写（write-through）：</strong>在CPU对Cache写入的同时，将数据写入到内存中。这种策略保证了在任何时刻，内存的数据和Cache中的数据都是同步的，这种方式简单、可靠。但由于CPU每次对Cache更新时都要对内存进行写操作，总线工作繁忙，内存的带宽被大大占用，因此运行速度会受到影响。</p><p><strong>回写（write-back）：</strong>回写相对于直写而言是一种高效的方法。回写系统通过将Cache line的标志位字段添加一个Dirty标志位，当处理器在改写了某个Cache line后，并不是马上把其写回内存，而是将该Cache line的Dirty标志设置为1。当处理器再次修改该Cache line并且写回到Cache中，查表发现该Dirty位已经为1，则先将Cache line内容写回到内存中相应的位置，再将新数据写到Cache中。</p><p>除了上述这两种写策略，还有WC（write-combining）和UC（uncacheable）。这两种策略都是针对特殊的地址空间来使用的，这里不做详细讨论，有兴趣的可以参考Intel官方社区。</p><p>在采用回写策略的架构中，如果多个CPU同时对一个cache line进行修改后的写回操作，就存在“脏”数据区域的问题，这就是cache一致性问题。其本质原因是<strong>存在多个处理器独占的Cache，而不是多个处理器。</strong>解决Cache一致性问题的机制有两种：基于目录的协议（Directory-based protocol）和总线窥探协议（Bus snooping protocol）。这里因为篇幅问题，不再展开讨论，有兴趣的可参见《深入浅出DPDK》一书相关内容。</p><p>事实上，Cache对于绝大多数程序员来说都是透明不可见的，cache完成数据缓存的所有操作都是硬件自动完成的。但是，硬件也不是完全智能的。因此，Intel体系架构引入了能够对Cache进行预取的指令，使一些对程序执行效率有很高要求的程序员能够一定程度上控制Cache，加快程序的执行。DPDK对cache进行预取操作如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (nb_rx &lt; nb_pkts) </span><br><span class="line">&#123; </span><br><span class="line">rxdp = &amp;rx_ring[rx_id]; <span class="comment">//读取接收描述符 </span></span><br><span class="line">staterr = rxdp-&gt;wb.upper.status_error; <span class="comment">//检查是否有报文收到 </span></span><br><span class="line"><span class="keyword">if</span> (！(staterr &amp; rte_cpu_to_le_32(IXGBE_RXDADV_STAT_DD)))</span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line">rxd = *rxdp; <span class="comment">//分配数据缓冲区 </span></span><br><span class="line">nmb = rte_rxmbuf_alloc(rxq-&gt;mb_pool); </span><br><span class="line">nb_hold++; <span class="comment">//读取控制结构体 </span></span><br><span class="line">rxe = &amp;sw_ring[rx_id]; </span><br><span class="line">…… </span><br><span class="line">rx_id++; </span><br><span class="line"><span class="keyword">if</span> (rx_id == rxq-&gt;nb_rx_desc) </span><br><span class="line">    &#123;</span><br><span class="line">        rx_id = <span class="number">0</span>; <span class="comment">//预取下一个控制结构体mbuf</span></span><br><span class="line">        rte_ixgbe_prefetch(sw_ring[rx_id].mbuf); <span class="comment">//预取接收描述符和控制结构体指针 </span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 预取报文 */</span></span><br><span class="line">    <span class="keyword">if</span> ((rx_id &amp; <span class="number">0x3</span>) == <span class="number">0</span>) </span><br><span class="line">    &#123; </span><br><span class="line">        rte_ixgbe_prefetch(&amp;rx_ring[rx_id]); </span><br><span class="line">        rte_ixgbe_prefetch(&amp;sw_ring[rx_id]); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 把接收描述符读取的信息存储在控制结构体mbuf中 */</span></span><br><span class="line">    rte_packet_prefetch((<span class="keyword">char</span> *)rxm-&gt;buf_addr + rxm-&gt;data_off); </span><br><span class="line">rxm-&gt;nb_segs = <span class="number">1</span>; </span><br><span class="line">rxm-&gt;next = <span class="literal">NULL</span>; </span><br><span class="line">rxm-&gt;pkt_len = pkt_len; </span><br><span class="line">rxm-&gt;data_len = pkt_len;</span><br><span class="line">rxm-&gt;port = rxq-&gt;port_id; </span><br><span class="line">……</span><br><span class="line">rx_pkts[nb_rx++] = rxm; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，DPDK在定义数据结构或者数据缓冲区时就申明cache line对齐，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RTE_CACHE_LINE_SIZE 64 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __rte_cache_aligned __attribute__((__aligned__(RTE_CACHE_LINE_SIZE)))</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_ring_debug_stats</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">uint64_t</span> enq_success_bulk; </span><br><span class="line"><span class="keyword">uint64_t</span> enq_success_objs; </span><br><span class="line"><span class="keyword">uint64_t</span> enq_quota_bulk; </span><br><span class="line"><span class="keyword">uint64_t</span> enq_quota_objs; </span><br><span class="line"><span class="keyword">uint64_t</span> enq_fail_bulk; </span><br><span class="line"><span class="keyword">uint64_t</span> enq_fail_objs;</span><br><span class="line"><span class="keyword">uint64_t</span> deq_success_bulk; </span><br><span class="line"><span class="keyword">uint64_t</span> deq_success_objs; </span><br><span class="line"><span class="keyword">uint64_t</span> deq_fail_bulk; </span><br><span class="line"><span class="keyword">uint64_t</span> deq_fail_objs; </span><br><span class="line">&#125; __rte_cache_aligned;</span><br></pre></td></tr></table></figure><h3 id="大页内存"><a href="#大页内存" class="headerlink" title="大页内存"></a>大页内存</h3><p>在前文<a href="https://kkutysllb.cn/2019/04/21/2019-04-21-x86%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80/">《x86架构基础》</a>一文中提到了TLB的概念，其主要用来缓存内存地址转换中的页表项，其本质上也是一个cache，称之为TLB cache。<strong>TLB和cache的区别是：TLB缓存内存地址转换用的页表项，而cache缓存程序用到的数据和指令。</strong></p><p>TLB中保存着程序线性地址前20位[31：12]和页框号的对应关系，如果匹配到线性地址就可以迅速找到页框号，通过页框号与线性地址后12位的偏移组合得到最终的物理地址。TLB使用虚拟地址进行搜索，直接返回对应的物理地址，相对于内存中的多级页表需要多次访问才能得到最终的物理地址，TLB查找大大减少了CPU的开销。如果需要的地址在TLB Cache中，就会迅速返回结果，然后CPU用该物理地址访问内存，这样的查找操作也称为TLB命中；如果需要的地址不在TLB Cache中，也就是不命中，CPU就需要到内存中访问多级页表，才能最终得到物理地址。但是，TLB的大小是有限的，因此TLB不命中的概率很大，为了提高内存地址转换效率，减少CPU的开销，就提出了<strong>大页内存</strong>的概念。</p><p>在x86架构中，一般都分成以下四组TLB：</p><ul><li>第一组：缓存一般页表（4KB页面）的指令页表缓存（Instruction-TLB）。</li><li>第二组：缓存一般页表（4KB页面）的数据页表缓存（Data-TLB）。</li><li>第三组：缓存大尺寸页表（2MB/4MB页面）的指令页表缓存（Instruction-TLB）。</li><li>第四组：缓存大尺寸页表（2MB/4MB页面）的数据页表缓存（Data-TLB）</li></ul><p>如果采用常规页（4KB）并且使TLB总能命中，需要寻址的内容都在该内容页内，那么至少需要在TLB表中存放两个表项。如果一个程序使用了512个内容页也就是2MB大小，那么需要512个页表表项才能保证不会出现TLB不命中的情况。但是，如果采用2MB作为分页的基本单位，那么只需要一个表项就可以保证不出现TLB不命中的情况；对于消耗内存以GB为单位的大型程序，可以采用1GB为单位作为分页的基本单位，减少TLB不命中的情况。需要注意的是：<strong>系统能否支持大页，支持大页的大小为多少是由其使用的处理器决定的。</strong></p><p>在Linux启动之后，如果想预留大页，则可以使用以下的方法来预留内存。在非NUMA系统中，可以使用以下方法预留2MB大小的大页。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 预留1024个大小为2MB的大页，也就是预留了2GB内存。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 1024 &gt; /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages</span><br></pre></td></tr></table></figure><p><strong><em>系统未开启大页内存的状态</em></strong></p><p><img src="https://i.loli.net/2019/04/27/5cc3e5b16a991.jpg"></p><p><strong><em>系统开启大页内存后的状态</em></strong></p><p><img src="https://i.loli.net/2019/04/27/5cc3e5cc93de5.jpg"></p><p>如果是在NUMA系统中，假设有两个NODE的系统中，则可以用以下的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在NODE0和NODE1上各预留1024个大小为2MB的大页，总共预留了4GB大小。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 1024 &gt; /sys/devices/system/node/node0/hugepages/hugepages-2048kB/nr_hugepages </span><br><span class="line"><span class="built_in">echo</span> 1024 &gt; /sys/devices/system/node/node1/hugepages/hugepages-2048kB/nr_hugepages</span><br></pre></td></tr></table></figure><p><strong>而对于大小为1GB的大页，则必须在Linux的GRUB配置文件中进行修改，并重启系统生效，不能动态预留。</strong></p><p>DPDK中也是使用HUGETLBFS来使用大页。首先，它需要把大页mount到某个路径，比如/mnt/huge，以下是命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /mnt/huge </span><br><span class="line">mount -t hugetlbfs nodev /mnt/huge</span><br></pre></td></tr></table></figure><p>需要注意的是：在mount之前，要确保之前已经成功预留内存，否则会失败。该命令只是临时的mount了文件系统，如果想每次开机时省略该步骤，可以修改/etc/fstab文件，加上如下一行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodev /mnt/huge hugetlbfs defaults 0 0</span><br></pre></td></tr></table></figure><p>对于1GB大小的大页，则必须用如下的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodev /mnt/huge_1GB hugetlbfs pagesize=1GB 0 0</span><br></pre></td></tr></table></figure><p>然后，在DPDK运行的时候，会使用<strong>mmap（）系统调用</strong>把大页映射到用户态的虚拟地址空间，然后就可以正常使用了。</p><p><strong>DDIO（Data Direct I/O）数据直连技术</strong></p><p>如今，随着大数据和云计算的爆炸式增长，宽带的普及以及个人终端网络数据的日益提高，对运营商服务节点和数据中心的数据交换能力和网络带宽提出了更高的要求。并且，数据中心本身对虚拟化功能的需求也增加了更多的网络带宽需求。为此，英特尔公司提出了Intel® DDIO（Data Direct I/O）的技术。该技术的主要目的就是让服务器能更快处理网络接口的数据，提高系统整体的吞吐率，降低延迟，同时减少能源的消耗。</p><p>当一个网络报文送到服务器的网卡时，网卡通过外部总线（比如PCI总线）把数据和报文描述符送到内存。接着，CPU从内存读取数据到Cache进而到寄存器。进行处理之后，再写回到Cache，并最终送到内存中。最后，网卡读取内存数据，经过外部总线送到网卡内部，最终通过网络接口发送出去。可以看出，对于一个数据报文，CPU和网卡需要多次访问内存。而内存相对CPU来讲是一个非常慢速的部件。CPU需要等待数百个周期才能拿到数据，在这过程中，CPU什么也做不了。</p><p>DDIO技术思想就是使外部网卡和CPU通过LLC Cache直接交换数据，绕过了内存这个相对慢速的部件。这样，就增加了CPU处理网络报文的速度（减少了CPU和网卡等待内存的时间），减小了网络报文在服务器端的处理延迟。这样做也带来了一个问题，就是<strong>网络报文直接存储在LLC Cache中，对这一级cache的容量有很大需求</strong>。因此，在英特尔的E5处理器系列产品中，把LLC Cache的容量提高到了20MB。DDIO处理网络报文流程示意图如下：</p><p><img src="https://i.loli.net/2019/04/27/5cc3e64a94e86.jpg"></p><p>为了发送一个数据报文到网络上去，首先是运行在CPU上的软件分配了一段内存，然后把这段内存读取到CPU内部，更新数据，并且填充相应的报文描述符（网卡会通过读取描述符了解报文的相应信息），然后写回到内存中，通知网卡，最终网卡把数据读回到内部，并且发送到网络上去。但是，没有DDIO技术和有DDIO技术条件的处理方式是不同的。</p><p><strong><em>a) 没有DDIO时，如下图所示：</em></strong></p><p><img src="https://i.loli.net/2019/04/27/5cc3e66c1fc6d.jpg"></p><p>1）CPU更新报文和控制结构体。由于分配的缓冲区在内存中，因此会触发一次Cache不命中，CPU把内存读取到Cache中，然后更新控制结构体和报文信息。之后通知NIC来读取报文。</p><p>2）NIC收到有报文需要传递到网络上的通知后，读取控制结构体进而知道去内存中读取报文信息。</p><p>3）由于之前CPU刚把该缓冲区从内存读到Cache中并且做了更新，很有可能Cache还没有来得及把更新的内容写回到内存中(回写机制)。因此，当NIC发起一个对内存的读请求时，很有可能这个请求会发送到Cache系统中，Cache系统会把数据写回到内存中。</p><p>4）最后，内存控制器再把数据写到PCI总线上去，NIC从PCI总线上读取数据。</p><p><strong>b) 有DDIO时，如下图所示：</strong></p><p><img src="https://i.loli.net/2019/04/27/5cc3e6d6612ea.jpg"></p><p>1）CPU更新报文和控制结构体。这个步骤和没有DDIO的技术类似，但是由于DDIO的引入，处理器会开始就把内存中的缓冲区和控制结构体预取到Cache，因此减少了内存读的时间。</p><p>2）NIC收到有报文需要传递到网络上的通知后，通过PCI总线去读取控制结构体和报文。利用DDIO技术，I/O访问可以直接将Cache的内容送到PCI总线上。这样，就减少了Cache写回时等待的时间。</p><p><strong>由此可以看出，由于DDIO技术的引入，网卡的读操作减少了访问内存的次数，因而提高了访问效率，减少了报文转发的延迟。在理想状况下，NIC和CPU无需访问内存，直接通过访问Cache就可以完成更新数据，把数据送到NIC内部，进而送到网络上的所有操作。</strong></p><p>有网络报文需要送到系统内部进行处理，其过程一般是NIC从网络上收到报文后，通过PCI总线把报文和相应的控制结构体送到预先分配的内存，然后通知相应的驱动程序或者软件来处理。和之前网卡的读数据操作类似，有DDIO技术和没有DDIO技术的处理也是不一样的。</p><p><strong>a) 没有DDIO时，如下图所示：</strong></p><p><img src="https://i.loli.net/2019/04/27/5cc3e702f0608.jpg"></p><p>1）报文和控制结构体通过PCI总线送到指定的内存中。如果该内存恰好缓存在Cache中（有可能之前CPU有对该内存进行过读写操作），则需要等待Cache把内容先写回到内存中，然后才能把报文和控制结构体写到内存中。</p><p>2）运行在CPU上的驱动程序或者软件得到通知收到新报文，去内存中读取控制结构体和相应的报文，Cache不命中。之所以Cache一定不会命中，是因为即使该内存地址在Cache中，在步骤1中也被强制写回到内存中。因此，只能从内存中读取控制结构体和报文。</p><p><strong>b) 有DDIO时，如下图所示：</strong></p><p><img src="https://i.loli.net/2019/04/27/5cc3e72df17eb.jpg"></p><p>1）这时，报文和控制结构体通过PCI总线直接送到Cache中。这时有两种情形：场景一就是如果该内存恰好缓存在Cache中（有可能之前处理器有对该内存进行过读写操作），则直接在Cache中更新内容，覆盖原有内容。场景二就是如果该内存没有缓存在Cache中，则在最后一级Cache中分配一块区域，并相应更新Cache表，表明该内容是对应于内存中的某个地址的。</p><p>2）运行在CPU上的驱动或者软件被通知到有报文到达，其产生一个内存读操作，由于该内容已经在Cache中，因此直接从Cache中读。</p><p><strong>由此可以看出，DDIO技术在CPU和外设之间交换数据时，减少了CPU和外设访问内存的次数，也减少了Cache写回的等待，提高了系统的吞吐率和数据的交换延迟。</strong></p><h3 id="NUMA系统"><a href="#NUMA系统" class="headerlink" title="NUMA系统"></a>NUMA系统</h3><p>从系统架构来看，目前的商用服务器大体可以分为三类，即<strong>对称多处理器结构 (SMP ： Symmetric Multi-Processor)</strong> ，<strong>非一致存储访问结构 (NUMA ： Non-Uniform Memory Access)</strong> ，以及<strong>海量并行处理结构 (MPP ： Massive Parallel Processing)</strong> 。它们的特征如下：</p><p><img src="https://i.loli.net/2019/04/27/5cc3e75475642.jpg"></p><blockquote><p><strong>SMP (Symmetric Multi Processing)</strong>,对称多处理系统内有许多紧耦合多处理器，在这样的系统中，所有的CPU共享全部资源，如总线，内存和I/O系统等，操作系统或管理数据库的复本只有一个，这种系统有一个最大的特点就是共享所有资源。多个CPU之间没有区别，平等地访问内存、外设、一个操作系统。操作系统管理着一个队列，每个处理器依次处理队列中的进程。如果两个处理器同时请求访问一个资源（例如同一段内存地址），由硬件、软件的锁机制去解决资源争用问题。SMP 服务器的主要特征是共享，系统中所有资源 (CPU 、内存、 I/O 等 ) 都是共享的。也正是由于这种特征，导致了 SMP 服务器的主要问题，<strong>那就是它的扩展能力非常有限</strong>。对于 SMP 服务器而言，每一个共享的环节都可能造成 SMP 服务器扩展时的瓶颈，而最受限制的则是内存。由于每个 CPU 必须通过相同的内存总线访问相同的内存资源，因此随着 CPU 数量的增加，内存访问冲突将迅速增加，最终会造成 CPU 资源的浪费，使 CPU 性能的有效性大大降低。实验证明， SMP 服务器 CPU 利用率最好的情况是 2 至 4 个 CPU 。</p><p><strong>NUMA 服务器</strong>的基本特征是具有多个 CPU 模块，每个 CPU 模块由多个 CPU( 如 4 个 ) 组成，并且具有独立的本地内存、 I/O 槽口等。由于其节点之间可以通过互联模块 ( 如称为 Crossbar Switch) 进行连接和信息交互，因此每个 CPU 可以访问整个系统的内存 ( 这是 NUMA 系统与 MPP 系统的重要差别 ) 。显然，访问本地内存的速度将远远高于访问远地内存 ( 系统内其它节点的内存 ) 的速度，这也是非一致存储访问 NUMA 的由来。由于这个特点，为了更好地发挥系统性能，开发应用程序时需要尽量减少不同 CPU 模块之间的信息交互。利用 NUMA 技术，可以较好地解决原来 SMP 系统的扩展问题，在一个物理服务器内可以支持上百个 CPU 。NUMA 技术同样有一定缺陷，由于访问远地内存的延时远远超过本地内存，因此当 CPU 数量增加时，系统性能无法线性增加。</p><p>和 NUMA 不同， <strong>MPP</strong> 提供了另外一种进行系统扩展的方式，它由多个 SMP 服务器通过一定的节点互联网络进行连接，协同工作，完成相同的任务，从用户的角度来看是一个服务器系统。其基本特征是由多个 SMP 服务器 ( 每个 SMP 服务器称节点 ) 通过节点互联网络连接而成，每个节点只访问自己的本地资源 ( 内存、存储等 ) ，是一种完全无共享 (Share Nothing) 结构，因而扩展能力最好，理论上其扩展无限制，目前的技术可实现 512 个节点互联，数千个 CPU 。<strong>MPP不是处理器内部节点互联，而是多个服务器通过外部互联。</strong>在 MPP 系统中，每个 SMP 节点也可以运行自己的操作系统、数据库等。但和 NUMA 不同的是，它不存在异地内存访问的问题。换言之，每个节点内的 CPU 不能访问另一个节点的内存。节点之间的信息交互是通过节点互联网络实现的，这个过程一般称为数据重分配 (Data Redistribution) 。MPP 服务器需要一种复杂的机制来调度和平衡各个节点的负载和并行处理过程。</p></blockquote><p>NUMA系统是一种多处理器环境下设计的内存结构。在NUMA架构出现前，CPU欢快的朝着频率越来越高的方向发展。受到物理极限的挑战，又转为核数越来越多的方向发展。如果每个core的工作性质都是share-nothing（类似于map-reduce的node节点的作业属性），那么也许就不会有NUMA。由于所有CPU Core都是通过共享一个北桥来读取内存，无论核数如何的发展，北桥在响应时间上的性能瓶颈越来越明显。于是，聪明的硬件设计师们，想到了把内存控制器（原本北桥中读取内存的部分）也做个拆分，平分到了每个die上。于是NUMA就出现了！</p><p><img src="https://i.loli.net/2019/04/27/5cc3e78523f21.jpg"></p><p>NUMA中，虽然内存直接attach在CPU上，但是由于内存被平均分配在了各个die上。只有当CPU访问自身直接attach内存对应的物理地址时，才会有较短的响应时间（后称Local Access）。而如果需要访问其他CPU attach的内存的数据时，就需要通过inter-connect通道访问，响应时间就相比之前变慢了（后称Remote Access）。所以NUMA（Non-Uniform Memory Access）就此得名。</p><p><strong>NUMA的几个概念（Node，socket，core，thread）</strong></p><p><img src="https://i.loli.net/2019/04/27/5cc3e7a0dc86a.jpg"></p><ul><li><p><strong>socket：</strong>就是主板上的CPU插槽; </p></li><li><p><strong>Core：</strong>就是socket里独立的一组程序执行的硬件单元，比如寄存器，计算单元等; </p></li><li><p><strong>Thread：</strong>就是超线程hyperthread的概念，逻辑的执行单元，独立的执行上下文，但是共享core内的寄存器和计算单元。</p></li><li><p><strong>Node：</strong>这个概念其实是用来解决core的分组的问题，具体参见下图来理解（图中的OS CPU可以理解thread，那么core就没有在图中画出），从图中可以看出共有4个socket，每个socket 2个node，每个node中有8个thread，总共4（Socket）× 2（Node）× 8 （4core × 2 Thread） = 64个thread。另外每个node有自己的内部CPU，总线和内存，同时还可以访问其他node内的内存，NUMA的最大的优势就是可以方便的增加CPU的数量，因为Node内有自己内部总线，所以增加CPU数量可以通过增加Node的数目来实现，如果单纯的增加CPU的数量，会对总线造成很大的压力，所以UMA结构不可能支持很多的核。下图出自：《<strong>NUMA Best Practices for Dell PowerEdge 12th Generation Servers</strong>》</p><p><img src="https://i.loli.net/2019/04/27/5cc3e7c6deca7.jpg"></p></li></ul><p>由于每个node内部有自己的CPU总线和内存，所以如果一个虚拟机的vCPU跨不同的Node的话，就会导致一个node中的CPU去访问另外一个node中的内存的情况，这就导致内存访问延迟的增加。在NFV环境中，对性能有比较高的要求，就非常需要同一个虚拟机的vCPU尽量被分配到同一个Node中的pCPU上，所以在OpenStack的Kilo版本及后续版本均增加了基于NUMA感知的虚拟机调度的特性。<strong>详见<a href="http://www.openstack.org官方社区管理员手册文档。" target="_blank" rel="noopener">www.openstack.org官方社区管理员手册文档。</a></strong></p><p><strong>查看服务器中NUMA拓扑架构常用以下命令：</strong></p><p><strong>1）比较常用的是lscpu</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ~]<span class="comment"># lscpu</span></span><br><span class="line">Architecture:          x86_64</span><br><span class="line">CPU op-mode(s):        32-bit, 64-bit</span><br><span class="line">Byte Order:            Little Endian</span><br><span class="line">CPU(s):                4</span><br><span class="line">On-line CPU(s) list:   0-3</span><br><span class="line">Thread(s) per core:    1</span><br><span class="line">Core(s) per socket:    2</span><br><span class="line">Socket(s):             2</span><br><span class="line">NUMA node(s):          2</span><br><span class="line">Vendor ID:             GenuineIntel</span><br><span class="line">CPU family:            6</span><br><span class="line">Model:                 158</span><br><span class="line">Model name:            Intel(R) Core(TM) i9-8950HK CPU @ 2.90GHz</span><br><span class="line">Stepping:              10</span><br><span class="line">CPU MHz:               2903.998</span><br><span class="line">BogoMIPS:              5807.99</span><br><span class="line">Virtualization:        VT-x</span><br><span class="line">Hypervisor vendor:     VMware</span><br><span class="line">Virtualization <span class="built_in">type</span>:   full</span><br><span class="line">L1d cache:             32K</span><br><span class="line">L1i cache:             32K</span><br><span class="line">L2 cache:              256K</span><br><span class="line">L3 cache:              12288K</span><br><span class="line">NUMA node0 CPU(s):     0-3</span><br><span class="line">Flags:                 fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon nopl xtopology tsc_reliable nonstop_tsc eagerfpu pni pclmulqdq vmx ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch ssbd ibrs ibpb stibp tpr_shadow vnmi ept vpid fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 invpcid rtm mpx rdseed adx smap clflushopt xsaveopt xsavec arat spec_ctrl intel_stibp flush_l1d arch_capabilities</span><br></pre></td></tr></table></figure><p>从上面报文输出可以看出，当前机器有2个sockets，每个sockets包含1个numa node，每个numa node中有2个cores，每个cores包含1个thread，所以总的threads数量=2（sockets）×1（node）×2（cores）×1（threads）=4.</p><p><strong>2）通过shell脚本打印出当前机器的socket，core和thread的数量</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 简单打印系统CPU拓扑</span></span><br><span class="line"><span class="comment"># Author: kkutysllb</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> get_nr_processor()</span><br><span class="line">&#123;</span><br><span class="line">grep <span class="string">'^processor'</span> /proc/cpuinfo | wc -l</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> get_nr_socket()</span><br><span class="line">&#123;</span><br><span class="line">grep <span class="string">'physical id'</span> /proc/cpuinfo | awk -F: <span class="string">'&#123;</span></span><br><span class="line"><span class="string">print $2 | "sort -un"&#125;'</span> | wc -l</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> get_nr_siblings()</span><br><span class="line">&#123;</span><br><span class="line">grep <span class="string">'siblings'</span> /proc/cpuinfo | awk -F: <span class="string">'&#123;</span></span><br><span class="line"><span class="string">print $2 | "sort -un"&#125;'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> get_nr_cores_of_socket()</span><br><span class="line">&#123;</span><br><span class="line">grep <span class="string">'cpu cores'</span> /proc/cpuinfo | awk -F: <span class="string">'&#123;</span></span><br><span class="line"><span class="string">print $2 | "sort -un"&#125;'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'===== CPU Topology Table ====='</span></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'+--------------+---------+-----------+'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'| Processor ID | Core ID | Socket ID |'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'+--------------+---------+-----------+'</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line; <span class="keyword">do</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$line</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">'| %-12s | %-7s | %-9s |\n'</span> <span class="variable">$p_id</span> <span class="variable">$c_id</span> <span class="variable">$s_id</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'+--------------+---------+-----------+'</span></span><br><span class="line"><span class="built_in">continue</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">echo</span> <span class="string">"<span class="variable">$line</span>"</span> | grep -q <span class="string">"^processor"</span>; <span class="keyword">then</span></span><br><span class="line">p_id=`<span class="built_in">echo</span> <span class="string">"<span class="variable">$line</span>"</span> | awk -F: <span class="string">'&#123;print $2&#125;'</span> | tr -d <span class="string">' '</span>` </span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">echo</span> <span class="string">"<span class="variable">$line</span>"</span> | grep -q <span class="string">"^core id"</span>; <span class="keyword">then</span></span><br><span class="line">c_id=`<span class="built_in">echo</span> <span class="string">"<span class="variable">$line</span>"</span> | awk -F: <span class="string">'&#123;print $2&#125;'</span> | tr -d <span class="string">' '</span>` </span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">echo</span> <span class="string">"<span class="variable">$line</span>"</span> | grep -q <span class="string">"^physical id"</span>; <span class="keyword">then</span></span><br><span class="line">s_id=`<span class="built_in">echo</span> <span class="string">"<span class="variable">$line</span>"</span> | awk -F: <span class="string">'&#123;print $2&#125;'</span> | tr -d <span class="string">' '</span>` </span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span> &lt; /proc/cpuinfo</span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line">awk -F: <span class="string">'&#123; </span></span><br><span class="line"><span class="string">if ($1 ~ /processor/) &#123;</span></span><br><span class="line"><span class="string">gsub(/ /,"",$2);</span></span><br><span class="line"><span class="string">p_id=$2;</span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">else if ($1 ~ /physical id/)&#123;</span></span><br><span class="line"><span class="string">gsub(/ /,"",$2);</span></span><br><span class="line"><span class="string">s_id=$2;</span></span><br><span class="line"><span class="string">arr[s_id]=arr[s_id] " " p_id</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">END&#123;</span></span><br><span class="line"><span class="string">for (i in arr) </span></span><br><span class="line"><span class="string">printf "Socket %s:%s\n", i, arr[i];</span></span><br><span class="line"><span class="string">&#125;'</span> /proc/cpuinfo</span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'===== CPU Info Summary ====='</span></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line">nr_processor=`get_nr_processor`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Logical processors: <span class="variable">$nr_processor</span>"</span></span><br><span class="line">nr_socket=`get_nr_socket`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Physical socket: <span class="variable">$nr_socket</span>"</span></span><br><span class="line">nr_siblings=`get_nr_siblings`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Siblings in one socket: <span class="variable">$nr_siblings</span>"</span></span><br><span class="line">nr_cores=`get_nr_cores_of_socket`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Cores in one socket: <span class="variable">$nr_cores</span>"</span></span><br><span class="line"><span class="built_in">let</span> nr_cores*=nr_socket</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Cores in total: <span class="variable">$nr_cores</span>"</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$nr_cores</span>"</span> = <span class="string">"<span class="variable">$nr_processor</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Hyper-Threading: off"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Hyper-Threading: on"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'===== END ====='</span></span><br></pre></td></tr></table></figure><p>运行后输出结果如下：</p><p><img src="https://i.loli.net/2019/04/27/5cc3e8c3924d0.jpg"></p><p><strong>DPDK中有以下策略来适应NUMA系统：</strong></p><p><strong>1）Per-core memory：</strong>一个CPU上有多个核（core），per-core memory是指每个核都有属于自己的内存，即对于经常访问的数据结构，每个核都有自己的备份。这样做一方面是为了本地内存的需要，另外一方面也是前面提到的Cache一致性的需要，避免多个核访问同一个Cache Line。</p><p><strong>2）本地设备本地处理</strong>：即用本地的处理器、本地的内存来处理本地的设备上产生的数据。如果有一个PCI设备在node0上，就用node0上的核来处理该设备，处理该设备用到的数据结构和数据缓冲区都从node0上分配。以下是一个分配本地内存的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* allocate memory for the queue structure */</span> </span><br><span class="line"><span class="comment">/* 该例分配一个结构体，通过传递socket_id，即node id获得本地内存，并且以Cache Line对齐 */</span></span><br><span class="line">q = rte_zmalloc_socket(<span class="string">"fm10k"</span>, <span class="keyword">sizeof</span>(*q), RTE_CACHE_LINE_SIZE, socket_id);</span><br></pre></td></tr></table></figure><h3 id="CPU的亲和性调度"><a href="#CPU的亲和性调度" class="headerlink" title="CPU的亲和性调度"></a>CPU的亲和性调度</h3><p>当前，属于多核处理器时代，这类多核处理器自然会面对一个问题，按照什么策略将任务线程分配到各个处理器上执行。众所周知，这个分配工作一般由操作系统完成。负载均衡当然是比较理想的策略，按需指定的方式也是很自然的诉求，因为其具有确定性。简单地说，<strong>CPU亲和性（Core affinity）就是一个特定的任务要在某个给定的CPU上尽量长时间地运行而不被迁移到其他处理器上的倾向性。</strong>这意味着线程可以不在处理器之间频繁迁移，从而减少不必要的开销。</p><p>Linux内核包含了一种机制，它让开发人员可以编程实现CPU亲和性。也就是说可以将应用程序显式地指定线程在哪个（或哪些）CPU上运行。</p><p>在Linux内核中，所有的线程都有一个相关的数据结构，称为<strong>task_struct</strong>。这个结构非常重要，这里不展开讨论，只讨论其中与亲和性相关度最高的是<strong>cpus_allowed位掩码</strong>。这个位掩码由n位组成，与系统中的n个逻辑处理器一一对应。具有4个物理CPU的系统可以有4位。如果这些CPU都启用了超线程，那么这个系统就有一个8位的位掩码。</p><p><strong>如果针对某个线程设置了指定的位，那么这个线程就可以在相关的CPU上运行。因此，如果一个线程可以在任何CPU上运行，并且能够根据需要在处理器之间进行迁移，那么位掩码就全是1。**</strong>实际上，在Linux中，这就是线程的默认状态。**</p><p>Linux内核API提供了一些方法，让用户可以修改位掩码或查看当前的位掩码：</p><ul><li><strong>sched_set_affinity（）（用来修改位掩码）</strong></li><li><strong>sched_get_affinity（）（用来查看当前的位掩码）</strong></li></ul><p><strong>注意，cpu_affinity会被传递给子线程，因此应该适当地调用sched_set_affinity。</strong></p><p><strong>将线程与CPU绑定，最直观的好处就是提高了CPU Cache的命中率</strong>，从而减少内存访问损耗，提高程序的速度。在多核体系CPU上，提高外设以及程序工作效率最直观的办法就是让各个物理核各自负责专门的事情。尤其在在NUMA架构下，这个操作对系统运行速度的提升有更大的意义，跨NUMA节点的任务切换，将导致大量三级Cache的丢失。从这个角度来看，NUMA使用CPU绑定时，每个核心可以更专注地处理一件事情，资源体系被充分使用，减少了同步的损耗。</p><p>通常Linux内核都可以很好地对线程进行调度，在应该运行的地方运行线程，也就是说在可用的处理器上运行并获得很好的整体性能。内核包含了一些用来检测CPU之间任务负载迁移的算法，可以启用线程迁移来降低繁忙的处理器的压力。只有在以下三个特殊场景会用到CPU亲和性绑定机制：</p><ul><li><strong>大量计算：</strong>在科学计算和理论计算中，如果不进行CPU亲和性绑定，会发现自己的应用程序要在多处理器的机器上花费大量时间进行迁移从而完成计算。</li><li><strong>复杂程序测试：</strong>比如在线性可伸缩测试中，我们期望的理论模型是如果应用程序随着CPU的增加可以线性地伸缩，那么每秒事务数和CPU个数之间应该会是线性的关系。这样建模可以测试应用程序是否可以有效地使用底层硬件。如果一个给定的线程迁移到其他地方去了，那么它就失去了利用CPU缓存的优势。实际上，如果正在使用的CPU需要为自己缓存一些特殊的数据，那么其他所有CPU都会使这些数据在自己的缓存中失效。因此，如果有多个线程都需要相同的数据，那么将这些线程绑定到一个特定的CPU上，就可以确保它们访问相同的缓存数据或者至少可以提高缓存的命中率。</li><li><strong>实时性线程：</strong>对于实时性线程经常会希望使用亲和性来指定一个8路主机上的某个CPU来处理，而同时允许其他7个CPU处理所有普通的系统调度。这种做法对长时间运行、对时间敏感的应用程序可以确保正常运行，同时可以允许其他应用程序独占其余的计算资源。</li></ul><p>Linux内核提供了启动参数isolcpus。对于有4个CPU的服务器，在启动的时候加入启动参数isolcpus=2，3。那么系统启动后将不使用CPU3和CPU4。<strong>注意，这里说的不使用不是绝对地不使用，系统启动后仍然可以通过taskset命令指定哪些程序在这些核心中运行。</strong></p><p><strong>1）修改/etc/default/grub文件中内容，在CMDLINE中添加如下图所示设置</strong></p><p><img src="https://i.loli.net/2019/04/27/5cc3e91e07d20.jpg"></p><p><strong>2）编译内核启动文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 myshell]<span class="comment"># grub2-mkconfig -o /boot/grub2/grub.cfg</span></span><br><span class="line">Generating grub configuration file ...</span><br><span class="line">Found linux image: /boot/vmlinuz-3.10.0-957.10.1.el7.x86_64</span><br><span class="line">Found initrd image: /boot/initramfs-3.10.0-957.10.1.el7.x86_64.img</span><br><span class="line">Found linux image: /boot/vmlinuz-3.10.0-862.el7.x86_64</span><br><span class="line">Found initrd image: /boot/initramfs-3.10.0-862.el7.x86_64.img</span><br><span class="line">Found linux image: /boot/vmlinuz-0-rescue-e344b139f44946638783478bcb51f820</span><br><span class="line">Found initrd image: /boot/initramfs-0-rescue-e344b139f44946638783478bcb51f820.img</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><strong>3）重启系统后查看/proc/cmdline配置文件是否设置生效</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 ~]<span class="comment"># cat /proc/cmdline </span></span><br><span class="line">BOOT_IMAGE=/vmlinuz-3.10.0-957.10.1.el7.x86_64 root=UUID=0887567f-1df6-425f-ba3d-ce58584279e0 ro crashkernel=auto biosdevname=0 net.ifnames=0 rhgb quiet isolcpu=2,3</span><br></pre></td></tr></table></figure><p>DPDK的线程基于pthread接口创建，属于抢占式线程模型，受内核调度支配。DPDK通过在多核设备上创建多个线程，每个线程绑定到单独的核上，减少线程调度的开销，以提高性能。DPDK的线程可以作为<strong>控制线程</strong>，也可以作为<strong>数据线程</strong>。控制线程一般绑定到MASTER核上，接受用户配置，并传递配置参数给数据线程等；数据线程分布在不同核上处理数据包。</p><p>DPDK的<strong>lcore</strong>指的是EAL线程，本质是基于pthread（Linux/FreeBSD）封装实现。Lcore（EAL pthread）由<strong>remote_launch函数</strong>指定的任务创建并管理。在每个EAL pthread中，有一个<strong>TLS（Thread Local Storage）称为_lcore_id</strong>。当使用DPDK的<strong>EAL‘-c’参数</strong>指定<strong>coremask</strong>时，EAL pthread生成相应个数<strong>lcore</strong>，并默认是1：1亲和到coremask对应的CPU逻辑核，<strong>_lcore_id和CPU ID是一致的。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* rte_eal_cpu_init（）函数中，通过读取/sys/devices/system/cpu/cpuX/下的相关信息，确定当前系统有哪些CPU核，以及每个核属于哪个CPU Socket。eal_parse_args（）函数，解析-c参数，确认哪些CPU核是可以使用的，以及设置第一个核为MASTER。为每一个SLAVE核创建线程，并调用eal_thread_set_affinity（）绑定CPU。线程的执行体是eal_thread_loop（）,函数内部的主体是一个while死循环，调用不同模块注册到lcore_config[lcore_id].f的回调函数 */</span></span><br><span class="line"></span><br><span class="line">RTE_LCORE_FOREACH_SLAVE(i) </span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">/* * create communication pipes between master thread * and children */</span> </span><br><span class="line"><span class="keyword">if</span> (pipe(lcore_config[i].pipe_master2slave) &lt; <span class="number">0</span>) </span><br><span class="line">rte_panic(<span class="string">"Cannot create pipe\n"</span>); </span><br><span class="line"><span class="keyword">if</span> (pipe(lcore_config[i].pipe_slave2master) &lt; <span class="number">0</span>) </span><br><span class="line">rte_panic(<span class="string">"Cannot create pipe\n"</span>); </span><br><span class="line">lcore_config[i].state = WAIT; </span><br><span class="line"><span class="comment">/* create a thread for each lcore */</span> </span><br><span class="line">ret = pthread_create(&amp;lcore_config[i].thread_id, <span class="literal">NULL</span>, eal_thread_loop, <span class="literal">NULL</span>); </span><br><span class="line"><span class="keyword">if</span> (ret！= <span class="number">0</span>) </span><br><span class="line">rte_panic(<span class="string">"Cannot create thread\n"</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 不同的模块需要调用rte_eal_mp_remote_launch（），将自己的回调处理函数注册到lcore_config[].f中。以l2fwd为例，注册的回调处理函数是l2fwd_launch_on_lcore（）*/</span></span><br><span class="line">rte_eal_mp_remote_launch(l2fwd_launch_one_lcore, <span class="literal">NULL</span>, CALL_MASTER);</span><br></pre></td></tr></table></figure><p>DPDK每个核上的线程最终会调用eal_thread_loop（）&gt;&gt;&gt; l2fwd_launch_on_lcore（），调用到自己实现的处理函数。默认情况下，lcore是与逻辑核一一亲和绑定的。带来性能提升的同时，也牺牲了一定的灵活性和能效。在现网中，往往有流量潮汐现象的发生，在网络流量空闲时，没有必要使用与流量繁忙时相同的核数。于是，EAL pthread和逻辑核之间进而允许打破1：1的绑定关系，使得_lcore_id本身和CPU ID可以不严格一致。EAL定义了长选项“——lcores”来指定lcore的CPU亲和性。对一个特定的lcore ID或者lcore ID组，这个长选项允许为EAL pthread设置CPU集。这个选项以及对应的一组API（rte_thread_set/get_affinity（））为lcore提供了亲和的灵活性。lcore可以亲和到一个CPU或者一个CPU集合，使得在运行时调整具体某个CPU承载lcore成为可能。同时，多个lcore也可能亲和到同一个核，但是这种情况下如果调度占用的内核库是非抢占式，就存在锁机制，DPDK技术栈在电信云中的最佳实践（2）中会专门针对不同锁进制进行讨论。</p><p>除了使用DPDK提供的逻辑核之外，用户也可以将DPDK的执行上下文运行在任何用户自己创建的pthread中。在普通用户自定义的pthread中，lcore id的值总是<strong>LCORE_ID_ANY</strong>，以此确定这个thread是一个有效的普通用户所创建的pthread。用户创建的pthread可以支持绝大多数DPDK库，没有任何影响。但少数DPDK库可能无法完全支持用户自创建的pthread，如timer和Mempool。详细请参见《DPDK开发者手册多线程章节》。</p><p>DPDK不仅可以通过绑核完成大量计算任务资源亲和性调度，同时在计算任务较小，一个核的资源绰绰有余的情况下，还可以通过Linux的cgroup对资源进行释放。因为，DPDK的线程其实就是普通的pthread，其本质就是使用cgroup能把CPU的配额灵活地配置在不同的线程上。因此，DPDK可以借助cgroup实现计算资源配额对于线程的灵活配置，可以有效改善I/O核的闲置利用率。</p><p>最后，用一张图来总结lcore的启动过程和执行任务分发的流程。</p><p><img src="https://i.loli.net/2019/04/27/5cc3eb2155fbf.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文篇幅有限，很难用短短几语就勾勒出DPDK的完整轮廓，概括来说，DPDK是一个技术栈，主要用于Intel架构的服务器领域，其主要目的就是提升x86标准服务器的转发性能。因此，本文只重点介绍DPDK平台部分技术在电信云中的最佳实践。
    
    </summary>
    
      <category term="NFV关键技术" scheme="https://kkutysllb.cn/categories/NFV%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="电信云" scheme="https://kkutysllb.cn/tags/%E7%94%B5%E4%BF%A1%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>2019-04-22-Linux系统命令-第四篇《系统信息显示命令》</title>
    <link href="https://kkutysllb.cn/2019/04/23/2019-04-22-Linux%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4-%E7%AC%AC%E5%9B%9B%E7%AF%87%E3%80%8A%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E6%98%BE%E7%A4%BA%E5%91%BD%E4%BB%A4%E3%80%8B/"/>
    <id>https://kkutysllb.cn/2019/04/23/2019-04-22-Linux系统命令-第四篇《系统信息显示命令》/</id>
    <published>2019-04-22T17:26:35.000Z</published>
    <updated>2019-05-01T16:26:34.304Z</updated>
    
    <content type="html"><![CDATA[<h2 id="uname：显示系统信息"><a href="#uname：显示系统信息" class="headerlink" title="uname：显示系统信息"></a>uname：显示系统信息</h2><p>uname命令用于显示系统相关信息，比如内核版本号、硬件架构等。</p><a id="more"></a><p><strong>语法格式：uname [option]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/04/23/5cbdf9bd527ef.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）显示当前系统所有信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># uname -a</span></span><br><span class="line">Linux C7-Server01 3.10.0-957.10.1.el7.x86_64 <span class="comment">#1 SMP Mon Mar 18 15:06:45 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux</span></span><br></pre></td></tr></table></figure><p><strong>2）显示当前服务器硬件架构</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># uname -m</span></span><br><span class="line">x86_64</span><br></pre></td></tr></table></figure><p><strong>3）显示当前服务器主机名</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># uname -n</span></span><br><span class="line">C7-Server01</span><br></pre></td></tr></table></figure><p><strong>4）显示内核发行版本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># uname -r</span></span><br><span class="line">3.10.0-957.10.1.el7.x86_64</span><br></pre></td></tr></table></figure><p><strong>5）显示当前服务器处理器类型</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># uname -p </span></span><br><span class="line">x86_64</span><br></pre></td></tr></table></figure><p><strong>6）显示当前服务器硬件平台</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># uname -i</span></span><br><span class="line">x86_64</span><br></pre></td></tr></table></figure><h2 id="hostname：显示或设置系统的主机名"><a href="#hostname：显示或设置系统的主机名" class="headerlink" title="hostname：显示或设置系统的主机名"></a>hostname：显示或设置系统的主机名</h2><p>hostname命令用于显示或设置系统的主机名称。许多网络程序均用主机名来标识主机，若没有设置好主机名，则可能会导致网络服务不正常。</p><p><strong>语法格式：hostname [option]</strong></p><p><strong>重要参数选项</strong></p><p><img src="https://i.loli.net/2019/04/23/5cbdfab5f04ae.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）显示主机名</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># hostname</span></span><br><span class="line">C7-Server01</span><br></pre></td></tr></table></figure><p><strong>2）临时修改主机名</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># hostname kkutysllb # 将主机名临时修改为kkutysllb</span></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># hostname</span></span><br><span class="line">kkutysllb</span><br></pre></td></tr></table></figure><p><strong>3）永久修改主机名</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># hostnamectl set-hostname C7-Server01</span></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># hostname</span></span><br><span class="line">c7-server01</span><br></pre></td></tr></table></figure><p>还有修改的方式就是修改/etc/hostname文件的内容：</p><p><img src="https://i.loli.net/2019/04/23/5cbdfb2e0d68d.jpg"></p><p><strong>4）配置主机名的DNS解析</strong></p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 修改/etc/hosts文件，在其后追加如下配置</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; [root@C7-Server01 kkutysllb]<span class="comment"># echo "</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; &gt; 192.168.101.81 C7-Server01</span><br><span class="line">&gt; &gt; <span class="string">" &gt;&gt; /etc/hosts</span></span><br><span class="line"><span class="string">&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="stat：显示文件或文件系统状态"><a href="#stat：显示文件或文件系统状态" class="headerlink" title="stat：显示文件或文件系统状态"></a>stat：显示文件或文件系统状态</h2><p>stat命令用于详细显示文件或文件系统的状态信息。</p><p><strong>语法格式：stat [option] [file]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/04/23/5cbdfb79eb494.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）查看文件的属性信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># stat /etc/hosts</span></span><br><span class="line">File: ‘/etc/hosts’</span><br><span class="line">Size: 187       Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: 803h/2051dInode: 33589107    Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2019-04-22 22:56:50.071492174 +0800</span><br><span class="line">Modify: 2019-04-22 22:56:43.218501936 +0800</span><br><span class="line">Change: 2019-04-22 22:56:43.218501936 +0800</span><br><span class="line">Birth: -</span><br></pre></td></tr></table></figure><blockquote><p><strong>输出各项解释如下：</strong></p><p>size：文件大小</p><p>Blocks：占用block的数量</p><p>IO Blocks：Block总大小为4096（8*512）</p><p>regular file：文件类型为普通文件</p><p>Device：设备编号的16进制和10进制</p><p>Inode：文件的inode值</p><p>Links：文件的硬链接数</p><p>Access：（0644/-rw-r–r–）：文件权限</p><p>Uid：文件归属用户</p><p>Gid：文件归属用户组</p><p>Access：文件的访问时间</p><p>Modify：文件的修改时间</p><p>Change：文件状态改变时间</p></blockquote><p><strong>2） 查看文件系统属性</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看/etc/hosts文件所在分区的文件系统属性</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># stat -f /etc/hosts</span></span><br><span class="line">File: <span class="string">"/etc/hosts"</span></span><br><span class="line">ID: 80300000000 Namelen: 255     Type: xfs</span><br><span class="line">Block size: 4096       Fundamental block size: 4096</span><br><span class="line">Blocks: Total: 10902067   Free: 10223852   Available: 10223852</span><br><span class="line">Inodes: Total: 21814784   Free: 21699625</span><br></pre></td></tr></table></figure><blockquote><p>显示/etc/hosts文件所在分区的文件系统类型为xfs，Blocks和Inodes的占用情况</p></blockquote><p><strong>3）使用指定格式输出文件内容</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># stat -c %a /etc/hosts # %a显示文件的10进制格式权限</span></span><br><span class="line">644</span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># stat -c %A /etc/hosts # %A显示文件的可读格式权限</span></span><br><span class="line">-rw-r--r--</span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># stat -c %o /etc/hosts # %o显示文件IO块数量</span></span><br><span class="line">4096</span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># stat -c %n /etc/hosts # %n显示文件名</span></span><br><span class="line">/etc/hosts</span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># stat -c %i /etc/hosts # %i显示文件的inode值</span></span><br><span class="line">33589107</span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># stat -c %b /etc/hosts # %b显示文件占用的block块数量</span></span><br><span class="line">8</span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># stat -c %B /etc/hosts # %B显示文件占用的block块单位大小</span></span><br><span class="line">512</span><br></pre></td></tr></table></figure><h2 id="du：统计磁盘空间使用情"><a href="#du：统计磁盘空间使用情" class="headerlink" title="du：统计磁盘空间使用情"></a>du：统计磁盘空间使用情</h2><p>du命令可以用于统计磁盘空间的使用情况，这个命令有助于我们找出哪个文件过多地占用了磁盘空间。</p><p><strong>语法格式：du [option] [file]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/04/23/5cbdfc34702cb.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）通过参数-a显示所有当前目录或文件所占空间</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># du -a</span></span><br><span class="line">4./.bash_logout</span><br><span class="line">4./.bash_profile</span><br><span class="line">4./.bashrc</span><br><span class="line">4./.bash_history</span><br><span class="line">0./mytest</span><br><span class="line">0./data/stu01</span><br><span class="line">0./data/stu02/test01</span><br><span class="line">0./data/stu02/test02</span><br><span class="line">0./data/stu02/test03</span><br><span class="line">0./data/stu02/test04</span><br><span class="line">0./data/stu02</span><br><span class="line">0./data/stu03/test01</span><br><span class="line">0./data/stu03/test02</span><br><span class="line">0./data/stu03/test03</span><br><span class="line">0./data/stu03/test04</span><br><span class="line">0./data/stu03</span><br><span class="line">0./data</span><br><span class="line">0./image008</span><br><span class="line">0./image009</span><br><span class="line">0./202012312234.55</span><br><span class="line">0./image010</span><br><span class="line">0./data_tmp/stu01</span><br><span class="line">0./data_tmp/stu02/test01</span><br><span class="line">0./data_tmp/stu02/test02</span><br><span class="line">0./data_tmp/stu02/test03</span><br><span class="line">0./data_tmp/stu02/test04</span><br><span class="line">0./data_tmp/stu02</span><br><span class="line">0./data_tmp/stu03/test01</span><br><span class="line">0./data_tmp/stu03/test02</span><br><span class="line">0./data_tmp/stu03/test03</span><br><span class="line">0./data_tmp/stu03/test04</span><br><span class="line">0./data_tmp/stu03</span><br><span class="line">0./data_tmp</span><br><span class="line">4./hard_link</span><br><span class="line">0./soft_link</span><br><span class="line">4./data001</span><br><span class="line">4./data002</span><br><span class="line">4./test.sh</span><br><span class="line">4./data003</span><br><span class="line">4./data004</span><br><span class="line">4./test01.sh</span><br><span class="line">0./test01</span><br><span class="line">4./data005</span><br><span class="line">52.</span><br></pre></td></tr></table></figure><p>上面占用大小单位的K字节。</p><p><strong>2）显示当前目录的总大小</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># du -s</span></span><br><span class="line">52.</span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># du -sh</span></span><br><span class="line">52K.</span><br></pre></td></tr></table></figure><p><strong>3）显示指定层次的目录大小</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># du -h --max-depth=1 /usr/local</span></span><br><span class="line">0/usr/<span class="built_in">local</span>/bin</span><br><span class="line">0/usr/<span class="built_in">local</span>/etc</span><br><span class="line">0/usr/<span class="built_in">local</span>/games</span><br><span class="line">0/usr/<span class="built_in">local</span>/include</span><br><span class="line">0/usr/<span class="built_in">local</span>/lib</span><br><span class="line">0/usr/<span class="built_in">local</span>/lib64</span><br><span class="line">0/usr/<span class="built_in">local</span>/libexec</span><br><span class="line">0/usr/<span class="built_in">local</span>/sbin</span><br><span class="line">0/usr/<span class="built_in">local</span>/share</span><br><span class="line">0/usr/<span class="built_in">local</span>/src</span><br><span class="line">182M/usr/<span class="built_in">local</span>/python3</span><br><span class="line">182M/usr/<span class="built_in">local</span></span><br></pre></td></tr></table></figure><p><strong>4）显示/usr/local下的第一和第二层子目录大小，但是不含python3</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># du -h --max-depth=2 --exclude=/usr/local/python3 /usr/local</span></span><br><span class="line">0/usr/<span class="built_in">local</span>/bin</span><br><span class="line">0/usr/<span class="built_in">local</span>/etc</span><br><span class="line">0/usr/<span class="built_in">local</span>/games</span><br><span class="line">0/usr/<span class="built_in">local</span>/include</span><br><span class="line">0/usr/<span class="built_in">local</span>/lib</span><br><span class="line">0/usr/<span class="built_in">local</span>/lib64</span><br><span class="line">0/usr/<span class="built_in">local</span>/libexec</span><br><span class="line">0/usr/<span class="built_in">local</span>/sbin</span><br><span class="line">0/usr/<span class="built_in">local</span>/share/applications</span><br><span class="line">0/usr/<span class="built_in">local</span>/share/info</span><br><span class="line">0/usr/<span class="built_in">local</span>/share/man</span><br><span class="line">0/usr/<span class="built_in">local</span>/share</span><br><span class="line">0/usr/<span class="built_in">local</span>/src</span><br><span class="line">0/usr/<span class="built_in">local</span></span><br></pre></td></tr></table></figure><h2 id="date：显示与设置系统时间"><a href="#date：显示与设置系统时间" class="headerlink" title="date：显示与设置系统时间"></a>date：显示与设置系统时间</h2><p>date命令用于显示当前的系统时间或设置系统时间。</p><p><strong>语法格式：date [option] [+FORMAT]</strong></p><p><strong>重要参数选项</strong></p><p><img src="https://i.loli.net/2019/04/23/5cbdfce06fb77.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）常用时间格式测试</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># date +%y  # 显示年份（短格式）</span></span><br><span class="line">19</span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># date +%Y  # 显示年份（长格式）</span></span><br><span class="line">2019</span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># date +%m  # 显示月份</span></span><br><span class="line">04</span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># date +%d  # 显示日期</span></span><br><span class="line">22</span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># date +%H  # 显示小时</span></span><br><span class="line">23</span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># date +%M # 显示分</span></span><br><span class="line">44</span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># date +%S # 显示秒</span></span><br><span class="line">52</span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># date +%F # 显示标准日期格式（年-月-日）</span></span><br><span class="line">2019-04-22</span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># date +%T # 显示标准时间格式（时:分:秒）</span></span><br><span class="line">23:45:02</span><br></pre></td></tr></table></figure><p><strong>2）通过参数-d显示指定字符串所描述的时间示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># date +%F -d '-1day'  # 显示昨天</span></span><br><span class="line">2019-04-21</span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># date +%F -d '+1day'  # 显示明天</span></span><br><span class="line">2019-04-23</span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># date +%F -d '1month' # 显示1个月后</span></span><br><span class="line">2019-05-22</span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># date +%F -d '1year'  # 显示1年后</span></span><br><span class="line">2020-04-22</span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># date +%F -d '24hour' # 显示24小时后</span></span><br><span class="line">2019-04-23</span><br></pre></td></tr></table></figure><p><strong>3）时间格式转换</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># date -d "Thu Jul 6 21:41:16 CST 2017" "+%Y-%m-%d %H:%M:%S"</span></span><br><span class="line">2017-07-06 21:41:16</span><br></pre></td></tr></table></figure><p>-d选项后面接上需要转化的时间，最后再接上你想要输出的时间格式。</p><p><strong>4）设置系统时间</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># date -s "Mon Apr 22 23:56:53 CST 2019"</span></span><br><span class="line">Mon Apr 22 23:56:53 CST 2019</span><br></pre></td></tr></table></figure><h2 id="whereis：显示命令及其相关文件全路径"><a href="#whereis：显示命令及其相关文件全路径" class="headerlink" title="whereis：显示命令及其相关文件全路径"></a>whereis：显示命令及其相关文件全路径</h2><p>whereis命令用于定位指定命令的可执行文件、源码文件及man帮助文件的路径。whereis命令用于在PATH环境变量里查找指定的命令。</p><p><strong>语法格式：whereis [option] [filename]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/04/23/5cbdfda6117a3.jpg"></p><p><strong>【使用范例】</strong></p><p><strong>1）将与python相关的文件都查找出来</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># whereis python</span></span><br><span class="line">python: /usr/bin/python /usr/bin/python2.7 /usr/bin/python2.7-config /usr/bin/python.bak /usr/lib/python2.7 /usr/lib64/python2.7 /etc/python /usr/include/python2.7 /usr/share/man/man1/python.1.gz</span><br></pre></td></tr></table></figure><p><strong>2）只查找python相关的可执行文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># whereis -b python</span></span><br><span class="line">python: /usr/bin/python /usr/bin/python2.7 /usr/bin/python2.7-config /usr/bin/python.bak /usr/lib/python2.7 /usr/lib64/python2.7 /etc/python /usr/include/python2.7</span><br></pre></td></tr></table></figure><p><strong>3）查找python的man帮助文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># whereis -m python</span></span><br><span class="line">python: /usr/share/man/man1/python.1.gz</span><br></pre></td></tr></table></figure><p><strong>4）查找python的源代码文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># whereis -s python</span></span><br><span class="line">python:      <span class="comment"># 为空表示没有找到</span></span><br></pre></td></tr></table></figure><p><strong>如果只是想查找命令的全路径，Linux中还有个which命令更常用，请大家自行研究。</strong></p><h2 id="who：显示已登录用户信息"><a href="#who：显示已登录用户信息" class="headerlink" title="who：显示已登录用户信息"></a>who：显示已登录用户信息</h2><p>who命令能够显示已经登录系统的用户，以及系统的启动时间等信息。</p><p><strong>语法格式：who [option]</strong> </p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/04/23/5cbdfe30e11de.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）显示已登录用户信息的不同参数实践例子</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># who</span></span><br><span class="line">root     pts/0        2019-04-22 22:53 (192.168.101.1)</span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># who -b</span></span><br><span class="line">         system boot  2019-04-22 22:53</span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># who -l</span></span><br><span class="line">LOGIN    tty1         2019-04-22 22:53              9468 id=tty1</span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># who -H</span></span><br><span class="line">NAME     LINE         TIME             COMMENT</span><br><span class="line">root     pts/0        2019-04-22 22:53 (192.168.101.1)</span><br></pre></td></tr></table></figure><p><strong>2）显示最全的登录用户的信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># who -H -a</span></span><br><span class="line">NAME       LINE         TIME             IDLE          PID COMMENT  EXIT</span><br><span class="line">system boot  2019-04-22 22:53</span><br><span class="line">LOGIN      tty1         2019-04-23 00:17             10515 id=tty1</span><br><span class="line">run-level 3  2019-04-22 22:53</span><br><span class="line">root     + pts/0        2019-04-22 22:53   .         10337 (192.168.101.1)</span><br></pre></td></tr></table></figure><h2 id="df：报告文件系统磁盘空间的使用情况"><a href="#df：报告文件系统磁盘空间的使用情况" class="headerlink" title="df：报告文件系统磁盘空间的使用情况"></a>df：报告文件系统磁盘空间的使用情况</h2><p>显示文件系统磁盘空间的使用情况。如果不指定命令后面的文件参数，则会显示所有磁盘分区的使用情况，如果给定文件，则显示此文件所在磁盘分区的使用情况。</p><p><strong>语法格式：df [option] [file]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/04/23/5cbdfe8d5b4ef.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）显示磁盘的使用情况</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># df</span></span><br><span class="line">Filesystem     1K-blocks    Used Available Use% Mounted on</span><br><span class="line">/dev/sda3       43608268 2712880  40895388   7% /</span><br><span class="line">devtmpfs         3984384       0   3984384   0% /dev</span><br><span class="line">tmpfs            3995140       0   3995140   0% /dev/shm</span><br><span class="line">tmpfs            3995140   11920   3983220   1% /run</span><br><span class="line">tmpfs            3995140       0   3995140   0% /sys/fs/cgroup</span><br><span class="line">/dev/sda1         406180  164980    241200  41% /boot</span><br><span class="line">tmpfs             799032       0    799032   0% /run/user/0</span><br></pre></td></tr></table></figure><p><strong>2）以人类可读的方式显示磁盘的使用情况</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># df -h</span></span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/sda3        42G  2.6G   40G   7% /</span><br><span class="line">devtmpfs        3.8G     0  3.8G   0% /dev</span><br><span class="line">tmpfs           3.9G     0  3.9G   0% /dev/shm</span><br><span class="line">tmpfs           3.9G   12M  3.8G   1% /run</span><br><span class="line">tmpfs           3.9G     0  3.9G   0% /sys/fs/cgroup</span><br><span class="line">/dev/sda1       397M  162M  236M  41% /boot</span><br><span class="line">tmpfs           781M     0  781M   0% /run/user/0</span><br></pre></td></tr></table></figure><p><strong>3）显示磁盘inode的使用情况</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># df -hi</span></span><br><span class="line">Filesystem     Inodes IUsed IFree IUse% Mounted on</span><br><span class="line">/dev/sda3         21M  113K   21M    1% /</span><br><span class="line">devtmpfs         973K   399  973K    1% /dev</span><br><span class="line">tmpfs            976K     1  976K    1% /dev/shm</span><br><span class="line">tmpfs            976K  1.3K  975K    1% /run</span><br><span class="line">tmpfs            976K    16  976K    1% /sys/fs/cgroup</span><br><span class="line">/dev/sda1        200K   335  200K    1% /boot</span><br><span class="line">tmpfs            976K     1  976K    1% /run/user/0</span><br></pre></td></tr></table></figure><p><strong>4）显示指定文件系统类型的磁盘</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># df -t xfs</span></span><br><span class="line">Filesystem     1K-blocks    Used Available Use% Mounted on</span><br><span class="line">/dev/sda3       43608268 2712880  40895388   7% /</span><br><span class="line">/dev/sda1         406180  164980    241200  41% /boot</span><br></pre></td></tr></table></figure><p><strong>5）列出系统文件系统的类型</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># df -T</span></span><br><span class="line">Filesystem     Type     1K-blocks    Used Available Use% Mounted on</span><br><span class="line">/dev/sda3      xfs       43608268 2712880  40895388   7% /</span><br><span class="line">devtmpfs       devtmpfs   3984384       0   3984384   0% /dev</span><br><span class="line">tmpfs          tmpfs      3995140       0   3995140   0% /dev/shm</span><br><span class="line">tmpfs          tmpfs      3995140   11920   3983220   1% /run</span><br><span class="line">tmpfs          tmpfs      3995140       0   3995140   0% /sys/fs/cgroup</span><br><span class="line">/dev/sda1      xfs         406180  164980    241200  41% /boot</span><br><span class="line">tmpfs          tmpfs       799032       0    799032   0% /run/user/0</span><br></pre></td></tr></table></figure><h2 id="top：实时显示系统中各个进程的资源占用状况"><a href="#top：实时显示系统中各个进程的资源占用状况" class="headerlink" title="top：实时显示系统中各个进程的资源占用状况"></a>top：实时显示系统中各个进程的资源占用状况</h2><p>top命令用于实时地对系统处理器状态进行监控，它能够实时地显示系统中各个进程的资源占用状况。该命令可以按照CPU的使用、内存的使用和执行时间对系统任务进程进行排序显示，同时top命令还可以通过交互式命令进行设定显示。</p><p><strong>语法格式：top [option]</strong> </p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/04/23/5cbdff3acfa93.jpg"></p><p><strong>交互式命令</strong></p><p><img src="https://i.loli.net/2019/04/23/5cbdff5120ed0.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）显示进程信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># top</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/23/5cbdff7cf2b6f.jpg"></p><p><strong>2）显示多核不同核CPU的信息</strong></p><p>在top基本视图中，按键盘数字“1”，可监控每个逻辑CPU的状况。</p><p><img src="https://i.loli.net/2019/04/23/5cbdff98d370f.jpg"></p><p>图中显示系统有4个逻辑CPU</p><p><strong>3）将进程按照批处理方式排序</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># top -b</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/23/5cbdffbe6c20e.jpg"></p><p><strong>4）显示进程的完整路径</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># top -c</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/23/5cbdffe1249f1.jpg"></p><p><strong>5）显示指定的进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># top -p 10560</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/23/5cbe00050f146.jpg"></p><p><strong>6）交互式例子</strong></p><p>默认进入top命令模式，各进程是按照CPU的使用量来排序的</p><p><img src="https://i.loli.net/2019/04/23/5cbe001e5012b.jpg"></p><p><strong>场景1：敲击键盘“b”和“x”</strong></p><p><img src="https://i.loli.net/2019/04/23/5cbe0037df9ac.jpg"></p><p><strong>场景2：敲击键盘“z”和“x”</strong></p><p><img src="https://i.loli.net/2019/04/23/5cbe004f82cd8.jpg"></p><p><strong>场景3：通过“&gt;”或“&lt;”可以向右或向左改变排序列</strong></p><p>敲击”&gt;”变为按内存排序</p><p><img src="https://i.loli.net/2019/04/23/5cbe0069b3a50.jpg"></p><p>一致敲击“&lt;”变为按PID排序</p><p><img src="https://i.loli.net/2019/04/23/5cbe0081da49d.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;uname：显示系统信息&quot;&gt;&lt;a href=&quot;#uname：显示系统信息&quot; class=&quot;headerlink&quot; title=&quot;uname：显示系统信息&quot;&gt;&lt;/a&gt;uname：显示系统信息&lt;/h2&gt;&lt;p&gt;uname命令用于显示系统相关信息，比如内核版本号、硬件架构等。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux核心命令" scheme="https://kkutysllb.cn/categories/Linux%E6%A0%B8%E5%BF%83%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Linux" scheme="https://kkutysllb.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>2019-04-21-x86架构基础</title>
    <link href="https://kkutysllb.cn/2019/04/21/2019-04-21-x86%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80/"/>
    <id>https://kkutysllb.cn/2019/04/21/2019-04-21-x86架构基础/</id>
    <published>2019-04-21T08:10:21.000Z</published>
    <updated>2019-04-27T17:16:47.726Z</updated>
    
    <content type="html"><![CDATA[<p>标准服务器技术是网络功能虚拟化（NFV）实现的一个关键因素，了解一些x86架构的基础知识对大家后续了解电信云关键技术，尤其是掌握虚拟化技术原理和关键优化方案是必须具备的。本文主要从x86架构的CPU指令集增强，内存管理、中断和异常、IO架构等部分进行阐述，以及包含一些基础IT的基本概念的讲解。<a id="more"></a></p><h2 id="x86-64指令集的增强"><a href="#x86-64指令集的增强" class="headerlink" title="x86-64指令集的增强"></a>x86-64指令集的增强</h2><p>Intel 的x86体系结构是世界上最流行的处理器架构，从1978年8086/8088处理器问世到现在的Core i7和Core i9，以及Xeon系列处理器，Intel x86体系结构已经在CPU领域叱咤40多年。</p><p>x86-64是x86架构的延伸产品，是一种64位微处理器架构及其相应的指令集。在x86-64出现以前，Intel与惠普联合推出IA-64架构，此架构不与x86兼容，且市场反应冷淡。于是，与x86兼容的x86-64架构应运而生。1999年，AMD 首次公开64位指令集为IA-32 提供扩展，称为x86-64（后来改名为AMD64）。此架构后来也为Intel 所采用，也就是现在的Intel 64。</p><p>x86-64能有效地把x86架构移植到64位环境，并且兼容原有的x86应用程序，市场前景广阔。外界使用x84-64或者x64称呼这个64位架构，以保持中立，不偏袒任何一家厂商。</p><blockquote><p>AMD 64指令集主要特点有：<strong>支持64 位通用寄存器、64 位整数及逻辑运算</strong>和<strong>64 位虚拟地址</strong>。</p><p>Intel 64架构加入了额外的寄存器和其他改良的指令集，可使<strong>处理器直接访问超过4GB的内存</strong>，允许运行更大的应用程序。通过64位的存储器地址上限，其理论存储器容量上限达16EB，目前大多数操作系统和应用程序已基本支持完整的64位地址。</p></blockquote><h2 id="x86的内存架构"><a href="#x86的内存架构" class="headerlink" title="x86的内存架构"></a>x86的内存架构</h2><p>硬件架构中最复杂、最核心的部分就是其内存架构。此部分详细内容因为篇幅有限无法详细展开，面向的人员主要包括CPU架构设计、操作系统开发和内核底层优化等领域，至于运维方面后期如果不做内核优化的同事了解即可，如感兴趣可参考《手把手教你设计CPU-RISC-V处理器》、《嵌入式操作系统原理》和《处理器虚拟化技术》等书籍。</p><h3 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h3><p>地址空间是所有可用资源的集合，我们姑且将它看做一个大大的数组，那么地址就是这个数组的索引。地址空间可以划分为物理地址空间和线性地址空间两大类。</p><p><strong>（1）物理地址空间</strong></p><p>硬件平台通常划分为CPU、内存和其他硬件设备三个部分。其中，CPU 是整个硬件平台的主导者，内存和其他硬件设备都是CPU 可以使用的资源。这些资源组合在一起，分布在CPU的物理地址空间内，CPU使用物理地址索引这些资源。<strong>物理地址空间的大小由CPU实现的物理地址位数所决定</strong>，物理地址位数由CPU经过MMU（Memory Management Unit，内存管理单元）转换后的外地址总线位数决定。<strong>外地址总线位数与CPU处理数据的能力（即CPU 位数）没有必然的联系</strong>，例如：16位的8086 CPU具有20位地址空间。</p><p>一个硬件平台只有一个物理地址空间，但每个程序都认为自己独享整个平台的硬件资源。为了让多个程序能够有效地相互隔离，也为了它们能够有效地使用物理地址空间的资源，引入了线性地址空间的概念。</p><p><strong>（2）线性地址空间</strong></p><p><strong>线性地址空间的大小由CPU实现的线性地址位数决定</strong>，线性地址位数由CPU的内地址总线位数决定。由于CPU的内地址总线与CPU的执行单元直连，所以，内地址总线位数往往与CPU位数一致，如果是32 位处理器，那么它就实现了32 位线性地址，其线性地址空间为4GB，如果是64位处理器，那么它的线性地址空间的为2的64次方，即16384GB。需要注意的是，<strong>线性地址空间的大小与物理地址空间的大小没有必然联系</strong>，Intel的PAE平台具有4GB 的线性地址空间，而其物理地址空间为64GB。但是，线性地址空间会被映射到某一部分物理地址空间或整个物理地址空间。也就是说，线性地址空间小于等于物理地址空间。</p><p>CPU负责将线性地址空间转换成物理地址空间，保证程序能够正确访问到该线性地址空间所映射到的物理地址空间。在现代操作系统中，每个进程通常都拥有自己的私有线性地址空间。一个典型的线性地址空间构造如下图所示。</p><p><img src="https://i.loli.net/2019/04/21/5cbc261553723.jpg"></p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p>地址是访问地址空间的索引。根据访问地址空间的不同，索引可以分为<strong>物理地址</strong>和<strong>线性地址</strong>。但由于x86特殊的段机制，还存在一种额外的地址—<strong>逻辑地址</strong>。</p><p><strong>（1）逻辑地址</strong></p><p>逻辑地址是程序直接使用的地址（x86无法禁用段机制，逻辑地址一直存在）。逻辑地址由一个16位的段选择符和一个32位的偏移量（32位平台）构成。下面以具体程序为例进行解释。比如：我们写下面一段c语言代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>;   # 定义一个整型变量a</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;   # 定义一个整型指针p，指向变量a在内存中的地址</span><br></pre></td></tr></table></figure><p>上述语句中的指针变量p存储的就是变量a的逻辑地址。实际上，p中存储的仅是逻辑地址的<strong>偏移部分</strong>，而偏移对应的<strong>段选择符位于段寄存器中</strong>，并没有在程序中显示。</p><p><strong>（2）线性地址</strong></p><p>线性地址又称虚拟地址。线性地址是逻辑地址转换后的结果，用于索引线性地址空间。当CPU使用分页机制时，还需要将线性地址转换成物理地址才能访问物理平台内存或其他硬件设备；<strong>当分页机制未启用时，线性地址与物理地址相同</strong>。</p><p><strong>（3）物理地址</strong></p><p>物理地址是物理地址空间的索引，是CPU提交到总线用于访问物理平台内存或其他硬件设备的最终地址，在x86下，物理地址有时也被称为总线地址。</p><p>根据上面的描述，我们可以总结如下：</p><ul><li><strong>分段机制启用，分页机制未启用：逻辑地址—&gt;线性地址=物理地址</strong></li><li><strong>分段机制、分页机制同时启用：逻辑地址—&gt;线性地址—&gt;物理地址</strong></li></ul><h3 id="x86内存管理机制"><a href="#x86内存管理机制" class="headerlink" title="x86内存管理机制"></a>x86内存管理机制</h3><p>x86架构的内存管理机制分为两部分：分段机制和分页机制。分段机制为程序提供彼此隔离的代码区域、数据区域、栈区域，从而避免了同一个处理器上运行的多个程序互相影响。</p><p>分页机制实现了传统的按需分页、虚拟内存机制，可以将程序的执行环境按需映射到物理内存。此外，分页机制还可以用于提供多任务的隔离。</p><p>分段机制和分页机制都可以通过配置，支持简单的单任务系统、多任务系统或共享内存的多处理器系统。<strong>需要强调的一点是，处理器无论在何种运行模式下都不可以禁止分段机制，但是分页机制却是可选选项。</strong></p><p><strong>（1）分段机制</strong></p><p>分段机制是x86架构下的朴素内存管理机制，不可以禁用。了解分段机制有利于对后续内存虚拟化原理和优化方案有更深的了解。</p><p>分段机制将内存划分成以基地址（Base）和长度（Limit）描述的块。段可以与程序最基本的元素联系起来，程序可以简单地划分为代码、数据和栈，段机制就有相应的代码段、数据段和栈段。</p><p>一个程序根据分段机制在内存中由<strong>逻辑地址</strong>、<strong>段选择符</strong>、<strong>段描述符</strong>和<strong>段描述符表</strong>4 个基本部分构成。</p><blockquote><p>1）当程序使用逻辑地址访问内存的某个部分时，CPU通过逻辑地址中的段选择符索引段描述符表，进而得到该内存对应的段描述符（段描述符描述段的基地址、长度以及读/写、访问权限等属性信息）</p><p>2）根据段描述符中的段属性信息检测程序的访问是否合法，如果合法，再根据段描述符中的基地址将逻辑地址转换为线性地址。</p></blockquote><p>这个流程可以用如下图示进行总结。</p><p><img src="https://i.loli.net/2019/04/21/5cbc267c60250.jpg"></p><p>段选择符是逻辑地址的一个组成部分，用于索引段描述符表以获得该段对应的段描述符。段选择符作为逻辑地址的一部分，对应用程序是可见的。但是，正如前面在逻辑地址中介绍的，应用程序中只存储和使用逻辑地址的偏移部分，段选择符的修改和分配由连接器和加载器完成。</p><p>为了使CPU能够快速地获得段选择符，x86架构提供了6个段寄存器存放当前程序中各个段的<strong>段选择符</strong>。这6 个段寄存器分别如下：</p><ul><li>CS（Code-Segment，代码段）：存放代码段的段选择符。</li><li>DS（Data-Segment，数据段）：存放数据段的段选择符。</li><li>SS（Stack-Segment，栈段）：存放栈的段选择符。</li><li>ES、FS、GS：可以存放额外三个数据段的段选择符，由程序自由使用。</li></ul><p>由于段选择符的存在最终是为了索引段描述符表中的段描述符，为了加速段描述符的访问，x86架构在不同的段寄存器后增加了一个程序不可见的<strong>段描述符寄存器</strong>。当相应段寄存器中加入一个新的段选择符后，CPU自动将该段选择符索引的段描述符加载到这个不可见的段描述符寄存器中。各个段寄存器的构造如下。</p><p><img src="https://i.loli.net/2019/04/21/5cbc26ab49407.jpg"></p><p>段描述符描述某个段的<strong>基地址</strong>、<strong>长度</strong>以及<strong>各种属性</strong>（例如，读/写属性、访问权限等）。这是分段机制的核心思想。当CPU通过一个逻辑地址的段选择符获得该段对应的段描述符后，会使用段描述符中各种属性字段对访问进行检查，一旦确认访问合法，CPU将段描述符中的基地址和程序中逻辑地址的偏移量相加就得到程序的线性地址。</p><p>正如前面讲到的，x86架构在每个段寄存器后增加了一个程序不可见的段描述符寄存器，每当段寄存器加入一个新的段选择符后，CPU自动将该段选择符索引的段描述符加载到这个段描述符寄存器中。后续只要不发生段寄存器的更新操作，CPU就不再查询段描述符表而是直接使用这个段描述符寄存器中的值，从而加快CPU的执行效率。</p><p>x86架构提供了两种段描述符表：<strong>GDT（全局段描述符表Global Descriptor Table）</strong>和<strong>LDT（本地段描述符表Local Descriptor Table）</strong>。具体选择哪个段描述符表，由段选择符中的TI字段决定，当TI=0时，索引GDT，当TI=1时索引LDT。系统中至少有一个GDT可以被所有的进程访问。与此同时，系统中可以有一个或多个LDT，可以被某个进程私有，也可以被多个进程共享。</p><blockquote><p><strong>GDT是内存中的一个数据结构</strong>。简单地讲，可以将GDT看成是一个数组，由基地址（Base）和长度（Limit）描述。</p><p><strong>LDT是一个段</strong>，需要用一个段描述符来描述。LDT的段描述符存放在GDT中，当系统中有多个LDT时，GDT中必须有对应数量的段描述符。</p></blockquote><p>为了加速对GDT和LDT的访问，x86架构提供了GDTR寄存器和LDTR寄存器。关于这两种寄存器的具体描述如下：</p><blockquote><p><strong>GDTR：</strong>包括一个32位的基地址（Base）和一个16 位的长度（Limit）。</p><p><strong>LDTR：</strong>结构与段寄存器相同（同样包含对程序不可见的段描述符寄存器）。</p></blockquote><p>通过段选择符索引GDT/LDT的过程如下图所示：</p><p><img src="https://i.loli.net/2019/04/21/5cbc26ed91ea5.jpg"></p><p><strong>x86架构内存管理中分段机制总结：</strong></p><p>1）在程序加载阶段，该进程LDT的段选择符首先索引GDT，获得LDT的段描述符并将其加载到LDTR寄存器中。此外，该进程的CS、DS、SS中加入相应的段选择符，CPU根据段选择符的TI字段索引相应的段描述符表，获得相应的段描述符，并加载入CS、DS、SS对应的程序不可见的段描述符寄存器。</p><p>2）程序执行到读/写内存中的数据时，把程序中相应变量的逻辑地址转换为线性地址：</p><ul><li>进行必要的属性、访问权限检查；</li><li>从DS对应的段描述符寄存器获得该段的基地址；</li><li>将变量的32位偏移量和段描述符中的基地址相加，获得该变量的线性地址。</li></ul><p><strong>2）分页机制</strong></p><p>分段机制的目的是将内存中的线性地址空间划分成以基地址和长度描述的多个段进行管理，程序对应的逻辑地址以基地址和偏移量来描述，实现逻辑地址到线性地址空间的映射。而分页机制是使用单位“页”来管理线性地址空间和物理地址空间的映射关系。同时，分页机制允许一个页面存放在物理内存中或磁盘的交换区域（如Linux下的Swap分区，Windows下的虚拟内存文件）中，程序可以使用比</p><p>机器物理内存更大的内存区域，从而实现现代操作系统中虚拟内存机制。<strong>（注意：操作系统的虚拟内存原理和映射关系和后面要讲的计算虚拟化技术中内存虚拟化技术基本一致，只是VMM实现时又多了一层嵌套）。</strong></p><p>在x86架构下，页的典型大小为4KB，于是一个4GB的线性地址空间被划分成1024×1024个页面，参见本文线性地址空间示意图。物理地址空间的划分与此类似。x86架构允许大于4KB的页面大小（如2MB、4MB、1GB）等。</p><p>分页机制的核心思想是通过页表将线性地址转换为物理地址，并配合旁路转换缓冲区（Translation Lookaside Buffer，后面简称为TLB）来加速地址转换的过程。分页机制主要由<strong>页表</strong>、<strong>CR3 寄存器</strong>和<strong>TLB</strong>三个部件构成，如下图所示。</p><p><img src="https://i.loli.net/2019/04/21/5cbc271d94801.jpg"></p><p>页表是用于将线性地址转换成物理地址的主要数据结构。一个地址对齐到页边界后的值称为页帧号（或者页框架），它实际上就是该地址所在页面的基地址。比如：一个页大小为4kB，那么第一个页帧号就是0，第二个页帧号就是4097，依次类推。线性地址对应的页帧号叫做虚拟页帧号（Virtual Frame Number，下面简称为VFN），物理地址对应的页帧号叫做物理页帧号（Physical Frame Number，下面简称为PFN）或机器页帧号。<strong>页表实际上是存储VFN到PFN映射的数据结构。</strong></p><p>在传统的32位的保护模式中（未启用物理地址扩展PAE功能），x86处理器使用两级转换方案，在这种方案中，CR3寄存器指向一个4KB大小的页目录表，页目录中共有1024个记录，每一项记录大小4B空间，都指向一个4KB大小的页表，页表中也有1024项，每项大小4B空间，所以，最后整个线性地址空间大小就是1024 个长为4KB的页，即总共4GB大小的空间。未启用PAE 的4KB大小的页面如下图所示。</p><p><img src="https://i.loli.net/2019/04/21/5cbc2739116af.jpg"></p><p><strong>页目录项（Page Directory Entry，下面简称为PDE）</strong>，包含页表的物理地地址，PDE存放在页目录表中。</p><p><strong>页表项（Page Table Entry，下面简称为PTE）</strong>：包含该线性地址对应的物理页帧号PFN，PTE存在页表中，确定物理页帧号PFN 后，再将线性地址的0~11位偏移量与其相加，就可以确定该线性地址对应的物理地址。</p><blockquote><p><strong>虚拟内存实现的关键在于PDE和PTE都包含一个P（Present）字段：</strong></p><p><strong>当P=1时</strong>，物理页面存在于物理内存中，CPU完成地址转换后可以直接访问该页面。</p><p><strong>当P=0时</strong>，物理页面不在物理内存中（在硬盘的交换分区中），当CPU访问该页面时，会产生一个<strong>缺页错误中断</strong>，由操作系统的缺页处理机制将存放在硬盘上的页面调入物理内存，使访问可以继续。同时，由于程序的局部性特点，操作系统会将该页面附近的页面一起调入物理内存，方便CPU的访问。所以，为了减少内存占用，要求程序开发人员尽量少的使用全局索引或递归调用等机制。</p><p>P=0时的PDE和PTE的1~31位都将为操作系统提供物理页面在硬盘上的信息，这些位存储着物理页面在硬盘上的位置。</p></blockquote><p>启用物理地址扩展（之后简称为PAE）后，页表结构将发生相应的变化。页表和页目录的总大小仍是4KB，但页表和页目录中的表项都从32位扩为64位，以使用附加的地址位。这样，页表和页目录都只有512个表项，变成了原来方案的一半，所以又加入了一个级：<strong>CR3 指向页目录指针表</strong>，即一个包含4个页目录指针的表。启用PAE 的4KB大小的页面使用的三级页表如下图所示：</p><p><img src="https://i.loli.net/2019/04/21/5cbc277ea692a.jpg"></p><p>CR3寄存器也称为<strong>页目录基地址寄存器</strong>（Page-Directory Base Register，PDBR），存放着页目录的物理地址。一个进程在运行前，必须将其页目录的基地址存入CR3，而且，页目录的基地址必须对齐到4KB页边界。启用PAE时，CR3指向页目录指针表，每一项都指向一个页目录表，共有4个页目录表。</p><p>为了提高地址转换的效率，x86架构使用TLB对最近用到的页面映射进行缓存。TLB中存放着VFN到PFN的转换记录，当CPU访问某个线性地址时，如果其所在页面的映射存在于TLB中，无须查找页表，即可得到该线性地址对应的PFN，CPU 再将它与线性地址的偏移相加，就能得到最后的物理地址。</p><p><strong>x86架构内存管理中心分页机制总结：</strong></p><p>1）CPU访问一个线性地址，在TLB中进行匹配，如果地址转换在TLB中，则跳到步骤6。否则，发生了一次TLB Miss（TLB 缺失），继续步骤2。</p><p>2）查找页表，如果页面在物理内存中，则跳到步骤4。</p><p>3）如果页面不在物理内存中，则产生缺页错误，由操作系统的缺页错误处理程序进行以下处理。</p><ul><li>将页面从磁盘复制到物理内存中。</li><li>更改对应的PTE，设置P 位为1，并对其他字段进行相应的设置。</li><li>刷新TLB 中对应的PTE。</li><li>从缺页错误处理程序中返回。</li></ul><p>4）此时，页面已经存在于物理内存中，并且页表也已经包含了这个映射。重新在TLB中进行匹配，如果地址转换在TLB中，则跳到步骤6。否则，发生了一次TLB Miss（TLB 缺失），继续步骤5。</p><p>5）CPU重新查页表，把对应的映射插入到TLB中。</p><p>6）此时，TLB已经包含了该线性地址对应的PFN。将PFN和线性地址中的偏移量相加，就得到了对应的物理地址。</p><h2 id="中断与异常"><a href="#中断与异常" class="headerlink" title="中断与异常"></a>中断与异常</h2><p>程序的执行往往不只是按顺序执行那么简单，一些异常和中断会打断顺序执行的程序流，转而进入一条完全不同的执行路径。中断提供给外部设备一种“打断CPU当前执行任务，并响应自身服务”的手段。中断(interrupt)是异步的事件，典型的比如由I/O设备触发；异常(exception)是同步的事件，典型的比如处理器执行某条指令时发现出错了等等，其实异常的本质就是同步中断。</p><p>中断通常被定义为一个打断CPU芯片指令执行的事件，该事件对应到CPU芯片内部或者外部的电路产生的电子信号。</p><p>中断信号可以被划分为<strong>同步中断</strong>和<strong>异步中断</strong>：</p><p>同步中断，该类型中断由CPU的控制单元在执行指令的时候产生，并且是在当前指令执行完毕下一个指令执行之前产生。</p><p>异步中断，该类型中断由其他硬件设备在任意的时间产生，并且遵循CPU的时钟信号传递给CPU。</p><blockquote><p>对于Intel的CPU而言，它将同步中断称作异常，而将异步中断称作中断。</p></blockquote><p>通常中断（即异步中断）由时钟定时器或者其他I/O设备产生，如键盘接收到敲击某个按键的信号后产生的中断信号。而异常（即同步中断）则通常由于编程错误或者由CPU检测到异常条件需要内核进行处理而产生，如上面讲到的Page Fault Exception（缺页异常），异常可以由程序通过int或者sysenter指令主动产生。</p><p>对于Intel x86 CPU而言，它将中断和异常进行了如下归类：</p><p><strong>中断，即异步中断</strong>，中断信息随着CPU的时钟信号传递到CPU内部。中断分为<strong>可屏蔽中断</strong>和<strong>不可屏蔽中断</strong>两类。</p><ul><li><strong>可屏蔽中断</strong>，所有由I/O设备产生的IRQ请求都被归为可屏蔽中断。一个可屏蔽中断可以有两种状态，屏蔽或者不屏蔽，当一个中断被屏蔽时，该中断信号将被对应的控制单元所忽略。</li><li><strong>不可屏蔽中断</strong>，即控制单元无法忽略该类型的中断信号，CPU肯定会接收到该类型的中断，一般对应到一些紧要的事件，比如硬件错误。</li></ul><p><strong>异常，即同步中断</strong>，中断信号在CPU执行完某个指令后产生并接收到。处理器检测到的异常，即当CPU执行指令的时候检测到硬件上存在一些异常条件的时候就会产生该信号。这种类型的异常根据产生时在内核堆栈中保存的EIP寄存器的值（即异常恢复后CPU重新执行的位置）进行细分：</p><ul><li><strong>Faults，该异常可以被内核正确纠正，并且纠正后重新执行引起该异常的指令时不会造成程序的中断或者功能的异常。</strong>这时候保存到EIP寄存器的值是引起异常的指令的地址，故异常恢复的时候会重新执行该指令，如Page Fault Exception（缺页异常），当访问的内存地址没有被映射到物理内存时，产生异常，内核分配新的物理内存页并建立映射关系，然后异常处理完毕后，CPU重新访问该地址，即可访问到正确的物理内存。</li></ul><ul><li><strong>Traps，该异常发生时，内核堆栈EIP寄存器保存的地址指向引起该异常的指令的下一条指令，即当该异常处理返回后会继续程序的执行，而不是重新执行引起异常的指令。</strong>x86 CPU的硬件虚拟化功能就是利用陷入（Traps）再模拟的方法，当CPU执行虚拟机指令的时候，如果执行的是敏感指令，就会触发Traps类型的异常，让VMM（Virtual Machine Monitor）对该敏感指令进行模拟，然后继续恢复虚拟机的运行。</li></ul><ul><li><strong>Aborts，当发生严重的错误时，CPU已经无法保证内核堆栈中EIP寄存器存放的值是引起该异常的指令的地址。</strong>该异常用于汇报严重的错误，如硬件错误或者是内存的不一致性。该异常信号让CPU切换到相应的abort exception handler，该处理函数由于无法确认错误，只能结束当前进程。</li></ul><p>我们在写程序时，经常会在容易产生错误的地方进行异常抛出，然后针对抛出的异常定义执行策略。这类编程产生的异常，由程序主动执行int或者int3之类的指令产生。CPU像处理Traps一样处理这些程序主动产生的异常，该类异常通常被称为<strong>软件中断（software interrupt）</strong>。这类异常主要有两种用途：实现系统调用和通知某个debugger特定的事件发生。</p><p>这些异常或中断由0~255的数字唯一标识，也就是经常说的中断信号量。对于不可屏蔽中断和异常来说，相应的中断信号量是固定的，而可屏蔽中断对应的中断信号量则可以通过设置中断控制器来更改。</p><h2 id="x86系统的I-O架构"><a href="#x86系统的I-O架构" class="headerlink" title="x86系统的I/O架构"></a>x86系统的I/O架构</h2><p>计算机所处理的任务其实只有两种：CPU运算和I/O操作。这部分内容是后续学习计算虚拟化中I/O虚拟化的基础。I/O（输入/输出）是CPU访问外部设备的方法。设备通常通过寄存器和设备RAM将自身功能展现给CPU，CPU通过读/写这些寄存器和RAM完成对设备的访问及其他操作。按访问方式的不同，x86架构的I/O分为如下两类：</p><p><strong>1）端口I/O（后文简称为Port I/O）：</strong>即通过I/O端口访问设备寄存器。x86有65536个8位的I/O端口，编号为0x0~0xFFFF。CPU将端口号作为设备端口的地址，进而对设备进行访问。这65536个端口构成了64KB的I/O端口地址空间。I/O端口地址空间是独立的，不是线性地址空间或物理地址空间的一</p><p>部分。需要使用特定的操作命令IN/OUT对端口进行访问，此时CPU通过一个特殊的芯片管脚标识这是一次I/O端口访问，于是芯片组知道地址线上的地址是I/O端口号并相应地完成操作。此外，2个或4个连续的8位I/O端口可以组成16位或32位的I/O端口。</p><p><strong>2）内存映射I/O（Memory Map I/O，后文简称为MMIO）：</strong>即通过内存访问的形式访问设备寄存器或设备RAM。MMIO要占用CPU的物理地址空间，它将设备寄存器或设备RAM映射到物理地址空间的某段地址，然后使用MOV等访存指令访问此段地址，即可访问到映射的设备。MMIO方式访问设备也需</p><p>要进行线性地址到物理地址的转换，但是这个转换过程中的MMIO地址不可缓存到TLB中。MMIO是一种更普遍、更先进的I/O访问方式，很多CPU 架构都没有Port I/O，采用统一的MMIO方式。</p><h2 id="DMA技术"><a href="#DMA技术" class="headerlink" title="DMA技术"></a>DMA技术</h2><p>直接内存访问（Direct Memory Access，后文简称为DMA）是所有现代计算机的重要特色。DMA允许设备绕开CPU直接向内存中复制或读取数据。如果设备向内存复制数据都经过CPU，则CPU会有大量中断负载，中断过程中，CPU对其他任务来讲无法使用，不利于系统性能的提高。通过DMA，CPU只负责初始化这个传输动作，而传输动作本身由DMA 控制器（简称为DMAC）来实行和完成。在实现DMA传输时，由DMAC直接控制总线，在DMA传输前，CPU要把总线控制权交给DMAC，结束DMA传输后，DMAC立即把总线控制权交回给CPU。</p><p><strong>一个完整的DMA 传输过程的基本流程如下：</strong></p><p><strong>1）DMA请求：</strong>CPU对DMAC进行初始化，并向I/O端口发出操作命令，I/O端口提出DMA请求。</p><p><strong>2）DMA响应：</strong>DMAC对DMA请求进行优先级判别和屏蔽判别，然后向总线控制芯片提出总线请。CPU执行完当前总线周期后释放总线控制权。此时，总线控制芯片发出总线应答，表示DMA请求已被响应，并通过DMAC通知I/O端口开始DMA传输。</p><p><strong>3）DMA传输：</strong>DMAC获得总线控制权后，CPU即可挂起或只执行内部操作，由DMAC发出读/写命令，直接控制RAM与I/O端口进行DMA传输。</p><p><strong>4）DMA结束：</strong>当完成规定的成批数据传送后，DMAC释放总线控制权，并向I/O端口发出结束信号。当I/O端口接收到结束信号后，停止I/O设备的工作并向CPU提出中断请求，使CPU执行一段检查本次DMA传输操作正确性判断的代码，并从不介入的状态退出。</p><p>由此可见，DMA无须CPU直接控制传输，也没有中断处理方式那样保留现场和恢复现场的过程，通过硬件（DMAC）为RAM与I/O设备开辟了一条直接传送数据的通路，极大地提高了CPU效率。需要注意的是，DMA操作访问的必须是连续的物理内存。DMA 传输的过程如下图所示。</p><p><img src="https://i.loli.net/2019/04/21/5cbc280a44322.jpg"></p><h2 id="进程、线程和协程"><a href="#进程、线程和协程" class="headerlink" title="进程、线程和协程"></a>进程、线程和协程</h2><p><strong>什么是进程和线程</strong></p><p>进程是什么呢？大白话讲，进程就是应用程序的启动实例。比如我们运行一个游戏，打开一个软件，就是开启了一个进程。进程拥有代码和打开的文件资源、数据资源、独立的内存空间。</p><p>线程又是什么呢？线程从属于进程，是程序的实际执行者。一个进程至少包含一个主线程，也可以有更多的子线程。线程拥有自己的栈空间。</p><p><img src="https://i.loli.net/2019/04/21/5cbc282ce34ef.jpg"></p><p><strong>对操作系统来说，线程是最小的执行单元，进程是最小的资源管理单元</strong>。无论进程还是线程，都是由操作系统所管理的。线程一般具有五种状态：初始化&gt;&gt;&gt;可运行&gt;&gt;&gt;运行中&gt;&gt;&gt;阻塞&gt;&gt;&gt;销毁。线程不同状态之间的转化均需要CPU开销来完成。</p><p><strong>什么是协程协程</strong></p><p>携程英文Coroutines，是一种比线程更加轻量级的存在。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p><p><img src="https://i.loli.net/2019/04/21/5cbc28480061c.jpg"></p><p>在Python语言中有个生成器的概念，里面有个关键字yield，当程序执行到yield关键字时，会暂停在那一行，等到主线程调用send方法发送了数据，协程才会接到数据继续执行。但是，yield让程序暂停，和线程的阻塞是有本质区别的。通过yield关键字的暂停完全由程序控制，线程的阻塞状态是由操作系统内核来进行切换。大家可以在Python脚本中写入如下代码并执行体验下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consume</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="comment"># consume等待接收数据</span></span><br><span class="line">number = <span class="keyword">yield</span></span><br><span class="line">print(<span class="string">"我要执行啦。。。。开始计数："</span>,number)</span><br><span class="line">consumer = consume()</span><br><span class="line">next(consumer)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">100</span>):</span><br><span class="line">print(<span class="string">"开始执行："</span>,num)</span><br><span class="line">consumer.send(num)</span><br></pre></td></tr></table></figure><p>在《流畅的Python》一书中还有个例子，可以更好地来说明协程的特点。如下面示例是一个计算移动平均值的协程函数。实现的功能说明如下：</p><p>1）函数体中是一个无限循环，表明只要调用方不断把值发给这个协程，它就会一直接收值，然后生成结果。仅当调用方在协程上调用 .close() 方法，或者没有对协程的引用而被垃圾回收程序回收时，这个协程才会终止。</p><p>2）yield 表达式用于暂停执行协程，把结果发给调用方；还用于接收调用方后面发给协程的值，恢复无限循环。</p><p><strong>使用协程的好处是，total 和 count 声明为局部变量即可，无需使用实例属性或闭包在多次调用之间保持上下文。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">()</span>:</span></span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    average = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        term = <span class="keyword">yield</span> average</span><br><span class="line">        total += term</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        average = total/count</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建协程对象</span></span><br><span class="line">coro_avg = averager()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用next函数，激活协程</span></span><br><span class="line">next(coro_avg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算移动平均值：多次调用 .send(...) 方法，产出当前的平均值</span></span><br><span class="line">print(coro_avg.send(<span class="number">10</span>))  <span class="comment"># 10.0</span></span><br><span class="line">print(coro_avg.send(<span class="number">20</span>))  <span class="comment"># 15.0</span></span><br><span class="line">print(coro_avg.send(<span class="number">30</span>))  <span class="comment"># 20.0</span></span><br><span class="line">print(coro_avg.send(<span class="number">50</span>))  <span class="comment"># 27.5</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;标准服务器技术是网络功能虚拟化（NFV）实现的一个关键因素，了解一些x86架构的基础知识对大家后续了解电信云关键技术，尤其是掌握虚拟化技术原理和关键优化方案是必须具备的。本文主要从x86架构的CPU指令集增强，内存管理、中断和异常、IO架构等部分进行阐述，以及包含一些基础IT的基本概念的讲解。
    
    </summary>
    
      <category term="NFV关键技术" scheme="https://kkutysllb.cn/categories/NFV%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="电信云" scheme="https://kkutysllb.cn/tags/%E7%94%B5%E4%BF%A1%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>2019-04-20-Linux系统命令-第三篇《文件过滤及内容编辑处理》</title>
    <link href="https://kkutysllb.cn/2019/04/20/2019-04-20-Linux%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4-%E7%AC%AC%E4%B8%89%E7%AF%87%E3%80%8A%E6%96%87%E4%BB%B6%E8%BF%87%E6%BB%A4%E5%8F%8A%E5%86%85%E5%AE%B9%E7%BC%96%E8%BE%91%E5%A4%84%E7%90%86%E3%80%8B/"/>
    <id>https://kkutysllb.cn/2019/04/20/2019-04-20-Linux系统命令-第三篇《文件过滤及内容编辑处理》/</id>
    <published>2019-04-20T11:00:36.000Z</published>
    <updated>2019-05-01T16:26:24.519Z</updated>
    
    <content type="html"><![CDATA[<h2 id="cat：合并文件或查看文件内容"><a href="#cat：合并文件或查看文件内容" class="headerlink" title="cat：合并文件或查看文件内容"></a>cat：合并文件或查看文件内容</h2><p>cat命令可以理解为英文单词concatenate的缩写，其功能是连接多个文件并且打印到屏幕输出，或者重定向到指定的文件中。此命令常用来显示单个文件内容，或者将几个文件内容连接起来一起显示，还可以从标准输入中读取内容并显示，生产环境中它常与重定向或追加符号配合使用。<a id="more"></a></p><p><strong>cat命令具备5大常用功能</strong></p><p><img src="https://i.loli.net/2019/04/20/5cbafc16222d5.jpg"></p><p><strong>语法格式：cat [option] [file]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/04/20/5cbafc44edbdf.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）在/home/kkutysllb目录下生成一个data001文件</strong></p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># EOF这里要按回车才能结束，另外，EOF必须成对出现，但也可以用别的成对标签来替换。</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; [root@C7-Server01 kkutysllb]<span class="comment"># cat &gt;&gt; data001 &lt;&lt; EOF</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; &gt; day001...</span><br><span class="line">&gt; &gt; day002...</span><br><span class="line">&gt; &gt; day003...</span><br><span class="line">&gt; &gt; day004...</span><br><span class="line">&gt; &gt; ...</span><br><span class="line">&gt; &gt; day00n...</span><br><span class="line">&gt; &gt; EOF</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用cat -n查看刚编辑生成的文件data001 </span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># cat -n data001       </span></span><br><span class="line"></span><br><span class="line">1day001...      </span><br><span class="line"></span><br><span class="line">2day002...      </span><br><span class="line"></span><br><span class="line">3day003...      </span><br><span class="line"></span><br><span class="line">4day004...      </span><br><span class="line"></span><br><span class="line">5...      </span><br><span class="line"></span><br><span class="line">6day00n...</span><br></pre></td></tr></table></figure><p><strong>2）直接执行cat命令，不带任何选项</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前目录下soft_link软链接文件的内容 </span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># cat soft_link  </span></span><br><span class="line"></span><br><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4 </span><br><span class="line"></span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br></pre></td></tr></table></figure><p><strong>3）执行cat命令，分别带-n及-b选项，并对比区别</strong></p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 新生成data002文件，输入以下内容，注意其中的空行要保留</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; [root@C7-Server01 kkutysllb]<span class="comment"># cat &gt;&gt; data002 &lt;&lt; EOF</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; &gt; www.sina.com.cn</span><br><span class="line">&gt; &gt;</span><br><span class="line">&gt; &gt; www.baidu.com</span><br><span class="line">&gt; &gt;</span><br><span class="line">&gt; &gt; www.chinamobile.com</span><br><span class="line">&gt; &gt;</span><br><span class="line">&gt; &gt; sn.chinamobile.com</span><br><span class="line">&gt; &gt;</span><br><span class="line">&gt; &gt; EOF</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 使用-n选项查看data002文件的内容</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 文件内容中的空行也被标识行号</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; [root@C7-Server01 kkutysllb]<span class="comment"># cat -n data002</span></span><br><span class="line">&gt; 1www.sina.com.cn</span><br><span class="line">&gt; 2</span><br><span class="line">&gt; 3www.baidu.com</span><br><span class="line">&gt; 4</span><br><span class="line">&gt; 5www.chinamobile.com</span><br><span class="line">&gt; 6</span><br><span class="line">&gt; 7sn.chinamobile.com</span><br><span class="line">&gt; 8</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 使用-b选项查看data002文件的内容，会忽略显示空白行行号</span></span><br><span class="line">&gt;</span><br><span class="line">&gt; [root@C7-Server01 kkutysllb]<span class="comment"># cat -b data002</span></span><br><span class="line">&gt; 1www.sina.com.cn</span><br><span class="line">&gt; 2www.baidu.com</span><br><span class="line">&gt; 3www.chinamobile.com</span><br><span class="line">&gt; 4sn.chinamobile.com</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>3）执行cat命令，带-E选项</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -E选项会在显示文件的每行行尾加上$符号 </span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># cat -E data001 </span></span><br><span class="line"></span><br><span class="line">day001...$ </span><br><span class="line"></span><br><span class="line">day002...$ </span><br><span class="line"></span><br><span class="line">day003...$ </span><br><span class="line"></span><br><span class="line">day004...$ </span><br><span class="line"></span><br><span class="line">...$ </span><br><span class="line"></span><br><span class="line">day00n...$</span><br></pre></td></tr></table></figure><p><strong>4）cat的一个特殊小用法（没基础的可以先大致了解，后续学了shell脚本后再看这部分）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用cat在shell脚本中显示帮助菜单 </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"></span><br><span class="line">exportfs_usage() </span><br><span class="line"></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">cat &lt;&lt; END</span><br><span class="line"></span><br><span class="line">USAGE:  <span class="variable">$0</span> &#123;start|stop|monitor|status|validate-all&#125;</span><br><span class="line"></span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exportfs_usage</span><br></pre></td></tr></table></figure><p><strong>执行上述脚本的输出如下：</strong></p><p><img src="https://i.loli.net/2019/04/20/5cbafdfe746ff.jpg"></p><p>为了实现自动化运维，有时运维人员不得不通过脚本把操作写好，然后让其他同事，通过傻瓜式的菜单选择，来完成相应的工作，进而提升工作效率。因此，cat命令在shell编程中常用来描写菜单输出操作。</p><p><strong>小练习：其他选项用法请自行练习，将结果贴在讨论区。提示：与cat命令作用相反的命令为tac，其作用是方向显示文件的内容，请自行研究练习。</strong></p><p><strong>补充知识：LInux系统中的重定向</strong></p><blockquote><p><strong>重定向简介</strong></p><p>重定向是Linux中一个重要知识点，对于它的作用，直白点儿说，就是可以让数据从一个地方（文件或工具）无损地流到另一个地方。</p><p><strong>标准输入/输出/错误输出</strong></p><p>标准输入是一个名称，它表示数据的一个流入方向，通常表示数据从文件等流入到处理的工具或命令中，用代码0表示，使用&lt;或&lt;&lt;符号来指示数据朝箭头所指的方向流动。</p><p>标准输出也是一个名称，也表示数据的一个流入方向，通常用代码1表示，使用&gt;或&gt;&gt;符号来指示数据朝箭头的方向流动。和标准输入不同的是，1表示将命令等处理的一般信息输出到文件。</p><p>标准错误输出是另一个名称，也是表示数据的一个流入方向，通常用代码2表示，使用&gt;或&gt;&gt;符号来指示数据朝箭头的方向流动。和标准输出不同的是，标准错误输出2表示将错误的信息输出到文件等，不输出正确的普通信息（仅输出错误信息）。</p></blockquote><h2 id="more：分页显示文件内容"><a href="#more：分页显示文件内容" class="headerlink" title="more：分页显示文件内容"></a>more：分页显示文件内容</h2><p>more命令的功能类似于cat，但cat命令是将整个文件的内容一次性显示在屏幕上，而more则会一页一页地显示文件内容。但more的功能还是比较简单的，有一个增强版的命令是less，将在后面讲解。（其实，学会了less命令，大家就可以把more命令忘记了）</p><p><strong>语法格式：more [option] [file]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/04/20/5cbb018212065.jpg"></p><p>在交互模式下，使用more命令打开文本之后，会进入一个基于vi的交互界面，在这里可以使用部分vi编辑器的功能，如搜索功能，还可以切换到vi编辑器。常用操作方式如下：</p><p><img src="https://i.loli.net/2019/04/20/5cbb01a03a20b.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）more命令后面不接任何参数</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示/etc/services文件内容 </span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># more /etc/services</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/04/20/5cbb01c87fcd5.jpg"></p><p><strong>2）显示指定行数的内容</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示/etc/service文件的前5行内容</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># more -5 /etc/services </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># /etc/services:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># $Id: services,v 1.55 2013/04/14 ovasik Exp $</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Network services, Internet style</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># IANA services version: last updated 2013-04-10</span></span><br></pre></td></tr></table></figure><p><strong>3）从指定的行数开始显示内容</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从465行开始显示/etc/service文件的内容</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># more -5 /etc/services </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># /etc/services:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># $Id: services,v 1.55 2013/04/14 ovasik Exp $</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Network services, Internet style</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># IANA services version: last updated 2013-04-10</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># more +465 /etc/services </span></span><br><span class="line">bpjava-msvc     13722/tcp                       <span class="comment"># BP Java MSVC Protocol</span></span><br><span class="line">bpjava-msvc     13722/udp                       <span class="comment"># BP Java MSVC Protocol</span></span><br><span class="line">vnetd           13724/tcp                       <span class="comment"># Veritas Network Utility</span></span><br><span class="line">vnetd           13724/udp                       <span class="comment"># Veritas Network Utility</span></span><br><span class="line">bpcd            13782/tcp                       <span class="comment"># VERITAS NetBackup</span></span><br><span class="line">bpcd            13782/udp                       <span class="comment"># VERITAS NetBackup</span></span><br><span class="line">vopied          13783/tcp                       <span class="comment"># VOPIED Protocol</span></span><br><span class="line">vopied          13783/udp                       <span class="comment"># VOPIED Protocol</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This port is registered as wnn6, but also used under the unregistered name</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># "wnn4" by the FreeWnn package.</span></span><br><span class="line"></span><br><span class="line">wnn6            22273/tcp       wnn4</span><br><span class="line">wnn6            22273/udp       wnn4</span><br><span class="line"></span><br><span class="line">quake           26000/tcp</span><br><span class="line">quake           26000/udp</span><br><span class="line">wnn6-ds         26208/tcp</span><br><span class="line">wnn6-ds         26208/udp</span><br><span class="line">traceroute      33434/tcp</span><br><span class="line">traceroute      33434/udp</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Datagram Delivery Protocol services</span></span><br><span class="line"></span><br><span class="line">。。。</span><br></pre></td></tr></table></figure><p><strong>4）分页显示目录下的内容</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分页显示/etc/目录下的内容，每页显示10行内容 </span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># ls -l /etc/|more -10 </span></span><br><span class="line"></span><br><span class="line">total 1108 </span><br><span class="line"></span><br><span class="line">-rw-r--r--.  1 root root       16 Apr  7 20:39 adjtime </span><br><span class="line"></span><br><span class="line">-rw-r--r--.  1 root root     1518 Jun  7  2013 aliases </span><br><span class="line"></span><br><span class="line">-rw-r--r--.  1 root root    12288 Apr  7 20:43 aliases.db </span><br><span class="line"></span><br><span class="line">drwxr-xr-x.  2 root root      236 Apr  7 20:35 alternatives </span><br><span class="line"></span><br><span class="line">-rw-------.  1 root root      541 Apr 11  2018 anacrontab </span><br><span class="line"></span><br><span class="line">-rw-r--r--.  1 root root       55 Apr 11  2018 asound.conf </span><br><span class="line"></span><br><span class="line">drwxr-x---.  3 root root       43 Apr  7 20:35 audisp </span><br><span class="line"></span><br><span class="line">drwxr-x---.  3 root root       83 Apr  7 20:43 audit </span><br><span class="line"></span><br><span class="line">drwxr-xr-x.  2 root root       33 Apr  7 20:35 bash_completion.d </span><br><span class="line"></span><br><span class="line">--More-- 。。。</span><br></pre></td></tr></table></figure><p><strong>小练习：more的其它用法请自行练习，可在讨论区进行讨论</strong></p><h2 id="less：分页显示文件内容"><a href="#less：分页显示文件内容" class="headerlink" title="less：分页显示文件内容"></a>less：分页显示文件内容</h2><p>如果使用man less查看less的帮助文档，会发现官方的解释是less为more的反义词（opposite of more）。但less命令的名称只是个文字游戏，它是more命令的高级版本（less这个名称来自俗语“越简单就越丰富”，即less is more）。</p><p>less命令的基本功能类似于more命令，可以分页显示文件内容，但比more的功能更强大。less命令在读取文件内容时，并不是像more、vi命令一样，要一次性将整个文件加载之后再显示，而是会根据需要来加载文件的内容，这样打开文件的速度会更快。而且less命令支持[page up]、[page down]等按键的功能，可以通过该功能向前或向后翻看文件，这样更容易查看一个文件的内容。</p><p><strong>语法格式：less [option] [file]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/04/20/5cbb0240a4397.jpg"></p><p>在交互模式下，less命令也是基于more命令和vi命令的，在这里可以使用vi编辑器的部分功能，如搜索功能，还可以切换到vi编辑器。表3-7给出了less命令的交互式子命令。</p><p><strong>less交互式命令说明</strong></p><p><img src="https://i.loli.net/2019/04/20/5cbb0259c2592.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）查看文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用less查看/etc/services文件内容</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># less /etc/services </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># /etc/services:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># $Id: services,v 1.55 2013/04/14 ovasik Exp $</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Network services, Internet style</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># IANA services version: last updated 2013-04-10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Note that it is presently the policy of IANA to assign a single well-known</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># port number for both TCP and UDP; hence, most entries here have two entries</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># even if the protocol doesn't support UDP operations.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Updated from RFC 1700, ``Assigned Numbers'' (October 1994).  Not all ports</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># are included, only the more common ones.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The latest IANA port assignments can be gotten from</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># http://www.iana.org/assignments/port-numbers</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The Well Known Ports are those from 0 through 1023.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The Registered Ports are those from 1024 through 49151</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The Dynamic and/or Private Ports are those from 49152 through 65535</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Each line describes one service, and is of the form:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># service-name  port/protocol  [aliases ...]   [# comment]</span></span><br><span class="line"></span><br><span class="line">tcpmux          1/tcp                           <span class="comment"># TCP port service multiplexer</span></span><br><span class="line">tcpmux          1/udp                           <span class="comment"># TCP port service multiplexer</span></span><br><span class="line">rje             5/tcp                           <span class="comment"># Remote Job Entry</span></span><br><span class="line">rje             5/udp                           <span class="comment"># Remote Job Entry</span></span><br><span class="line"><span class="built_in">echo</span>            7/tcp</span><br><span class="line"><span class="built_in">echo</span>            7/udp</span><br><span class="line">discard         9/tcp           sink null</span><br><span class="line">discard         9/udp           sink null</span><br><span class="line">systat          11/tcp          users</span><br><span class="line">systat          11/udp          users</span><br><span class="line">daytime         13/tcp</span><br><span class="line">daytime         13/udp</span><br><span class="line">。。。</span><br></pre></td></tr></table></figure><p><strong>2）显示行号</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用less -N查看文件/etc/services的内容</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># less -N /etc/services </span></span><br><span class="line">1 <span class="comment"># /etc/services:</span></span><br><span class="line">2 <span class="comment"># $Id: services,v 1.55 2013/04/14 ovasik Exp $</span></span><br><span class="line">3 <span class="comment">#</span></span><br><span class="line">4 <span class="comment"># Network services, Internet style</span></span><br><span class="line">5 <span class="comment"># IANA services version: last updated 2013-04-10</span></span><br><span class="line">6 <span class="comment">#</span></span><br><span class="line">7 <span class="comment"># Note that it is presently the policy of IANA to assign a single well-known</span></span><br><span class="line">8 <span class="comment"># port number for both TCP and UDP; hence, most entries here have two entries</span></span><br><span class="line">9 <span class="comment"># even if the protocol doesn't support UDP operations.</span></span><br><span class="line">10 <span class="comment"># Updated from RFC 1700, ``Assigned Numbers'' (October 1994).  Not all ports</span></span><br><span class="line">11 <span class="comment"># are included, only the more common ones.</span></span><br><span class="line">12 <span class="comment">#</span></span><br><span class="line">13 <span class="comment"># The latest IANA port assignments can be gotten from</span></span><br><span class="line">14 <span class="comment">#       http://www.iana.org/assignments/port-numbers</span></span><br><span class="line">15 <span class="comment"># The Well Known Ports are those from 0 through 1023.</span></span><br><span class="line">16 <span class="comment"># The Registered Ports are those from 1024 through 49151</span></span><br><span class="line">17 <span class="comment"># The Dynamic and/or Private Ports are those from 49152 through 65535</span></span><br><span class="line">18 <span class="comment">#</span></span><br><span class="line">19 <span class="comment"># Each line describes one service, and is of the form:</span></span><br><span class="line">20 <span class="comment">#</span></span><br><span class="line">21 <span class="comment"># service-name  port/protocol  [aliases ...]   [# comment]</span></span><br><span class="line">22 </span><br><span class="line">23 tcpmux          1/tcp                           <span class="comment"># TCP port service multiplexer</span></span><br><span class="line">24 tcpmux          1/udp                           <span class="comment"># TCP port service multiplexer</span></span><br><span class="line">25 rje             5/tcp                           <span class="comment"># Remote Job Entry</span></span><br><span class="line">26 rje             5/udp                           <span class="comment"># Remote Job Entry</span></span><br><span class="line">27 <span class="built_in">echo</span>            7/tcp</span><br><span class="line">28 <span class="built_in">echo</span>            7/udp</span><br><span class="line">29 discard         9/tcp           sink null</span><br><span class="line">30 discard         9/udp           sink null</span><br><span class="line">31 systat          11/tcp          users</span><br><span class="line">32 systat          11/udp          users</span><br><span class="line">33 daytime         13/tcp</span><br><span class="line">34 daytime         13/udp</span><br><span class="line">35 qotd            17/tcp          quote</span><br><span class="line">36 qotd            17/udp          quote</span><br><span class="line">37 msp             18/tcp                          <span class="comment"># message send protocol (historic)</span></span><br><span class="line">38 msp             18/udp                          <span class="comment"># message send protocol (historic)</span></span><br><span class="line">39 chargen         19/tcp          ttytst <span class="built_in">source</span></span><br></pre></td></tr></table></figure><p><strong>小练习：使用less分页显示/etc/目录下的内容。（提示：可参照more使用示例）</strong></p><h2 id="head：显示文件内容头部"><a href="#head：显示文件内容头部" class="headerlink" title="head：显示文件内容头部"></a>head：显示文件内容头部</h2><p>head命令用于显示文件内容头部，它默认输出文件的开头10行。如果指定了多个文件，则在每一段输出前会给出文件名作为文件头。</p><p><strong>语法格式：head [option] [file]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/04/20/5cbb02beca189.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）不带任何参数，默认显示文件的前10行内容</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示/etc/passwd文件的前10行内容</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># head /etc/passwd</span></span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line">lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br><span class="line">sync:x:5:0:sync:/sbin:/bin/sync</span><br><span class="line">shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown</span><br><span class="line">halt:x:7:0:halt:/sbin:/sbin/halt</span><br><span class="line">mail:x:8:12:mail:/var/spool/mail:/sbin/nologin</span><br><span class="line">operator:x:11:0:operator:/root:/sbin/nologin</span><br></pre></td></tr></table></figure><p><strong>2）显示文件的前n行内容</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示/etc/passwd文件的前5行内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 选项n可带也可不带，通常情况下，为简化指令一般不带选项n，直接输入数字即可</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># head -5 /etc/passwd</span></span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line">lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br></pre></td></tr></table></figure><p><strong>3） 读取文件的前10个字节</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-c选项，读取/etc/hosts文件的前10个字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：空格符也统计在内</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># head -c 10 /etc/hosts</span></span><br><span class="line">127.0.0.1 <span class="comment"># 这行最后有一个空格</span></span><br></pre></td></tr></table></figure><p><strong>4） 显示多个文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同时显示/etc/hosts和/etc/passwd文件的前5行内容</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># head -c 10 /etc/hosts</span></span><br><span class="line">127.0.0.1 [root@C7-Server01 kkutysllb]<span class="comment"># head -5 /etc/hosts /etc/passwd</span></span><br><span class="line">==&gt; /etc/hosts &lt;==  <span class="comment"># 每个文件名作为文件头</span></span><br><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line">==&gt; /etc/passwd &lt;== <span class="comment"># 每个文件名作为文件头</span></span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line">lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br></pre></td></tr></table></figure><p><strong>小练习：使用head命令只显示/etc/services文件的最后一行内容</strong></p><h2 id="tail：显示文件内容尾部"><a href="#tail：显示文件内容尾部" class="headerlink" title="tail：显示文件内容尾部"></a>tail：显示文件内容尾部</h2><p>tail命令用于显示文件内容的尾部，它默认输出文件的最后10行。如果指定了多于一个文件，则在每一段输出前会给出文件名作为文件头。</p><p><strong>语法格式：tail [option] [file]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/04/20/5cbb031ae5511.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）不带任何参数，默认显示文件的最后10行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示/etc/passwd文件的最后10行内容</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># tail /etc/passwd</span></span><br><span class="line">nobody:x:99:99:Nobody:/:/sbin/nologin</span><br><span class="line">systemd-network:x:192:192:systemd Network Management:/:/sbin/nologin</span><br><span class="line">dbus:x:81:81:System message bus:/:/sbin/nologin</span><br><span class="line">polkitd:x:999:998:User <span class="keyword">for</span> polkitd:/:/sbin/nologin</span><br><span class="line">tss:x:59:59:Account used by the trousers package to sandbox the tcsd daemon:/dev/null:/sbin/nologin</span><br><span class="line">sshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin</span><br><span class="line">postfix:x:89:89::/var/spool/postfix:/sbin/nologin</span><br><span class="line">chrony:x:998:996::/var/lib/chrony:/sbin/nologin</span><br><span class="line">ntp:x:38:38::/etc/ntp:/sbin/nologin</span><br><span class="line">kkutysllb:x:1000:1000::/home/kkutysllb:/bin/bash</span><br></pre></td></tr></table></figure><p><strong>2）显示文件的末尾5行内容</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 与head命令一样，可以省略-n选项，直接填写数字</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># tail -5 /etc/services </span></span><br><span class="line">com-bardac-dw   48556/tcp               <span class="comment"># com-bardac-dw</span></span><br><span class="line">com-bardac-dw   48556/udp               <span class="comment"># com-bardac-dw</span></span><br><span class="line">iqobject        48619/tcp               <span class="comment"># iqobject</span></span><br><span class="line">iqobject        48619/udp               <span class="comment"># iqobject</span></span><br><span class="line">matahari        49000/tcp               <span class="comment"># Matahari Broker</span></span><br></pre></td></tr></table></figure><p><strong>3）实时监控文件的变化</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-f选项实时监控系统安全日志/var/log/secure</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># tail -f /var/log/secure</span></span><br></pre></td></tr></table></figure><p><strong><em>初始状态如下</em></strong></p><p><img src="https://i.loli.net/2019/04/20/5cbb0377470ea.jpg"></p><p><strong><em>当我再次打开一个终端时，文件实时发生变化</em></strong></p><p><img src="https://i.loli.net/2019/04/20/5cbb03921a52c.jpg"></p><p><strong>需要说明的是：使用tail -f实时跟踪日志文件结束后，必须使用Ctrl+C退出。同时，在Linux系统还有一个专门跟踪系统日志文件的命令tailf，功能几乎等同于tail-f，与tail-f不同的是，如果文件不增长，那么它不会去访问磁盘文件，也不会更改文件的访问时间。</strong></p><h2 id="cut：从文本中提取一段文字并输出"><a href="#cut：从文本中提取一段文字并输出" class="headerlink" title="cut：从文本中提取一段文字并输出"></a>cut：从文本中提取一段文字并输出</h2><p>cut命令从文件的每一行剪切字节、字符或字段，并将这些字节、字符或字段输出至标准输出。</p><p><strong>语法格式：cut [option] [file]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/04/20/5cbb03a92ad40.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）以字节为分隔符</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示当前目录下data001文件的内容</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># cat data001</span></span><br><span class="line">day001...</span><br><span class="line">day002...</span><br><span class="line">day003...</span><br><span class="line">day004...</span><br><span class="line">...</span><br><span class="line">day00n...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以-b选项，只显示data001文件每行的第3个字节内容</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># cut -b 3 data001</span></span><br><span class="line">y</span><br><span class="line">y</span><br><span class="line">y</span><br><span class="line">y</span><br><span class="line">.</span><br><span class="line">y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示data001文件每行的第3到第5个字节内容</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># cut -b 3-5 data001</span></span><br><span class="line">y00</span><br><span class="line">y00</span><br><span class="line">y00</span><br><span class="line">y00</span><br><span class="line">.</span><br><span class="line">y00</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示data001文件每行从第1个字节到第3个字节的内容</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># cut -b -3 data001</span></span><br><span class="line">day</span><br><span class="line">day</span><br><span class="line">day</span><br><span class="line">day</span><br><span class="line">...</span><br><span class="line">day</span><br></pre></td></tr></table></figure><p><strong>2）以字符为分隔符</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示data001文件每行的第2到5个字符</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># cut -c 2-5 data001</span></span><br><span class="line">ay00</span><br><span class="line">ay00</span><br><span class="line">ay00</span><br><span class="line">ay00</span><br><span class="line">..</span><br><span class="line">ay00</span><br></pre></td></tr></table></figure><p><strong>发现与-b选项的输出没有区别，这是英文是以单字母为字符的，如果换成中文就看出区别了，请大家自行练习。</strong></p><p><strong>3）自定义分隔符</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用：作为分隔符，显示/etc/passwd文件所有行的第一列的内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此方法和后续三剑客中awk使用场景类似</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># cut -d : -f 1 /etc/passwd</span></span><br><span class="line">root</span><br><span class="line">bin</span><br><span class="line">daemon</span><br><span class="line">adm</span><br><span class="line">lp</span><br><span class="line">sync</span><br><span class="line">shutdown</span><br><span class="line">halt</span><br><span class="line">mail</span><br><span class="line">operator</span><br><span class="line">games</span><br><span class="line">ftp</span><br><span class="line">nobody</span><br><span class="line">systemd-network</span><br><span class="line">dbus</span><br><span class="line">polkitd</span><br><span class="line">tss</span><br><span class="line">sshd</span><br><span class="line">postfix</span><br><span class="line">chrony</span><br><span class="line">ntp</span><br><span class="line">kkutysllb<span class="comment"># 以：为分隔符，显示/etc/passwd文件每行的3-5列内容</span></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># cut -d : -f 3-5 /etc/passwd</span></span><br><span class="line">0:0:root</span><br><span class="line">1:1:bin</span><br><span class="line">2:2:daemon</span><br><span class="line">3:4:adm</span><br><span class="line">4:7:lp</span><br><span class="line">5:0:sync</span><br><span class="line">6:0:shutdown</span><br><span class="line">7:0:halt</span><br><span class="line">8:12:mail</span><br><span class="line">11:0:operator</span><br><span class="line">12:100:games</span><br><span class="line">14:50:FTP User</span><br><span class="line">99:99:Nobody</span><br><span class="line">192:192:systemd Network Management</span><br><span class="line">81:81:System message bus</span><br><span class="line">999:998:User <span class="keyword">for</span> polkitd</span><br><span class="line">59:59:Account used by the trousers package to sandbox the tcsd daemon</span><br><span class="line">74:74:Privilege-separated SSH</span><br><span class="line">89:89:</span><br><span class="line">998:996:</span><br><span class="line">38:38:</span><br><span class="line">1000:1000:</span><br></pre></td></tr></table></figure><h2 id="sort：文本排序"><a href="#sort：文本排序" class="headerlink" title="sort：文本排序"></a>sort：文本排序</h2><p>sort命令将输入的文件内容按照指定的规则进行排序，然后将排序结果输出。</p><p><strong>语法格式：sort [option] [file]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/04/20/5cbb0404b1851.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）默认以行为单位进行比较</strong></p><p>默认比较的原则是从首字符向后，依次按ASCII码值进行比较，输出默认按升序进行排列。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成一个实验文件，写入如下内容</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># cat &gt;&gt; data003 &lt;&lt; EOF</span></span><br><span class="line"></span><br><span class="line">&gt; 10.0.2.1</span><br><span class="line">&gt; 10.0.2.56</span><br><span class="line">&gt; 10.0.2.3</span><br><span class="line">&gt; 10.0.2.5</span><br><span class="line">&gt; 10.0.2.14</span><br><span class="line">&gt; 10.0.2.11</span><br><span class="line">&gt; EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用sort默认对data003文件进行升序排序输出</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># sort data003</span></span><br><span class="line">10.0.2.1</span><br><span class="line">10.0.2.11</span><br><span class="line">10.0.2.14</span><br><span class="line">10.0.2.3</span><br><span class="line">10.0.2.5</span><br><span class="line">10.0.2.56</span><br></pre></td></tr></table></figure><p><strong>2）使用-n选项使输出按数字从小到大的顺序进行排列</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># sort -n data003</span></span><br><span class="line">10.0.2.1</span><br><span class="line">10.0.2.11</span><br><span class="line">10.0.2.14</span><br><span class="line">10.0.2.3</span><br><span class="line">10.0.2.5</span><br><span class="line">10.0.2.56</span><br></pre></td></tr></table></figure><p><strong>3）结合-r选项进行反向排序</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># sort -nr data003</span></span><br><span class="line">10.0.2.56</span><br><span class="line">10.0.2.5</span><br><span class="line">10.0.2.3</span><br><span class="line">10.0.2.14</span><br><span class="line">10.0.2.11</span><br><span class="line">10.0.2.1</span><br></pre></td></tr></table></figure><p><strong>4）使用-t和-k按照指定格式要求进行排序</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对/etc/passwd文件按要求进行排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-t选项指定分割符为：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-k数字选项指定按照分割后的第3列进行排序</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># sort -t : -k 3 /etc/passwd</span></span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">kkutysllb:x:1000:1000::/home/kkutysllb:/bin/bash</span><br><span class="line">operator:x:11:0:operator:/root:/sbin/nologin</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">games:x:12:100:games:/usr/games:/sbin/nologin</span><br><span class="line">ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin</span><br><span class="line">systemd-network:x:192:192:systemd Network Management:/:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line">ntp:x:38:38::/etc/ntp:/sbin/nologin</span><br><span class="line">lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br><span class="line">sync:x:5:0:sync:/sbin:/bin/sync</span><br><span class="line">tss:x:59:59:Account used by the trousers package to sandbox the tcsd daemon:/dev/null:/sbin/nologin</span><br><span class="line">shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown</span><br><span class="line">halt:x:7:0:halt:/sbin:/sbin/halt</span><br><span class="line">sshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin</span><br><span class="line">mail:x:8:12:mail:/var/spool/mail:/sbin/nologin</span><br><span class="line">dbus:x:81:81:System message bus:/:/sbin/nologin</span><br><span class="line">postfix:x:89:89::/var/spool/postfix:/sbin/nologin</span><br><span class="line">chrony:x:998:996::/var/lib/chrony:/sbin/nologin</span><br><span class="line">polkitd:x:999:998:User <span class="keyword">for</span> polkitd:/:/sbin/nologin</span><br><span class="line">nobody:x:99:99:Nobody:/:/sbin/nologin</span><br></pre></td></tr></table></figure><p><strong>5）使用-k选项的进阶用法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-k选项指定字符范围进行排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -k4.1,4,2表示按照第4列的第一个字符到第二个字符范围整体排序</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># sort -n -t . -k 4.1,4.2 data003</span></span><br><span class="line">10.0.2.1</span><br><span class="line">10.0.2.3</span><br><span class="line">10.0.2.5</span><br><span class="line">10.0.2.11</span><br><span class="line">10.0.2.14</span><br><span class="line">10.0.2.56</span><br></pre></td></tr></table></figure><h2 id="uniq：去除重复行"><a href="#uniq：去除重复行" class="headerlink" title="uniq：去除重复行"></a>uniq：去除重复行</h2><p>uniq命令可以输出或忽略文件中的重复行。在工作中，我们常用的场景是使用sort命令对文件排序，然后使用uniq命令去重并计数。</p><p><strong>语法格式：uniq [option] [INPUT]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/04/20/5cbb046a974b3.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）去重测试</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建测试文件</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># cat data003</span></span><br><span class="line">10.0.2.1</span><br><span class="line">10.0.2.56</span><br><span class="line">10.0.2.3</span><br><span class="line">10.0.2.5</span><br><span class="line">10.0.2.14</span><br><span class="line">10.0.2.11</span><br><span class="line">10.0.2.2</span><br><span class="line">10.0.2.2</span><br><span class="line">10.0.2.3</span><br><span class="line">10.0.2.11</span><br><span class="line">10.0.2.1</span><br><span class="line">10.0.2.1</span><br><span class="line">10.0.2.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用uniq指令去重，结合sort指令一起使用</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># sort data003 | uniq</span></span><br><span class="line">10.0.2.1</span><br><span class="line">10.0.2.11</span><br><span class="line">10.0.2.14</span><br><span class="line">10.0.2.2</span><br><span class="line">10.0.2.3</span><br><span class="line">10.0.2.5</span><br><span class="line">10.0.2.56</span><br></pre></td></tr></table></figure><p><strong>2）显示重复行的个数</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># sort -n -t . -k 4.1,4.2 data003 | uniq -c</span></span><br><span class="line">4 10.0.2.1</span><br><span class="line">2 10.0.2.2</span><br><span class="line">2 10.0.2.3</span><br><span class="line">1 10.0.2.5</span><br><span class="line">2 10.0.2.11</span><br><span class="line">1 10.0.2.14</span><br><span class="line">1 10.0.2.56</span><br></pre></td></tr></table></figure><p><strong>3）只显示重复行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># sort -n -t . -k 4.1,4.2 data003 | uniq -cd</span></span><br><span class="line">4 10.0.2.1</span><br><span class="line">2 10.0.2.2</span><br><span class="line">2 10.0.2.3</span><br><span class="line">2 10.0.2.11</span><br></pre></td></tr></table></figure><p><strong>4）只显示唯一行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># sort -n -t . -k 4.1,4.2 data003 | uniq -u</span></span><br><span class="line">10.0.2.5</span><br><span class="line">10.0.2.14</span><br><span class="line">10.0.2.56</span><br></pre></td></tr></table></figure><h2 id="wc：统计文件的行数、单词数或字节数"><a href="#wc：统计文件的行数、单词数或字节数" class="headerlink" title="wc：统计文件的行数、单词数或字节数"></a>wc：统计文件的行数、单词数或字节数</h2><p>wc命令用于统计文件的行数、单词数或字节数。</p><p><strong>语法格式：wc [option] [file]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/04/20/5cbb0c7696443.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）查看文件的字节数、字数、行数等</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看/etc/hosts的统计值（字节数、字数、行数等）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 什么参数都不加时，显示的三个数字从左到右分别是行数，单词数和字节数</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># wc /etc/hosts</span></span><br><span class="line">2  10 158 /etc/hosts</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示文件的字节数</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># wc -c /etc/hosts</span></span><br><span class="line">158 /etc/hosts</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示文件的单词数</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># wc -w /etc/hosts</span></span><br><span class="line">10 /etc/hosts</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示文件的行数</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># wc -l /etc/hosts</span></span><br><span class="line">2 /etc/hosts</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示文件最长行的长度</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># wc -L /etc/hosts</span></span><br><span class="line">78 /etc/hosts</span><br></pre></td></tr></table></figure><p><strong>2）在shell脚本常用来判断某个软件包是否安装</strong></p><p><img src="https://i.loli.net/2019/04/20/5cbb0cd6eb1a6.jpg"></p><h2 id="diff：比较两个文件的不同"><a href="#diff：比较两个文件的不同" class="headerlink" title="diff：比较两个文件的不同"></a>diff：比较两个文件的不同</h2><p>diff命令可以逐行比较纯文本文件的内容，并输出文件的差异。只能同时比较2个文件。</p><p><strong>语法格式：diff [option] [file1] [file2]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/04/20/5cbb0ceb49eaf.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）比较两个文本文件</strong></p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 将data003文件去重后生成一个新文件data004</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; [root@C7-Server01 kkutysllb]<span class="comment"># sort data003 | uniq &gt; data004</span></span><br><span class="line">&gt; [root@C7-Server01 kkutysllb]<span class="comment"># cat data004</span></span><br><span class="line">&gt; 10.0.2.1</span><br><span class="line">&gt; 10.0.2.11</span><br><span class="line">&gt; 10.0.2.14</span><br><span class="line">&gt; 10.0.2.2</span><br><span class="line">&gt; 10.0.2.3</span><br><span class="line">&gt; 10.0.2.5</span><br><span class="line">&gt; 10.0.2.56</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 比较data003和data004两个文件</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; [root@C7-Server01 kkutysllb]<span class="comment"># diff data003 data004</span></span><br><span class="line">&gt; 2,5d1   <span class="comment"># 以data003为基准，data003比data004多了2,3,4,5行，所以data003的2-5行需要删除</span></span><br><span class="line">&gt; &lt; 10.0.2.56</span><br><span class="line">&gt; &lt; 10.0.2.3</span><br><span class="line">&gt; &lt; 10.0.2.5</span><br><span class="line">&gt; &lt; 10.0.2.14</span><br><span class="line">&gt; 7c3  <span class="comment"># 以data003为基准，其第7行对应data004的第3行，两者结果不一致，需要修改</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">## &lt; 10.0.2.2</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; &gt; 10.0.2.14</span><br><span class="line">&gt; &gt; 10,13c6,7  <span class="comment"># 以data003为基准，其第10,11行对应data004的第6,7行，两者结果不一致，需要修改。同时，data003多了12,13两行内容</span></span><br><span class="line">&gt; &gt; &lt; 10.0.2.11</span><br><span class="line">&gt; &gt; &lt; 10.0.2.1</span><br><span class="line">&gt; &gt; &lt; 10.0.2.1</span><br><span class="line">&gt; &gt; &lt; 10.0.2.1</span><br><span class="line">&gt; </span><br><span class="line">&gt; ------</span><br><span class="line">&gt; </span><br><span class="line">&gt; &gt; 10.0.2.5</span><br><span class="line">&gt; &gt; 10.0.2.56</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><p><strong>2） 并排格式输出</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用-y选项就可以并排格式输出对比</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># diff -y data003 data004</span></span><br><span class="line">10.0.2.110.0.2.1</span><br><span class="line">10.0.2.56      &lt;</span><br><span class="line">10.0.2.3      &lt;</span><br><span class="line">10.0.2.5      &lt;</span><br><span class="line">10.0.2.14      &lt;</span><br><span class="line">10.0.2.1110.0.2.11</span><br><span class="line">10.0.2.2      |10.0.2.14</span><br><span class="line">10.0.2.210.0.2.2</span><br><span class="line">10.0.2.310.0.2.3</span><br><span class="line">10.0.2.11      |10.0.2.5</span><br><span class="line">10.0.2.1      |10.0.2.56</span><br><span class="line">10.0.2.1      &lt;</span><br><span class="line">10.0.2.1      &lt;</span><br></pre></td></tr></table></figure><p><strong>3） 使用-c选项就可以上下文输出</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -表示data004比data003少的行数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># +表示data004比data003多的行数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># !表示两者不一样的行数</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># diff -c data003 data004</span></span><br><span class="line">*** data0032019-04-20 15:44:51.488782009 +0800</span><br><span class="line">--- data0042019-04-20 17:21:03.569053069 +0800</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">  *** 1,13 ****</span><br><span class="line">    10.0.2.1</span><br><span class="line"></span><br><span class="line">- 10.0.2.56</span><br><span class="line">  - 10.0.2.3</span><br><span class="line">  - 10.0.2.5</span><br><span class="line">  - 10.0.2.14</span><br><span class="line">    10.0.2.11</span><br><span class="line">    ! 10.0.2.2</span><br><span class="line">    10.0.2.2</span><br><span class="line">    10.0.2.3</span><br><span class="line">    ! 10.0.2.11</span><br><span class="line">    ! 10.0.2.1</span><br><span class="line">    ! 10.0.2.1</span><br><span class="line">    ! 10.0.2.1</span><br><span class="line">    --- 1,7 ----</span><br><span class="line">    10.0.2.1</span><br><span class="line">    10.0.2.11</span><br><span class="line">    ! 10.0.2.14</span><br><span class="line">    10.0.2.2</span><br><span class="line">    10.0.2.3</span><br><span class="line">    ! 10.0.2.5</span><br><span class="line">    ! 10.0.2.56</span><br></pre></td></tr></table></figure><p>​    </p><p><strong>小练习：除了diff指令可以比较两个文件外，vimdiff指令还可以可视化比较两个文件，大家自行研究。</strong></p><h2 id="tee：多重定向"><a href="#tee：多重定向" class="headerlink" title="tee：多重定向"></a>tee：多重定向</h2><p>tee命令用于将数据重定向到文件，同时提供一份重定向数据的副本作为后续命令的标准输入。简单地说就是把数据重定向到给定文件和屏幕上。</p><p><strong>语法格式：tee [option] [file]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/04/20/5cbb0d47b66ac.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）tee命令允许标准输出同时把内容写入（覆盖）到文件中</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示当前目录下内容详细信息，并将结果写入到data005文件中（如果data005文件不存在，则直接创建，否则将内容覆盖原文件内容）</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># ls -lhi | tee data005</span></span><br><span class="line">total 28K</span><br><span class="line">1231037 -rw-r--r--  1 root root   0 Apr 16 18:35 202012312234.55</span><br><span class="line">34100198 drwxr-xr-x  5 root root  45 Apr 17 11:59 data</span><br><span class="line">1231031 -rw-r--r--  1 root root  54 Apr 19 17:14 data001</span><br><span class="line">1231047 -rw-r--r--  1 root root  73 Apr 19 17:31 data002</span><br><span class="line">1231030 -rw-r--r--  1 root root 121 Apr 20 15:44 data003</span><br><span class="line">1231056 -rw-r--r--  1 root root  66 Apr 20 17:21 data004</span><br><span class="line">1231024 -rw-r--r--  1 root root   0 Apr 20 17:41 data005</span><br><span class="line">1231057 drwxr-xr-x  5 root root  45 Apr 17 11:59 data_tmp</span><br><span class="line">33583813 -rw-r--r--. 1 root root 158 Jun  7  2013 hard_link</span><br><span class="line">1231054 -rw-r--r--  1 root root   0 Apr 16 17:56 image008</span><br><span class="line">1231055 -rw-r--r--  1 root root   0 Apr 16 17:56 image009</span><br><span class="line">1231032 -rw-r--r--  1 root root   0 Apr 17 11:46 image010</span><br><span class="line">1231039 drwxr-xr-x  2 root root   6 Apr 16 14:30 mytest</span><br><span class="line">1231043 lrwxrwxrwx  1 root root  10 Apr 17 14:04 soft_link -&gt; /etc/hosts</span><br><span class="line">1231022 -rw-r--r--  1 root root   0 Apr 20 17:10 test01</span><br><span class="line">1231025 -rw-r--r--  1 root root  82 Apr 20 17:08 test01.sh</span><br><span class="line">1231052 -rw-r--r--  1 root root 114 Apr 19 18:03 test.sh</span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># cat -n data005</span></span><br><span class="line">1total 28K</span><br><span class="line">2 1231037 -rw-r--r--  1 root root   0 Apr 16 18:35 202012312234.55</span><br><span class="line">334100198 drwxr-xr-x  5 root root  45 Apr 17 11:59 data</span><br><span class="line">4 1231031 -rw-r--r--  1 root root  54 Apr 19 17:14 data001</span><br><span class="line">5 1231047 -rw-r--r--  1 root root  73 Apr 19 17:31 data002</span><br><span class="line">6 1231030 -rw-r--r--  1 root root 121 Apr 20 15:44 data003</span><br><span class="line">7 1231056 -rw-r--r--  1 root root  66 Apr 20 17:21 data004</span><br><span class="line">8 1231024 -rw-r--r--  1 root root   0 Apr 20 17:41 data005</span><br><span class="line">9 1231057 drwxr-xr-x  5 root root  45 Apr 17 11:59 data_tmp</span><br><span class="line">1033583813 -rw-r--r--. 1 root root 158 Jun  7  2013 hard_link</span><br><span class="line">11 1231054 -rw-r--r--  1 root root   0 Apr 16 17:56 image008</span><br><span class="line">12 1231055 -rw-r--r--  1 root root   0 Apr 16 17:56 image009</span><br><span class="line">13 1231032 -rw-r--r--  1 root root   0 Apr 17 11:46 image010</span><br><span class="line">14 1231039 drwxr-xr-x  2 root root   6 Apr 16 14:30 mytest</span><br><span class="line">15 1231043 lrwxrwxrwx  1 root root  10 Apr 17 14:04 soft_link -&gt; /etc/hosts</span><br><span class="line">16 1231022 -rw-r--r--  1 root root   0 Apr 20 17:10 test01</span><br><span class="line">17 1231025 -rw-r--r--  1 root root  82 Apr 20 17:08 test01.sh</span><br><span class="line">18 1231052 -rw-r--r--  1 root root 114 Apr 19 18:03 test.sh</span><br></pre></td></tr></table></figure><p><strong>2）tee命令允许标准输出同时把内容追加到文件中</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"># 使用-a选项，会将内容追加到目标文件最后</span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]# ls -lhi /boot | tee -a data005</span><br><span class="line">total 123M</span><br><span class="line">    72 -rw-r--r--. 1 root root 145K Apr 21  2018 config-3.10.0-862.el7.x86_64</span><br><span class="line">    81 -rw-r--r--  1 root root 149K Mar 18 23:10 config-3.10.0-957.10.1.el7.x86_64</span><br><span class="line">    67 drwxr-xr-x. 3 root root   17 Apr  7 20:33 efi</span><br><span class="line">    68 drwxr-xr-x. 2 root root   27 Apr  7 20:34 grub</span><br><span class="line"><span class="symbol">786496 </span>drwx------. <span class="number">5</span> root root  <span class="number">132</span> Apr <span class="number">20</span> <span class="number">16</span>:<span class="number">09</span> grub2</span><br><span class="line">    76 -rw-------. 1 root root  50M Apr  7 20:38 initramfs-0-rescue-e344b139f44946638783478bcb51f820.img</span><br><span class="line">    75 -rw-------  1 root root  19M Apr 20 16:09 initramfs-3.10.0-862.el7.x86_64.img</span><br><span class="line">    78 -rw-------  1 root root  11M Apr 20 16:08 initramfs-3.10.0-862.el7.x86_64kdump.img</span><br><span class="line">    84 -rw-------  1 root root  19M Apr 20 16:09 initramfs-3.10.0-957.10.1.el7.x86_64.img</span><br><span class="line">    73 -rw-r--r--. 1 root root 298K Apr 21  2018 symvers-3.10.0-862.el7.x86_64.gz</span><br><span class="line">    82 -rw-r--r--  1 root root 307K Mar 18 23:10 symvers-3.10.0-957.10.1.el7.x86_64.gz</span><br><span class="line">    71 -rw-------. 1 root root 3.3M Apr 21  2018 System.map-3.10.0-862.el7.x86_64</span><br><span class="line">    80 -rw-------  1 root root 3.4M Mar 18 23:10 System.map-3.10.0-957.10.1.el7.x86_64</span><br><span class="line">    77 -rwxr-xr-x. 1 root root 6.0M Apr  7 20:38 vmlinuz-0-rescue-e344b139f44946638783478bcb51f820</span><br><span class="line">    74 -rwxr-xr-x. 1 root root 6.0M Apr 21  2018 vmlinuz-3.10.0-862.el7.x86_64</span><br><span class="line">    83 -rwxr-xr-x  1 root root 6.4M Mar 18 23:10 vmlinuz-3.10.0-957.10.1.el7.x86_64</span><br><span class="line">[root@C7-Server01 kkutysllb]# </span><br><span class="line">[root@C7-Server01 kkutysllb]# cat -n data005</span><br><span class="line">     1total 28K</span><br><span class="line">     2 1231037 -rw-r--r--  1 root root   0 Apr 16 18:35 202012312234.55</span><br><span class="line">     334100198 drwxr-xr-x  5 root root  45 Apr 17 11:59 data</span><br><span class="line">     4 1231031 -rw-r--r--  1 root root  54 Apr 19 17:14 data001</span><br><span class="line">     5 1231047 -rw-r--r--  1 root root  73 Apr 19 17:31 data002</span><br><span class="line">     6 1231030 -rw-r--r--  1 root root 121 Apr 20 15:44 data003</span><br><span class="line">     7 1231056 -rw-r--r--  1 root root  66 Apr 20 17:21 data004</span><br><span class="line">     8 1231024 -rw-r--r--  1 root root   0 Apr 20 17:41 data005</span><br><span class="line">     9 1231057 drwxr-xr-x  5 root root  45 Apr 17 11:59 data_tmp</span><br><span class="line">    1033583813 -rw-r--r--. 1 root root 158 Jun  7  2013 hard_link</span><br><span class="line">    11 1231054 -rw-r--r--  1 root root   0 Apr 16 17:56 image008</span><br><span class="line">    12 1231055 -rw-r--r--  1 root root   0 Apr 16 17:56 image009</span><br><span class="line">    13 1231032 -rw-r--r--  1 root root   0 Apr 17 11:46 image010</span><br><span class="line">    14 1231039 drwxr-xr-x  2 root root   6 Apr 16 14:30 mytest</span><br><span class="line">    15 1231043 lrwxrwxrwx  1 root root  10 Apr 17 14:04 soft_link -&gt; /etc/hosts</span><br><span class="line">    16 1231022 -rw-r--r--  1 root root   0 Apr 20 17:10 test01</span><br><span class="line">    17 1231025 -rw-r--r--  1 root root  82 Apr 20 17:08 test01.sh</span><br><span class="line">    18 1231052 -rw-r--r--  1 root root 114 Apr 19 18:03 test.sh</span><br><span class="line">    19total 123M</span><br><span class="line">    20    72 -rw-r--r--. 1 root root 145K Apr 21  2018 config-3.10.0-862.el7.x86_64</span><br><span class="line">    21    81 -rw-r--r--  1 root root 149K Mar 18 23:10 config-3.10.0-957.10.1.el7.x86_64</span><br><span class="line">    22    67 drwxr-xr-x. 3 root root   17 Apr  7 20:33 efi</span><br><span class="line">    23    68 drwxr-xr-x. 2 root root   27 Apr  7 20:34 grub</span><br><span class="line">    24786496 drwx------. 5 root root  132 Apr 20 16:09 grub2</span><br><span class="line">    25    76 -rw-------. 1 root root  50M Apr  7 20:38 initramfs-0-rescue-e344b139f44946638783478bcb51f820.img</span><br><span class="line">    26    75 -rw-------  1 root root  19M Apr 20 16:09 initramfs-3.10.0-862.el7.x86_64.img</span><br><span class="line">    27    78 -rw-------  1 root root  11M Apr 20 16:08 initramfs-3.10.0-862.el7.x86_64kdump.img</span><br><span class="line">    28    84 -rw-------  1 root root  19M Apr 20 16:09 initramfs-3.10.0-957.10.1.el7.x86_64.img</span><br><span class="line">    29    73 -rw-r--r--. 1 root root 298K Apr 21  2018 symvers-3.10.0-862.el7.x86_64.gz</span><br><span class="line">    30    82 -rw-r--r--  1 root root 307K Mar 18 23:10 symvers-3.10.0-957.10.1.el7.x86_64.gz</span><br><span class="line">    31    71 -rw-------. 1 root root 3.3M Apr 21  2018 System.map-3.10.0-862.el7.x86_64</span><br><span class="line">    32    80 -rw-------  1 root root 3.4M Mar 18 23:10 System.map-3.10.0-957.10.1.el7.x86_64</span><br><span class="line">    33    77 -rwxr-xr-x. 1 root root 6.0M Apr  7 20:38 vmlinuz-0-rescue-e344b139f44946638783478bcb51f820</span><br><span class="line">    34    74 -rwxr-xr-x. 1 root root 6.0M Apr 21  2018 vmlinuz-3.10.0-862.el7.x86_64</span><br><span class="line">    35    83 -rwxr-xr-x  1 root root 6.4M Mar 18 23:10 vmlinuz-3.10.0-957.10.1.el7.x86_64</span><br></pre></td></tr></table></figure><p><strong>3）tee还有个用法类似cat的创建/追加文件的用法，区别是不需要添加输出重定向符号</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建docker.service.d目录</span></span><br><span class="line"></span><br><span class="line">mkdir /etc/systemd/system/docker.service.d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在docker.service.d/目录下创建一个kolla.conf文件，并完成相应配置</span></span><br><span class="line"></span><br><span class="line">tee /etc/systemd/system/docker.service.d/kolla.conf &lt;&lt; <span class="string">'EOF'</span></span><br><span class="line">[Service]</span><br><span class="line">MountFlags=shared</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h2 id="tr：替换或删除字符"><a href="#tr：替换或删除字符" class="headerlink" title="tr：替换或删除字符"></a>tr：替换或删除字符</h2><p>tr命令从标准输入中替换、缩减或删除字符，并将结果写到标准输出。</p><p><strong>语法格式：tr [option] [SET1] [SET2]</strong></p><p><strong>重要选项参数</strong></p><p><img src="https://i.loli.net/2019/04/20/5cbb0da12a5e2.jpg"></p><p><strong>【使用示例】</strong></p><p><strong>1）将文件中出现的“www”替换为“xyz”</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成测试文件</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># tee data005 &lt;&lt; 'EOF'</span></span><br><span class="line"></span><br><span class="line">&gt; www.sina.com.cn</span><br><span class="line">&gt; www.aliyun.com</span><br><span class="line">&gt; www.chinamobile.com</span><br><span class="line">&gt; www.openstack.org</span><br><span class="line">&gt; www.tsinghua.edu.cn</span><br><span class="line">&gt; kkutysllb.cn</span><br><span class="line">&gt; EOF</span><br><span class="line">&gt; www.sina.com.cn</span><br><span class="line">&gt; www.aliyun.com</span><br><span class="line">&gt; www.chinamobile.com</span><br><span class="line">&gt; www.openstack.org</span><br><span class="line">&gt; www.tsinghua.edu.cn</span><br><span class="line">&gt; kkutysllb.cn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不使用任何选项参数时，默认按照set1和set2的对应字符位置替换</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面的例子w对应z，所有全部替换为z</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># tr 'www' 'xyz' &lt; data005</span></span><br><span class="line">zzz.sina.com.cn</span><br><span class="line">zzz.aliyun.com</span><br><span class="line">zzz.chinamobile.com</span><br><span class="line">zzz.openstack.org</span><br><span class="line">zzz.tsinghua.edu.cn</span><br><span class="line">kkutysllb.cn</span><br></pre></td></tr></table></figure><p><strong>2）使用tr命令“统一”字母大小写</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个例子中使用了正则的匹配规则，后续正则表达式会专门讲解</span></span><br><span class="line"></span><br><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># tr '[a-z]' '[A-Z]' &lt; data005</span></span><br><span class="line">WWW.SINA.COM.CN</span><br><span class="line">WWW.ALIYUN.COM</span><br><span class="line">WWW.CHINAMOBILE.COM</span><br><span class="line">WWW.OPENSTACK.ORG</span><br><span class="line">WWW.TSINGHUA.EDU.CN</span><br><span class="line">KKUTYSLLB.CN</span><br></pre></td></tr></table></figure><p><strong>3）删除所有的点”.”</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># tr -d "." &lt; data005</span></span><br><span class="line">wwwsinacomcn</span><br><span class="line">wwwaliyuncom</span><br><span class="line">wwwchinamobilecom</span><br><span class="line">wwwopenstackorg</span><br><span class="line">wwwtsinghuaeducn</span><br><span class="line">kkutysllbcn</span><br></pre></td></tr></table></figure><p><strong>4）将所有的非w字符替换为&amp;</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@C7-Server01 kkutysllb]<span class="comment"># tr -c 'w' '&amp;' &lt; data005</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 除w字符外，其它所有字符被替换为&amp;，包括换行符\n和制表符\t</span></span><br><span class="line"></span><br><span class="line">www&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;www&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;www&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;www&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;www&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span><br></pre></td></tr></table></figure><p><strong>小练习：想想怎么使用br指令完成整单词替换？</strong></p><h2 id="vi-vim编辑器"><a href="#vi-vim编辑器" class="headerlink" title="vi/vim编辑器"></a>vi/vim编辑器</h2><p>vi是Linux命令行界面下的文字编辑器，几乎所有的Linux系统都安装了vi，只要学会了vi这个编辑工具，就可以在任何Linux系统上使用它。而vim是vi命令的增强版（Vi IMproved），与vi编辑器完全兼容，此外还有很多增强功能，例如用不同颜色高亮显示代码。因此，如果系统有vim命令，那么建议大家就使用vim编辑文本。</p><p><strong>语法格式：vim [option] [file]</strong></p><p><strong>【vim的三种模式】</strong></p><p>一般来说，vim可分为三种模式：普通模式、编辑模式、命令模式。这三种模式的作用分别如下。</p><p>（1）普通模式</p><p>用vim命令打开一个文件，默认的状态就是普通模式。在这个模式中，不能进行编辑输入操作，但可以按“上下左右”键来移动光标，也可以执行一些操作命令进行如删除、复制、粘贴等之类的工作。</p><p>（2）编辑模式</p><p>在普通模式下不能进行编辑输入操作，只有按下“i，I，o，O，a，A，r，R，s，S”（其中“I”最常用）等字母进入编辑模式之后才可以执行录入文字等编辑操作。看文件是否处于编辑模式状态有一个重要的特征，那就是在窗口的左下角要有插入的标记“——INSERT——”或“——插入——”，如下图所示：</p><p><img src="https://i.loli.net/2019/04/20/5cbb0e38b205b.jpg"></p><p>（3）命令模式</p><p>在普通模式下，输入“：”或“/”或“?”时，光标会自动定位在那一行，在这个模式中，可以执行保存、退出、搜索、替换、显示行号等相关操作。如下图所示：</p><p><img src="https://i.loli.net/2019/04/20/5cbb0e5093673.jpg"></p><p><strong>【vi/vim的操作示意图</strong>】</p><p><img src="https://i.loli.net/2019/04/20/5cbb0e68e47fd.jpg"></p><p><strong>1）进入编辑模式指令</strong></p><ul><li>i：在当前光标所在处输入文字</li><li>a：在当前光标所在的下一个字符处插入文字</li><li>I：在当前所在行的行首第一个非空格字符处开始插入文字、和A相反</li><li>A：在当前所在行的行尾最后一个字符处开始插入文字，和I相反</li><li>O：在当前所在行的上一行处插入新的一行</li><li>o：在当前所在行的下一行处插入新的一行</li><li>Esc：退出编辑模式，回到命令模式中。</li></ul><p><strong>2）命令行模式下指令</strong></p><ul><li>:wq：退出并保存</li><li>:wq!：退出并强制保存。</li><li>:q!：强制退出，不保存</li><li>:n1,n2,w filename：n1、n2为数字，将n1行到n2行的内容保存成filename这个文件。</li><li>:n1,n2 co n3：n1、n2为数字，将n1行到n2行内容拷贝到n3位置下。</li><li>:n1,n2 m n3：n1、n2为数字，将n1行到n2行的内容移动到n3位置下。</li><li>:!command：暂时离开vi到命令行模式下执行command的显示结果</li><li>:set nu：显示行号</li><li>:set nonu：与set nu相反，取消行号</li><li>:vs filename：垂直分屏显示，同时显示当前文件和filename对应文件的内容</li><li>:sp filename：水平分屏显示，同时当前文件和filename对应文件的内容</li><li>I+#+ESC：在可视模式下（Ctrl+v），一次性注释所选的多行，取消注释可用n1,n2s/#//gc。这里操作是一个通用操作，#可以换成tab键，这样可以实现批量缩进</li><li>Del：在可视块模式下（Ctrl+v），一次性删除所选内容</li><li>r：在可视块模式下（Ctrl+v），一次性替换所选内容</li></ul><p><strong>【常用操作】</strong></p><p><strong>1）普通模式下移动光标的操作</strong></p><ul><li>G：将光标自动文件的最后一行</li><li>gg：将光标移动文件的第一行</li><li>0：数字0，将光标从所在位置移动到当前行的开头</li><li>$：从光标所在位置移动到当前行的结尾</li><li>n<enter>：n为数字，<enter>为回车键，将光标从当前位置向下移动n行</enter></enter></li><li>ngg：n为数字，移动光标到文件的第n行</li><li>H：光标移动当前窗口最上方那一行</li><li>M：光标移动到当前窗口中间的那一行</li><li>L：光标移动到当前窗口最下方的那一行</li><li>h或向左箭头：光标向左移动一个字符</li><li>j或向下箭头：光标向下移动一个字符</li><li>k或向上箭头：光标向上移动一个字符</li><li>l或向右箭头：光标向右移动一个字符</li></ul><p><strong>2）普通模式下搜索与替换操作：</strong></p><ul><li>/关键字：从光标位置开始向下搜索关键字行</li><li>?关键字：从光标位置开始向上搜索关键字</li><li>n：从光标位置开始，向下重复前一个搜索的动作</li><li>N：从光标位置开始，向上重复前一个搜索的动作</li><li>:g/A/s/B/g：把符合A的内容全部替换为B，左斜线为分隔符，可以用@、#等替换</li><li>:%s/A/B/g：把符合A的内容全部替换为B，左斜线为分隔符，可以用@、#等替换。</li><li>:n1,n2s/A/B/gc：n1、n2为数字，在第n1行和n2行间寻找A，用B替换</li></ul><p><strong>3）普通模式下复制、粘贴、删除等操作</strong></p><ul><li>yy：复制光标所在行的全部内容</li><li>nyy：n为数字，复制光标开始向下共n行的内容</li><li>p/P：p将已复制的数据粘贴到光标的下一行，P则为粘贴到光标的上一行</li><li>dd：删除所在的当前行</li><li>ndd：n为数字，删除从光标开始向下的共n行。</li><li>u：恢复（回滚）前一个执行过的操作</li><li>.：点号。重复前一个执行过的动作</li><li>%：向后删除字符</li><li>X：向前删除字符</li><li>d1G：删除当前行至第一行</li><li>dG：删除当前行至最后一行</li><li>d0：删除当前光标文本至行首</li><li>d$：删除当前光标文本至行尾</li></ul><p><strong>vi/vim编辑器是Linux运维、开发、测试中最常用的工具，需要大家重点掌握。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;cat：合并文件或查看文件内容&quot;&gt;&lt;a href=&quot;#cat：合并文件或查看文件内容&quot; class=&quot;headerlink&quot; title=&quot;cat：合并文件或查看文件内容&quot;&gt;&lt;/a&gt;cat：合并文件或查看文件内容&lt;/h2&gt;&lt;p&gt;cat命令可以理解为英文单词concatenate的缩写，其功能是连接多个文件并且打印到屏幕输出，或者重定向到指定的文件中。此命令常用来显示单个文件内容，或者将几个文件内容连接起来一起显示，还可以从标准输入中读取内容并显示，生产环境中它常与重定向或追加符号配合使用。
    
    </summary>
    
      <category term="Linux核心命令" scheme="https://kkutysllb.cn/categories/Linux%E6%A0%B8%E5%BF%83%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Linux" scheme="https://kkutysllb.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>2019-04-19-中国移动NovoNet2020</title>
    <link href="https://kkutysllb.cn/2019/04/19/2019-04-19-%E4%B8%AD%E5%9B%BD%E7%A7%BB%E5%8A%A8NovoNet2020/"/>
    <id>https://kkutysllb.cn/2019/04/19/2019-04-19-中国移动NovoNet2020/</id>
    <published>2019-04-19T03:14:23.000Z</published>
    <updated>2019-04-19T03:54:35.196Z</updated>
    
    <content type="html"><![CDATA[<p>2015年7月，中国移动发布了NovoNet 2020愿景，推出下一代革新网络NovoNet，2016—2020年将成为中国移动SDN/NFV技术的关键部署期。中国移动希望利用SDN、NFV等新技术，构建一张资源可全局调度、能力可全面开放、容量可弹性伸缩、架构可灵活调整的新一代网络，满足“互联网+”、物联网等创新型业务对通信网络的需求。<a id="more"></a></p><p><img src="https://i.loli.net/2019/04/19/5cb946747cb72.jpg"></p><h2 id="中国移动网络重构战略"><a href="#中国移动网络重构战略" class="headerlink" title="中国移动网络重构战略"></a>中国移动网络重构战略</h2><p>中国移动NovoNet的核心发展理念是实现网络的“三化”和“三可”，即网络功能部署的软件化、虚拟资源的共享化、硬件基础设施的通用化，同时达到网络开放可编程、控制转发可解耦、功能编排可调度的能力，以便在移动网络、IP承载网络、传送网络、数据中心等领域实现网络和业务的虚拟化、软件化。</p><p>中国移动NovoNet的愿景是实现网络可编程、部署更灵活、调度更高效、网络更智能、服务更开放、成本更低廉的总体效果，通过SDN和NFV两大基础技术，在网络架构、运营管理和网络开放等层面持续优化网络和服务。</p><p><strong>网络架构</strong></p><p><img src="https://i.loli.net/2019/04/19/5cb9453ade41d.jpg"></p><blockquote><p><strong>1、 网络功能软件化</strong></p><p>将软件和硬件解耦，网元功能以软件部署在通用硬件平台上，实现业务的快速部署和升级，有利于运营商快速满足客户的业务需求。</p><p><strong>2、资源共享化</strong></p><p>借助NFV技术，实现硬件资源的通用化和虚拟资源的共享化，可以降低硬件件成本，实现资源的灵活配置和调度，有利于运营商开发创新业务并灵活部署。</p><p><strong>3、 网络可编程</strong></p><p>应用SDN技术，将网络控制与物理网络拓扑分离，实现网络可编程，有利于快速响应和满足用户的业务需求，最大化利用运营商的网络资源。</p></blockquote><p><strong>网络运营管理</strong></p><p>在2017全球未来网络发展峰会网络重构与转型论坛上，中国移动通信研究院副院长杨志强明确指出，5G和固定宽带业务将会成为运营商未来网络的核心应用，在开源软件和硬件的基础上进行自主研发和运营将成为新的主流运营模式。</p><p><img src="https://i.loli.net/2019/04/19/5cb9457cee35e.jpg"></p><blockquote><p><strong>1、集中控制</strong></p><p>网络功能的控制和调度通过软件完成，提升网络的调度优化能力，可以逐步实现面向全局最优的网络管理和简化网络运维。</p><p><strong>2、灵活调度</strong></p><p>实现业务部署、业务资源的动态调度，可快速、灵活调度网络资源，应对网络故障、突发事件等。</p><p><strong>3、绿色节能</strong></p><p>根据业务量需求动态调度网络资源，并可实现高效率集中控制，大幅提升网络资源的利用效率，构建绿色节能的通信网络。</p></blockquote><p><strong>网络服务</strong></p><p><img src="https://i.loli.net/2019/04/19/5cb9459d9a22a.jpg"></p><blockquote><p><strong>1、全面开放的服务</strong></p><p>提供全面的开放能力，构建与第三方业务开发者合作共赢的生态环境，全面服务“互联网+”。</p><p><strong>2、高效敏捷的服务</strong></p><p>具备完善的业务部署和调度能力，能够有效疏导网络流量、对业务提供完善的生命周期管理能力，支持业务的快速迭代、灵活部署、高效使用。</p><p><strong>3、按需调度的服务</strong></p><p>计算、存储、网络资源可全局调度，网络可动态编程，可根据用户、业务的需求动态调配资源。</p></blockquote><h2 id="中国移动网络重构目标"><a href="#中国移动网络重构目标" class="headerlink" title="中国移动网络重构目标"></a>中国移动网络重构目标</h2><p>中国移动将SDN/NFV作为网络重构的技术基础，实现基础设施云化、网元功能软件化以及运营管理智能化。未来网络的核心是通过SDN/NFV的引入，实现网络的软件化、资源池化、集中控制、灵活的编排与调度，构建云化的部署形态、智能化的网络调度、全局化的网络编排管理。</p><blockquote><p>（1）引入网络功能虚拟化（NFV）技术，采用IT通用服务器构建资源池，电信设备软硬解耦，以软件形成电信云，并支撑内容分发、边缘计算等。</p><p>（2）引入软件定义网络（SDN）技术，采用控制转发分离和路由集中计算，实现网络灵活、智能调度和网络能力的开放。</p><p>（3）引入协同编排技术，实现跨领域、端到端的全网资源、网元和流量流向的管理编排与调度。</p></blockquote><p>中国移动网络重构主要包括节点重构、架构重构、网元功能重构以及网络管理与业务运营重构四个方面。</p><p><img src="https://i.loli.net/2019/04/19/5cb945d6c35ee.jpg"></p><p><strong>节点重构</strong></p><p>构建云化数据中心，替代传统的核心网机房。云化数据中心采用标准化和微模块方式构建，易于快速复制部署，是电信云的基本组件和满足电信网络要求的关键基础设施，可以承载各类虚拟化的电信类软件应用。</p><blockquote><p>① 标准化的组网：以电信标准为基准的更为严格的网段隔离和网络平面划分原则，业务、管理、基础设施平面独立。</p><p>② 标准化的基础设施：硬件采用通用的X86硬件架构，增强性能要求和电信级管理要求；以统一的云操作系统支持统一的虚拟层指标要求；以电信级增强的OpenStack/VIM实现云资源的管理和分配。</p><p>③ 统一的管理编排体系：以整合的NFVO和SDN编排器和控制器作为统一的管理编排体系。</p></blockquote><p><strong>架构重构</strong></p><blockquote><p>① 构建基础设施资源池：分布式部署云化数据中心，形成基础设施资源池，承载不同的网络功能。</p><p>② 控制功能集中化：网络控制功能集中在核心云数据中心。</p><p>③ 媒体面下沉：靠近接入点设置边缘云数据中心，将大流量的媒体内容调度到网络边缘，实现快速疏导，提升用户体验。</p></blockquote><p><strong>网元功能重构</strong></p><p>通过基于服务的网络架构、切片、控制转发分离等，结合云化技术，实现网络的定制化、开放化、服务化，支持大流量、大连接和低时延的万物互联需求。</p><blockquote><p>① 用户面功能可实现灵活部署和独立扩缩容，采用集中式部署支持广域移动性和业务连续性，采用网络边缘部署，实现流量本地卸载，支持端到端毫秒级时延，降低回传网络和集中式用户面的处理压力。</p><p>② 网络切片提供端到端资源隔离的逻辑专网，可基于行业用户的需求，实现专网专用，基于业务场景灵活组合网络功能，灵活扩缩容，功能扩展敏捷。</p><p>③ 固网宽带业务控制设备通过转发控制分离，应对固网发展中面临的运维复杂、资源利用率低及业务开通慢等挑战。</p></blockquote><p><strong>网络管理与业务运营重构</strong></p><p>构建下一代网络编排器，实施对网络资源池的管理，完成网络和网元部署以及生命周期管理，协调SDN控制器完成网络的统一调度，实现业务的统一编排和对外开放。</p><h2 id="中国移动网络重构研发与实践"><a href="#中国移动网络重构研发与实践" class="headerlink" title="中国移动网络重构研发与实践"></a>中国移动网络重构研发与实践</h2><p>为了验证NovoNet的理念，中国移动已开展了相关研发和测试，包括研发SDN应用和控制器、SDN交换机、多厂家vIMS、vEPC软硬件解耦测试及MANO实验室验证、基于SDN网元功能重构的EPC原型验证、三层解耦的Nanocell网关测试等实验室验证。同时，中国移动也在数据中心、RCS、IMS、SPTN等领域开展了现网的试点及试商用的探索。NovoNet试验网由陕西、安徽、山东、河北、浙江、广东6个省组成，试验网的每个节点均构建两层云数据中心，用全局的编排器实现全网资源和网络的编排调度，以统一的资源池支持数据中心SDN、广域网SDN、SPTN、固网宽带、物联网、VoLTE、vCDN等多业务环境。</p><p><img src="https://i.loli.net/2019/04/19/5cb9461d0f8dd.jpg"></p><p>基于NovoNet的发展理念，中国移动加快推动SDN/NFV开源开放和相关产业发展，积极参与相关标准组织的项目推进。从2013年开始，中国移动牵头推动成立了Carrier Grade SDN工作组并任主席，参与无线和移动、光传送网、北向接口工作组标准化工作。2014年5月，中国移动与华为联合发起3GPP第一个NFV虚拟网络管理研究项目，并得到23家单位的支持。中国移动在SA1牵头发起Service Chaining立项，研究Gi-LAN场景业务链的场景和需求。2014年9月，中国移动联合国际运营商和厂商发起成立开源组织OPNFV，并出任董事会要职。2016年9月，中国移动加入领先的开源可编程、软件定义网络平台OpenDaylight项目，并利用该平台和OpenStack在其NovoDC项目中部署企业私有云服务产品。</p><p>2014年，中国移动完成7家厂商的OpenStack+SDN数据中心解决方案测试，以及2家厂商的广域网方案测试。2015年，中国移动成立Open NFV实验室，引入了15个合作厂商，进行三层解耦测试，搭建云数据中心平台，就NFV部署展开了相关实践。目前，实验室和外场均已按计划开展三层解耦的集成和测试、OPNFV开源平台测试，已搭建了多套基于多厂家NFV组件互操作的云数据中心平台，可模拟核心云数据中心和边缘云数据中心。</p><p>2015年，中国移动完成业界首次SDN+NFV的面向商用外场测试，在中国移动自有数据中心采用该架构进行了国内第一次比较全面的组合测试。</p><p><img src="https://i.loli.net/2019/04/19/5cb9463b68c48.jpg"></p><blockquote><p>① 在VoLTE和vIMS方面，中国移动进行了NFV实践，2015年-2019年连续5年在陕西、安徽、河北、广东、浙江和山东共6个城市验证了3个系统厂商以及自研产品的核心网云化的快速上线、弹性伸缩、网络快速更新等能力。</p><p>② 在虚拟化RCS（Rich Comunication Suite，富媒体通信套件）方面，中国移动融合通信业务平台（新消息、VoWiFi、业务管理功能）基于NFV架构进行部署，采用软硬件解耦方案，硬件由惠普和思科提供，中兴提供虚拟层和虚拟网元功能并完成系统集成，目前已在中国南北基地进行部署商用。</p><p>③ 在Nanocell商用方面，2016年中国移动基于NFV的4G一体化小基站（Nanocell）开始部署商用。</p></blockquote><h2 id="中国移动网络重构小结"><a href="#中国移动网络重构小结" class="headerlink" title="中国移动网络重构小结"></a>中国移动网络重构小结</h2><p>NovoNet是中国移动面向2020年的网络愿景和行动计划，NovoNet的目标形态是通过NFV和SDN技术的结合，打造以DC为部署核心、以MANO/SDN控制器体系为管理控制核心、以虚拟化和软件化实现网元功能、以SDN技术实现网络灵活调度的电信云。NovoNet是中国移动下一代网络发展的愿景，也是中国移动下一代网络发展的重大项目和平台，是中国移动对未来网络的重新定义。</p><p>标准化和开源系统是SDN和NFV发展的两个重要基石，国际合作和产业推进是NovoNet发展的助推器。中国移动正面向未来网络发展的方向，围绕着NovoNet的引入策略、技术攻关、试验验证、产业推进、测试认证五个方面全面展开工作，以开放共赢的理念从顶层设计、标准推动、开源开放等多个层面全面推动产业发展，积极构建NovoNet试验网，推动NovoNet网络技术和管理成熟。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2015年7月，中国移动发布了NovoNet 2020愿景，推出下一代革新网络NovoNet，2016—2020年将成为中国移动SDN/NFV技术的关键部署期。中国移动希望利用SDN、NFV等新技术，构建一张资源可全局调度、能力可全面开放、容量可弹性伸缩、架构可灵活调整的新一代网络，满足“互联网+”、物联网等创新型业务对通信网络的需求。
    
    </summary>
    
      <category term="NFV基础" scheme="https://kkutysllb.cn/categories/NFV%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="电信云" scheme="https://kkutysllb.cn/tags/%E7%94%B5%E4%BF%A1%E4%BA%91/"/>
    
  </entry>
  
</feed>
